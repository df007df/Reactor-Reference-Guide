[[core-features]]
= Reactor Core Features

The Reactor project main artifact is `reactor-core`, a reactive library that focuses on
the Reactive Streams specification and targets Java 8.

Reactor项目的主要工件是reactor-core一个反应式库，该库侧重于Reactive Streams规范，并针对Java 8。

Reactor introduces composable reactive types that implement `Publisher` but also provide
a rich vocabulary of operators: `Flux` and `Mono`. A `Flux` object
represents a reactive sequence of 0..N items, while a `Mono` object represents a
single-value-or-empty (0..1) result.

Reactor引入了可实现的可反应类型，这些可实现Publisher但也提供了丰富的运算符词汇：Flux和Mono。
Flux对象表示的0..N项的反应序列，而一个Mono对象表示单值或空（0..1）的结果。

This distinction carries a bit of semantic information into the type, indicating the
rough cardinality of the asynchronous processing. For instance, an HTTP request produces
only one response, so there is not much sense in doing a `count` operation. Expressing
the result of such an HTTP call as a `Mono<HttpResponse>` thus makes more sense than
expressing it as a `Flux<HttpResponse>`, as it offers only operators that are relevant to
a context of zero items or one item.

这种区别在类型中包含了一些语义信息，表明了异步处理的粗略基数。
例如，一个HTTP请求仅产生一个响应，因此进行count操作没有太大意义。
因此，将HTTP调用的结果表示为 Mono<HttpResponse>比将其表示为Flux<HttpResponse>更有意义，因为它仅提供与零项或一个项的上下文相关的运算符。

Operators that change the maximum cardinality of the processing also switch to the
relevant type. For instance, the `count` operator exists in `Flux`, but it returns a
`Mono<Long>`.

更改处理最大基数的运算符也将切换到相关类型。例如，count运算符存在于中Flux，但返回 Mono<Long>。


[[flux]]
== `Flux`, an Asynchronous Sequence of 0-N Items

The following image shows how a `Flux` transforms items:

image::https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/flux.png[Flux]

A `Flux<T>` is a standard `Publisher<T>` that represents an asynchronous sequence of 0 to N
emitted items, optionally terminated by either a completion signal or an error.
As in the Reactive Streams spec, these three types of signal translate to calls to a downstream
Subscriber's `onNext`, `onComplete`, and `onError` methods.

Flux<T>是Publisher<T>代表0到N个发射项目的异步序列的标准，可以选择通过完成信号或错误终止。
如反应式流规范中，这三种类型的信号转换为呼叫到下游Subscriber的onNext，onComplete和onError方法。

With this large scope of possible signals, `Flux` is the general-purpose reactive type.
Note that all events, even terminating ones, are optional: no `onNext` event but an
`onComplete` event represents an _empty_ finite sequence, but remove the `onComplete` and
you have an _infinite_ empty sequence (not particularly useful, except for tests around cancellation).
Similarly, infinite sequences are not necessarily empty. For example, `Flux.interval(Duration)`
produces a `Flux<Long>` that is infinite and emits regular ticks from a clock.


在这么大范围的可能信号中，Flux是通用信号类型。
请注意，所有事件，甚至是终止事件，都是可选的：没有onNext事件，但一个 onComplete事件表示一个空的有限序列，但是删除onComplete，您将获得一个无限的空序列（除了取消测试外，它不是特别有用）。
同样，无限序列不一定为空。例如，Flux.interval(Duration) 产生一个Flux<Long>无限的并且从时钟发出规则的滴答声。

[[mono]]
== `Mono`, an Asynchronous 0-1 Result

The following image shows how a `Mono` transforms an item:

image::https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/mono.png[Mono]

A `Mono<T>` is a specialized `Publisher<T>` that emits at most one item and then
(optionally) terminates with an `onComplete` signal or an `onError` signal.

Mono<T>是一个专门的Publisher<T>，最多发出一个项目，
然后（可选）以一个onComplete信号或一个onError信号终止。

It offers only a subset of the operators that are available for a `Flux`, and
some operators (notably those that combine the `Mono` with another `Publisher`)
switch to a `Flux`.
For example, `Mono#concatWith(Publisher)` returns a `Flux` while `Mono#then(Mono)`
returns another `Mono`.

它仅提供可用于Flux的运算符的一个子集，而某些运算符（特别是那些Mono与另一个结合的运算符Publisher）切换到Flux。
例如，Mono#concatWith(Publisher)返回Flux一会儿Mono#then(Mono) 返回另一个Mono。

Note that you can use a `Mono` to represent no-value asynchronous processes that only
have the concept of completion (similar to a `Runnable`). To create one, you can use an empty
`Mono<Void>`.

请注意，您可以使用 Mono表示仅具有完成概念的无值异步流程（类似于Runnable）。要创建一个，您可以使用empty Mono<Void>。

== Simple Ways to Create a Flux or Mono and Subscribe to It

The easiest way to get started with `Flux` and `Mono` is to use one of the numerous
factory methods found in their respective classes.

最简单的方式开始使用Flux和Mono是使用在各自的类别中的众多工厂方法之一。

For instance, to create a sequence of `String`, you can either enumerate them or put them
in a collection and create the Flux from it, as follows:

例如，要创建的序列String，您可以枚举它们或将它们放入集合中并从中创建Flux，如下所示：

====
[source,java]
----
Flux<String> seq1 = Flux.just("foo", "bar", "foobar");

List<String> iterable = Arrays.asList("foo", "bar", "foobar");
Flux<String> seq2 = Flux.fromIterable(iterable);
----
====

Other examples of factory methods include the following:

====
[source,java]
----
Mono<String> noData = Mono.empty(); <1>

Mono<String> data = Mono.just("foo");

Flux<Integer> numbersFromFiveToSeven = Flux.range(5, 3); <2>
----
<1> 请注意，即使工厂方法没有任何价值，它也会尊重该泛型类型.
<2> 第一个参数是范围的开始，而第二个参数是要生成的项目数.
====

When it comes to subscribing, `Flux` and `Mono` make use of Java 8 lambdas. You
have a wide choice of `.subscribe()` variants that take lambdas for different
combinations of callbacks, as shown in the following method signatures:

当谈到订阅，Flux以及Mono 采用Java 8 lambda表达式。
您可以选择多种.subscribe()类型的变体，它们针对不同的回调组合采用lambda表达式，如以下方法签名所示：

[[subscribeMethods]]
.Lambda-based subscribe variants for `Flux`
====
[source,java]
----
subscribe(); <1>

subscribe(Consumer<? super T> consumer); <2>

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer); <3>

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer); <4>

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer,
          Consumer<? super Subscription> subscriptionConsumer); <5>
----
<1>	订阅并触发序列.
<2> 为每个产生的值做点事.
<3> 处理值，但也会对错误做出反应.
<4>	处理值和错误，但在序列成功完成后还要运行一些代码.
<5> 处理值和错误并成功完成，但还要处理因subscribe调用产生的结果Subscription.
====

TIP: These variants return a reference to the subscription that you can use to cancel the
subscription when no more data is needed. Upon cancellation, the source should stop
producing values and clean up any resources it created. This cancel-and-clean-up behavior
is represented in Reactor by the general-purpose `Disposable` interface.


TIP: 这些变体返回对订阅的引用，您可以在不需要更多数据时使用该引用来取消订阅。
取消后，源应停止产生值并清除其创建的任何资源。这种取消和清理行为在Reactor中由通用Disposable接口表示。

include::subscribe-details.adoc[]

include::subscribe-backpressure.adoc[]

//the leveloffset seems to be absolute from root
include::producing.adoc[leveloffset=2]

[[schedulers]]
== Threading and Schedulers

Reactor, like RxJava, can be considered to be *concurrency-agnostic*. That is, it does not
enforce a concurrency model. Rather, it leaves you, the developer, in command. However,
that does not prevent the library from helping you with concurrency.

像RxJava一样，Reactor可以被视为与并发无关的。
也就是说，它不强制执行并发模型。相反，它使您（开发人员）处于命令状态。但是，这不会阻止你使用并发库。

Obtaining a `Flux` or a `Mono` does not necessarily mean that it runs in a dedicated
`Thread`. Instead, most operators continue working in the `Thread` on which the
previous operator executed. Unless specified, the topmost operator (the source)
itself runs on the `Thread` in which the `subscribe()` call was made. The following
example runs a `Mono` in a new thread:

获得 Flux或 Mono不一定意味着它运行在专用的Thread 中。取而代之的是，大多数运算符Thread将在先前的运算符执行时继续工作。
除非另有说明，最上面的操作（源）本身上运行，Thread其在subscribe()有人呼吁。以下示例Mono在新线程中运行：

====
[source,java]
----
public static void main(String[] args) throws InterruptedException {
  final Mono<String> mono = Mono.just("hello "); //<1>

  Thread t = new Thread(() -> mono
      .map(msg -> msg + "thread ")
      .subscribe(v -> //<2>
          System.out.println(v + Thread.currentThread().getName()) //<3>
      )
  )
  t.start();
  t.join();

}
----
<1> 该Mono<String>组装在线程main.
<2> 但是，它是在thread中订阅的Thread-0.
<3> 因此，map和onNext回调实际上都在Thread-0

====

The preceding code produces the following output:

====
[source]
----
hello thread Thread-0
----
====

In Reactor, the execution model and where the execution happens is determined by the
`Scheduler` that is used. A
https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html[`Scheduler`]
has scheduling responsibilities similar to an `ExecutorService`, but having a
dedicated abstraction lets it do more, notably acting as a clock and enabling
a wider range of implementations (virtual time for tests, trampolining or
immediate scheduling, and so on).

在Reactor中，执行模型以及执行的位置由所Scheduler使用所确定的 。
Scheduler 具有与ExecutorService相似的调度职责，但是具有专用的抽象使其可以做更多的事情，
尤其是充当时钟并支持更广泛的实现（测试的虚拟时间，蹦床或即时调度等）。

The https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html[`Schedulers`]
class has static methods that give access to the following execution contexts:
Schedulers 类有给访问以下执行上下文的静态方法：

 * No execution context (`Schedulers.immediate()`): at processing time, the submitted `Runnable`
will be directly executed, effectively running them on the current `Thread` (can be seen as a "null object" or no-op `Scheduler`).
 * A single, reusable thread (`Schedulers.single()`). Note that this method reuses the
same thread for all callers, until the Scheduler is disposed. If you want a per-call
dedicated thread, use `Schedulers.newSingle()` for each call.
* An unbounded elastic thread pool (`Schedulers.elastic()`). This one is no longer preferred
with the introduction of `Schedulers.boundedElastic()`, as it has a tendency to hide backpressure
problems and lead to too many threads (see below).
* A bounded elastic thread pool (`Schedulers.boundedElastic()`). Like its predecessor `elastic()`, it
creates new worker pools as needed and reuses idle ones. Worker pools that stay idle for too long (the default is 60s) are
also disposed. Unlike its `elastic()` predecessor, it has a cap on the number of backing threads it can create (default is number of CPU cores x 10).
Up to 100 000 tasks submitted after the cap has been reached are enqueued and will be re-scheduled when a thread becomes available
(when scheduling with a delay, the delay starts when the thread becomes available). This is a better choice for I/O blocking work.
`Schedulers.boundedElastic()` is a handy way to give a blocking process its own thread so that
it does not tie up other resources. See <<faq.wrap-blocking>>, but doesn't pressure the system too much with new threads.
* A fixed pool of workers that is tuned for parallel work (`Schedulers.parallel()`). It
creates as many workers as you have CPU cores.

 * 没有执行上下文（Schedulers.immediate()）：在处理时，提交的文件Runnable 将被直接执行，从而有效地在当前Thread上运行（可以视为“空对象”或no-op Scheduler）。

 * 单个可重用线程（Schedulers.single()）。请注意，此方法对所有调用方都使用相同的线程，直到调度程序被释放为止。如果您需要一个每次调用专用线程，请Schedulers.newSingle()为每个调用使用。

 * 无限制的弹性线程池（Schedulers.elastic()）。引入时Schedulers.boundedElastic()，不再首选该线程，因为它倾向于隐藏背压问题并导致线程过多（请参见下文）。

 * 有界的弹性线程池（Schedulers.boundedElastic()）。像其前身一样elastic()，它根据需要创建新的工作池，并重用空闲的工作池。闲置时间过长（默认值为60s）的工作池也将被丢弃。
 与之前的elastic()版本不同，它对可以创建的支持线程数进行了限制（默认值为CPU内核数x 10）。达到上限后，最多可提交10万个任务，并在线程可用时重新调度（当延迟调度时，延迟在线程可用时开始）。
 这是I / O阻止工作的更好选择。 Schedulers.boundedElastic()是一种为阻塞进程分配自己的线程的简便方法，这样它就不会占用其他资源。请参阅<<faq.wrap-blocking>>，但使用新线程不会对系统造成太大压力。

 * 已调整为并行工作的固定工作池（Schedulers.parallel()）。它创建的工作线程数量与CPU内核数量一样多。

Additionally, you can create a `Scheduler` out of any pre-existing `ExecutorService` by
using `Schedulers.fromExecutorService(ExecutorService)`. (You can also create one from an
`Executor`, although doing so is discouraged.)

此外，您可以创建一个Scheduler不存在ExecutorService的对象使用Schedulers.fromExecutorService(ExecutorService)。
（Executor尽管不建议这样做，也可以从中创建一个 。）

You can also create new instances of the various scheduler types by using the `newXXX`
methods. For example, `Schedulers.newParallel(yourScheduleName)` creates a new parallel
scheduler named `yourScheduleName`.

您还可以使用这些newXXX 方法来创建各种调度程序类型的新实例。
例如，Schedulers.newParallel(yourScheduleName)创建一个名为 yourScheduleName 的新并行调度程序。

[WARNING]
====
While `boundedElastic` is made to help with legacy blocking code if it cannot be avoided,
`single` and `parallel` are not. As a consequence, the use of Reactor blocking APIs
(`block()`, `blockFirst()`, `blockLast()` (as well as iterating over `toIterable()`
or `toStream()`) inside the default single and parallel schedulers) results in
an `IllegalStateException` being thrown.

Custom `Schedulers` can also be marked as "non blocking only" by creating instances of `Thread`
that implement the `NonBlocking` marker interface.
====

[WARNING]
====
虽然boundedElastic是帮助制造与传统的阻塞代码，如果无法避免， single而且parallel都没有。因此，使用反应器阻塞的API（ ，block()，blockFirst()（blockLast()以及遍历toIterable() 或toStream()）的默认单和并行调度器内）导致在IllegalStateException被抛出。

Schedulers通过创建Thread 实现NonBlocking标记接口的实例，也可以将Custom 标记为“仅非阻塞” 。
====

Some operators use a specific scheduler from `Schedulers` by default (and usually give
you the option of providing a different one). For instance, calling the
`Flux.interval(Duration.ofMillis(300))` factory method produces a `Flux<Long>` that ticks every 300ms.
By default, this is enabled by `Schedulers.parallel()`. The following line changes the
Scheduler to a new instance similar to `Schedulers.single()`:

某些操作员Schedulers默认情况下使用特定的调度程序（通常会为您提供提供其他调度程序的选项）。
例如，调用 Flux.interval(Duration.ofMillis(300))factory方法会产生一个Flux<Long>每300毫秒滴答一次的滴答声。
默认情况下，通过启用Schedulers.parallel()。以下行将Scheduler更改为类似于Schedulers.single()的新实例：


====
[source,java]
----
Flux.interval(Duration.ofMillis(300), Schedulers.newSingle("test"))
----
====

Reactor offers two means of switching the execution context (or `Scheduler`) in a
reactive chain: `publishOn` and `subscribeOn`. Both take a `Scheduler` and let you switch
the execution context to that scheduler. But the placement of `publishOn` in the chain
matters, while the placement of `subscribeOn` does not. To understand that difference,
you first have to remember that <<reactive.subscribe,nothing happens until you
subscribe>>.


Reactor提供了两种在反应式链中切换执行上下文（或 Scheduler）的方式：publishOn和subscribeOn。两者都使用Scheduler，让您将执行上下文切换到该调度程序。
但是publishOn在链中的位置很重要，而在链中的位置subscribeOn并不重要。要了解这种差异，您首先必须记住，<<reactive.subscribe,nothing happens until yousubscribe>>。


In Reactor, when you chain operators, you can wrap as many `Flux` and `Mono`
implementations inside one another as you need. Once you subscribe, a chain of
`Subscriber` objects is created, backward (up the chain) to the first
publisher. This is effectively hidden from you. All you can see is the outer layer of
`Flux` (or `Mono`) and `Subscription`, but these intermediate operator-specific
subscribers are where the real work happens.

在Reactor中，当您链接运算符时，可以根据需要将许多 实现Flux和Mono实现彼此包装在一起。
订阅后，一个Subscriber对象链将被创建 ，向后（向上）到第一个发布者。
这实际上对您是隐藏的。您所看到的只是Flux（和Mono）和 Subscription的外层，但是这些中间操作员特定的订户才是真正工作的地方。


With that knowledge, we can have a closer look at the `publishOn` and `subscribeOn`
operators:

有了这些知识，我们可以更详细地了解publishOnand subscribeOn 运算符

=== The `publishOn` Method

`publishOn` applies in the same way as any other operator, in the middle of the
subscriber chain. It takes signals from upstream and replays them downstream while
executing the callback on a worker from the associated `Scheduler`. Consequently, it
*affects where the subsequent operators execute* (until another `publishOn` is
chained in), as follows:

publishOn在订户链的中间以与任何其他运营商相同的方式应用。它从上游获取信号并在下游重播它们，同时在关联的上对worker执行回调Scheduler。
因此，它 会影响后续运算符的执行位置（直到publishOn链接另一个运算符），如下所示：

* Changes the execution context to one `Thread` picked by the `Scheduler`
* as per the specification, `onNext` calls happen in sequence, so this uses up a single thread
* unless they work on a specific `Scheduler`, operators after `publishOn` continue execution on that same thread

* 将执行上下文更改Thread为由Scheduler
* 根据规范，onNext调用是按顺序发生的，因此这会占用一个线程
* 除非他们在特定的Scheduler，执行publishOn后在同一线程上工作

The following example uses the `publishOn` method:

====
[source,java]
----
Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); //<1>

final Flux<String> flux = Flux
    .range(1, 2)
    .map(i -> 10 + i)  //<2>
    .publishOn(s)  //<3>
    .map(i -> "value " + i);  //<4>

new Thread(() -> flux.subscribe(System.out::println));  //<5>
----
<1> 创建一个Scheduler由四个Thread实例支持的新对象。
<2> 第一个map在<5>中的匿名线程上运行。
<3> publishOn 切换整个序列到在 Thread<1>中。
<4> 第二个map在Thread<1> 上运行.
<5> 这匿名Thread是进行订阅的地方。打印发生在最新的执行上下文中，是从publishOn创建出来的
====



=== The `subscribeOn` Method

`subscribeOn` applies to the subscription process, when that backward chain is
constructed. As a consequence, no matter where you place the `subscribeOn` in the chain,
*it always affects the context of the source emission*. However, this does not affect the
behavior of subsequent calls to `publishOn` -- they still switch the execution context for
the part of the chain after them.

subscribeOn当构造了反向链时，适用于订阅过程。因此，无论将其放置subscribeOn在链中的什么位置， 它始终会影响源发射的环境。
但是，这不会影响后续调用的行为，publishOn 它们仍会在其后的部分链中切换执行上下文。


* 从全链的订阅中更改Thread
* 从Scheduler中选择一个线程

NOTE: Only the earliest `subscribeOn` call in the chain is actually taken into account.

subscribeOn实际上仅考虑链中 最早的呼叫。

The following example uses the `subscribeOn` method:

====
[source,java]
----
Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); //<1>

final Flux<String> flux = Flux
    .range(1, 2)
    .map(i -> 10 + i)  //<2>
    .subscribeOn(s)  //<3>
    .map(i -> "value " + i);  //<4>

new Thread(() -> flux.subscribe(System.out::println));  //<5>
----
<1> 创建一个Scheduler由4个Thread。.
<2> 第一个map运行在这四个线程之一上
<3> 因为 subscribeOn从订阅时间（<5>）的位置，就开始切换了整个序列的线程
<4> 第二个map也运行在同一线程上.
<5> 匿名Thread是最初发生预订的那个，但subscribeOn立即将其转移到四个调度程序线程之一。
====

[[error.handling]]
== Handling Errors

TIP: For a quick look at the available operators for error handling, see
<<which.errors,the relevant operator decision tree>>.

In Reactive Streams, errors are terminal events. As soon as an error occurs, it stops the
sequence and gets propagated down the chain of operators to the last step, the
`Subscriber` you defined and its `onError` method.

在反应式流中，错误是终端事件。一旦发生错误，它就会停止序列，并沿操作链传播到最后一步Subscriber上，你定义的onError方法。

Such errors should still be dealt with at the application level. For instance, you might
display an error notification in a UI or send a meaningful error payload in a REST
endpoint. For this reason, the subscriber's `onError` method should always be defined.

此类错误仍应在应用程序级别处理。例如，您可能在UI中显示错误通知，或在REST端点中发送有意义的错误有效负载。
因此，onError应始终定义订户的方法。

WARNING: If not defined, `onError` throws an `UnsupportedOperationException`. You can
further detect and triage it with the `Exceptions.isErrorCallbackNotImplemented` method.


WARNING: 如果未定义，则onError抛出UnsupportedOperationException。您可以使用该Exceptions.isErrorCallbackNotImplemented方法进一步对其进行检测和分类。


Reactor also offers alternative means of dealing with errors in the middle of the chain,
as error-handling operators. The following example shows how to do so:

作为错误处理运算符，Reactor还提供了处理链中间错误的替代方法。以下示例显示了如何执行此操作：

====
[source,java]
----
Flux.just(1, 2, 0)
    .map(i -> "100 / " + i + " = " + (100 / i)) //this triggers an error with 0
    .onErrorReturn("Divided by zero :("); // error handling example
----
====

IMPORTANT: Before you learn about error-handling operators, you must keep in mind that
_any error in a reactive sequence is a terminal event_. Even if an error-handling
operator is used, it does not let the original sequence continue. Rather, it
converts the `onError` signal into the start of a new sequence (the fallback one). In
other words, it replaces the terminated sequence _upstream_ of it.

IMPORTANT: 在学习错误处理运算符之前，必须记住，反应序列中的 任何错误都是终端事件。
即使使用了错误处理运算符，它也不会让原始序列继续。相反，它将onError信号转换为新序列的开始（后备序列）。
换句话说，它将替换其上游的终止序列。

Now we can consider each means of error handling one-by-one. When relevant, we make a
parallel with imperative programming's `try` patterns.

现在，我们可以考虑各种错误处理方式。我们看做与命令式编程的try模式相平行。

=== Error Handling Operators

You may be familiar with several ways of dealing with exceptions in a try-catch block.
Most notably, these include the following:

您可能熟悉在try-catch块中处理异常的几种方法。最值得注意的是，这些内容包括：

* Catch and return a static default value.
* Catch and execute an alternative path with a fallback method.
* Catch and dynamically compute a fallback value.
* Catch, wrap to a `BusinessException`, and re-throw.
* Catch, log an error-specific message, and re-throw.
* Use the `finally` block to clean up resources or a Java 7 "`try-with-resource`" construct.


* 捕获并返回静态默认值。
* 使用后备方法捕获并执行替代路径
* 捕获并动态计算后备值
* 接住，包装成BusinessException，然后重新抛出。
* 捕获，记录特定于错误的消息，然后重新抛出。
* 使用该finally块清除资源或Java 7“ try-with-resource”构造。


All of these have equivalents in Reactor, in the form of error-handling operators.
Before looking into these operators, we first want to establish a parallel between a reactive
chain and a try-catch block.

所有这些都以错误处理运算符的形式在Reactor中具有等效项。在研究这些运算符之前，我们首先要在反应链和try-catch块之间建立并行。

When subscribing, the `onError` callback at the end of the chain is akin to a `catch`
block. There, execution skips to the catch in case an `Exception` is thrown, as the
following example shows:

订阅时，onError链末尾的回调类似于一个catch 块。Exception如下面的示例所示，在此情况下，执行会跳到捕获到的情况：

====
[source,java]
----
Flux<String> s = Flux.range(1, 10)
    .map(v -> doSomethingDangerous(v)) // <1>
    .map(v -> doSecondTransform(v)); // <2>
s.subscribe(value -> System.out.println("RECEIVED " + value), // <3>
            error -> System.err.println("CAUGHT " + error) // <4>
);
----
<1> 执行了可能引发异常的转换
<2> 如果一切顺利，则执行第二次转换
<3> 每个成功转换的值都会打印出来
<4> 发生错误时，序列终止，并显示错误消息
====

The preceding example is conceptually similar to the following try-catch block:

前面的示例在概念上类似于以下try-catch块：

====
[source,java]
----
try {
    for (int i = 1; i < 11; i++) {
        String v1 = doSomethingDangerous(i); // <1>
        String v2 = doSecondTransform(v1); // <2>
        System.out.println("RECEIVED " + v2);
    }
} catch (Throwable t) {
    System.err.println("CAUGHT " + t); // <3>
}
----
<1> If an exception is thrown here...
<2> ...the rest of the loop is skipped...
<3> ... and the execution goes straight to here.
====

Now that we have established a parallel, we can look at the different error handling cases
and their equivalent operators.

既然我们已经建立了并行，我们就可以研究不同的错误处理情况及其等效的运算符

==== Static Fallback Value

The equivalent of "`Catch and return a static default value`" is `onErrorReturn`.
The following example shows how to use it:

等效于“捕获并返回静态默认值” onErrorReturn。以下示例显示了如何使用它：

====
[source,java]
----
try {
  return doSomethingDangerous(10);
}
catch (Throwable error) {
  return "RECOVERED";
}
----
====

The following example shows the Reactor equivalent:

====
[source,java]
----
Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn("RECOVERED");
----
====

You also have the option of applying a `Predicate` on the exception to decided
whether or not to recover, as the folloiwng example shows:

你还可以选择Predicate对异常应用，以决定是否恢复，如以下示例所示：

====
[source,java]
----
Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn(e -> e.getMessage().equals("boom10"), "recovered10"); //<1>
----
<1> Recover only if the message of the exception is `"boom10"`
====

==== Fallback Method

If you want more than a single default value and you have an alternative (safer) way of
processing your data, you can use `onErrorResume`. This would be the equivalent of
"`Catch and execute an alternative path with a fallback method`".

如果您需要多个默认值，并且有另一种（更安全的）数据处理方式，则可以使用onErrorResume。这相当于“使用后备方法捕获并执行替代路径”。

For example, if your nominal process is fetching data from an external and unreliable
service but you also keep a local cache of the same data that _can_ be a bit more out of
date but is more reliable, you could do the following:

例如，如果您的标称进程正在从外部且不可靠的服务中获取数据，但是您还保留了相同数据的本地缓存，该缓存可能会过时但更可靠，则可以执行以下操作：

====
[source,java]
----
String v1;
try {
  v1 = callExternalService("key1");
}
catch (Throwable error) {
  v1 = getFromCache("key1");
}

String v2;
try {
  v2 = callExternalService("key2");
}
catch (Throwable error) {
  v2 = getFromCache("key2");
}
----
====

The following example shows the Reactor equivalent:

====
[source,java]
----
Flux.just("key1", "key2")
    .flatMap(k -> callExternalService(k) // <1>
        .onErrorResume(e -> getFromCache(k)) // <2>
    );
----
<1> 对于每个键，异步调用外部服务。.
<2> 如果外部服务调用失败，则退回到该密钥的缓存。请注意，无论源错误e是什么，我们总是应用相同的后备.
====

Like `onErrorReturn`, `onErrorResume` has variants that let you filter which exceptions
to fall back on, based either on the exception's class or on a `Predicate`. The fact that it
takes a `Function` also lets you choose a different fallback sequence to switch to,
depending on the error encountered. The following example shows how to do so:

像 onErrorReturn，onErrorResume 那样具有变体，可让您根据异常的类或来过滤要回退的异常或断言。
事实上内部是执行了一个Function，使您可以根据遇到的错误选择不同的后备序列来切换。以下示例显示了如何执行此操作：

====
[source,java]
----
Flux.just("timeout1", "unknown", "key2")
    .flatMap(k -> callExternalService(k)
        .onErrorResume(error -> { // <1>
            if (error instanceof TimeoutException) // <2>
                return getFromCache(k);
            else if (error instanceof UnknownKeyException)  // <3>
                return registerNewEntry(k, "DEFAULT");
            else
                return Flux.error(error); // <4>
        })
    );
----
<1> 该功能允许动态选择如何继续.
<2> 如果源超时，请访问本地缓存.
<3> 如果源显示密钥未知，请创建一个新条目.
<4> 在所有其他情况下，“重新抛出”.
====

==== Dynamic Fallback Value

Even if you do not have an alternative (safer) way of processing your data, you might want
to compute a fallback value out of the exception you received. This would be the
equivalent of "`Catch and dynamically compute a fallback value`".

即使没有其他（更安全）的数据处理方式，您也可能希望根据收到的异常来计算回退值。这相当于“捕获并动态计算后备值”。

For instance, if your return type (`MyWrapper`) has a variant dedicated to holding an exception (think
`Future.complete(T success)` versus `Future.completeExceptionally(Throwable error)`), you
could instantiate the error-holding variant and pass the exception.

例如，如果您的返回类型（MyWrapper）具有专用于保存异常的变量（认为 Future.complete(T success)与Future.completeExceptionally(Throwable error)），则可以实例化错误保存变量并传递异常。

An imperative example would look like the following:

====
[source,java]
----
try {
  Value v = erroringMethod();
  return MyWrapper.fromValue(v);
}
catch (Throwable error) {
  return MyWrapper.fromError(error);
}
----
====

You can do this reactively in the same way as the fallback method solution,
by using `onErrorResume`, with a tiny bit of boilerplate, as follows:

您可以通过使用onErrorResume，与一小部分样板程序一样，以与后备方法解决方案相同的方式进行反应，如下所示：

====
[source,java]
----
erroringFlux.onErrorResume(error -> Mono.just( // <1>
        MyWrapper.fromError(error) // <2>
));
----
<1> 由于您期望返回MyWrapper为错误的表示形式，因此需要获得 Mono<MyWrapper> 从 onErrorResume 中。我们用 Mono.just() 来完成.
<2> 我们需要计算异常值。在这里，我们通过使用相关的MyWrapper工厂方法包装异常来实现这一目标。
====

==== Catch and Rethrow

"Catch, wrap to a `BusinessException`, and re-throw" looks like the following in the
imperative world:

在命令式世界中，“捕获 BusinessException 包装并重新抛出” 看起来像以下内容：

====
[source,java]
----
try {
  return callExternalService(k);
}
catch (Throwable error) {
  throw new BusinessException("oops, SLA exceeded", error);
}
----
====

In the "`fallback method`" example, the last line inside the `flatMap` gives us a hint
at achieving the same reactively, as follows:

在“后备方法”示例中，内的最后一行为flatMap我们提供了一个提示，以提示您以被动方式实现相同目标，如下所示：

====
[source,java]
----
Flux.just("timeout1")
    .flatMap(k -> callExternalService(k))
    .onErrorResume(original -> Flux.error(
            new BusinessException("oops, SLA exceeded", original))
    );
----
====

However, there is a more straightforward way of achieving the same effect with `onErrorMap`:

但是，还有一种更简单的方法可以达到以下效果onErrorMap：

====
[source,java]
----
Flux.just("timeout1")
    .flatMap(k -> callExternalService(k))
    .onErrorMap(original -> new BusinessException("oops, SLA exceeded", original));
----
====

==== Log or React on the Side

For cases where you want the error to continue propagating but still want to react to
it without modifying the sequence (logging it, for instance), you can use the `doOnError`
operator. This is the equivalent of "`Catch, log an error-specific message, and re-throw`"
pattern, as the following example shows:

对于希望错误继续传播但仍希望对错误做出反应而又不修改顺序（例如记录错误）的情况，可以使用doOnError 运算符。这等效于“捕获，记录特定于错误的消息并重新抛出”模式，如以下示例所示：

====
[source,java]
----
try {
  return callExternalService(k);
}
catch (RuntimeException error) {
  //make a record of the error
  log("uh oh, falling back, service failed for key " + k);
  throw error;
}
----
====

The `doOnError` operator, as well as all operators prefixed with `doOn` , are sometimes
referred to as having a "`side-effect`". They let you peek inside the sequence's events without
modifying them.

doOnError操作者，以及与所有前缀为doOn的操作符，有时被称为具有“副作用”。它们使您可以查看序列的事件而无需修改它们。

Like the imperative example shown earlier, the following example still propagates the error yet
ensures that we at least log that the external service had a failure:

====
[source,java]
----
LongAdder failureStat = new LongAdder();
Flux<String> flux =
Flux.just("unknown")
    .flatMap(k -> callExternalService(k) // <1>
        .doOnError(e -> {
            failureStat.increment();
            log("uh oh, falling back, service failed for key " + k); // <2>
        })
        // <3>
    );
----
<1> 可能失败的外部服务调用.
<2> 具有日志和统计方面的副作用
<3> 之后，它仍然会以错误终止，除非我们在此处使用错误恢复操作符。
====

We can also imagine we have statistic counters to increment as a second error side-effect.

我们还可以想象，我们有统计计数器会增加，这是第二个错误副作用。

==== Using Resources and the Finally Block

The last parallel to draw with imperative programming is the cleaning up that can be done
either by using a "`Use of the `finally` block to clean up resources`" or by using a
"`Java 7 try-with-resource construct`", both shown below:

命令式编程的最后一个并行处理是清理，可以通过使用“使用finally块清理资源”或通过使用“ Java 7 try-with-resource构造”来完成，两者均显示如下：

.Imperative use of finally
====
[source,java]
----
Stats stats = new Stats();
stats.startTimer();
try {
  doSomethingDangerous();
}
finally {
  stats.stopTimerAndRecordTiming();
}
----
====

.Imperative use of try-with-resource
====
[source,java]
----
try (SomeAutoCloseable disposableInstance = new SomeAutoCloseable()) {
  return disposableInstance.toString();
}
----
====

Both have their Reactor equivalents: `doFinally` and `using`.

两者都有其Reactor等效方法：doFinally和using。

`doFinally` is about side-effects that you want to be executed whenever the
sequence terminates (with `onComplete` or `onError`) or is cancelled.
It gives you a hint as to what kind of termination triggered the side-effect.
The following example shows how to use `doFinally`:

doFinally与序列终止（用onComplete或onError或取消）时要执行的副作用有关。它提示您哪种终止方式会引起副作用。以下示例显示如何使用doFinally：

====
[source,java]
.Reactive finally: `doFinally()`
----
Stats stats = new Stats();
LongAdder statsCancel = new LongAdder();

Flux<String> flux =
Flux.just("foo", "bar")
    .doOnSubscribe(s -> stats.startTimer())
    .doFinally(type -> { // <1>
        stats.stopTimerAndRecordTiming();// <2>
        if (type == SignalType.CANCEL) // <3>
          statsCancel.increment();
    })
    .take(1); // <4>
----
<1> `doFinally` consumes a `SignalType` for the type of termination. 	doFinally使用终止类型的SignalType。
<2> Similarly to `finally` blocks, we always record the timing.  与“ finally”块类似，我们总是记录时间。
<3> Here we also increment statistics in case of cancellation only.  在这里，我们还仅在取消的情况下增加统计信息。
<4> `take(1)` cancels after one item is emitted. `take（1）` 表示 发出一项后即取消，
====

On the other hand, `using` handles the case where a `Flux` is derived from a
resource and that resource must be acted upon whenever processing is done.
In the following example, we replace the `AutoCloseable` interface of "`try-with-resource`" with a
`Disposable`:

另一方面，“using”处理了“Flux”来自于资源，并且每当处理完成时都必须对资源进行操作。
在以下示例中，我们将“ try-with-resource”的“ AutoCloseable”界面替换为
`一次性`：

.The Disposable resource
====
[source,java]
----
AtomicBoolean isDisposed = new AtomicBoolean();
Disposable disposableInstance = new Disposable() {
    @Override
    public void dispose() {
        isDisposed.set(true); // <4>
    }

    @Override
    public String toString() {
        return "DISPOSABLE";
    }
};
----
====

Now we can do the reactive equivalent of "`try-with-resource`" on it, which looks
like the following:

现在，我们可以在其上执行与“ try-with-resource”等效的效果，如下所示：

.Reactive try-with-resource: `using()`
====
[source,java]
----
Flux<String> flux =
Flux.using(
        () -> disposableInstance, // <1>
        disposable -> Flux.just(disposable.toString()), // <2>
        Disposable::dispose // <3>
);
----
<1> The first lambda generates the resource. Here, we return our mock `Disposable`. 	第一个lambda生成资源。在这里，我们返回我们的模拟Disposable
<2> The second lambda processes the resource, returning a `Flux<T>`. 第二个lambda处理资源，返回Flux<T>。
<3> The third lambda is called when the `Flux` from <2> terminates or is cancelled, to
clean up resources. 当Fluxfrom <2>终止或取消时，将调用第三个lambda 以清理资源。
<4> After subscription and execution of the sequence, the `isDisposed` atomic boolean
becomes `true`. 订阅并执行序列后，isDisposed原子布尔值变为true。
====

==== Demonstrating the Terminal Aspect of `onError`

In order to demonstrate that all these operators cause the upstream original sequence to
terminate when an error happens, we can use a more visual example with a
`Flux.interval`. The `interval` operator ticks every x units of time with an increasing
`Long` value. The following example uses an `interval` operator:

为了证明所有这些运算符都会在发生错误时使上游原始序列终止，我们可以使用带有的更直观的示例 Flux.interval。
该interval运算符每隔x单位时间滴答一次，递增Long值。以下示例使用interval运算符：

====
[source,java]
----
Flux<String> flux =
Flux.interval(Duration.ofMillis(250))
    .map(input -> {
        if (input < 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .onErrorReturn("Uh oh");

flux.subscribe(System.out::println);
Thread.sleep(2100); // <1>
----
<1> Note that `interval` executes on a *timer* `Scheduler` by default. If we want
to run that example in a main class, we would need to add a `sleep` call here so that the
application does not exit immediately without any value being produced.

请注意，默认情况下interval会在计时器上执行Scheduler。如果要在主类中运行该示例，则需要在sleep此处添加一个调用，以便应用程序不会立即退出而不会产生任何值。

====

The preceding example prints out one line every 250ms, as follows:

前面的示例每250ms打印出一行，如下所示：

====
[source]
----
tick 0
tick 1
tick 2
Uh oh
----
====

Even with one extra second of runtime, no more tick comes in from the `interval`. The
sequence was indeed terminated by the error.

即使再多一秒的运行时间，也不会再出现滴答声interval。错误确实终止了该序列。

==== Retrying

There is another operator of interest with regards to error handling, and you might be
tempted to use it in the case described in the previous section. `retry`, as its name
indicates, lets you retry an error-producing sequence.

关于错误处理，还有另一个有趣的运算符，在上一节中所述的情况下，您可能会想使用它。retry顾名思义，可让您重试产生错误的序列。

The thing to keep in mind is that it works by *re-subscribing* to the upstream `Flux`.
This is really a different sequence, and the original one is still terminated.
To verify that, we can re-use the previous example and append a `retry(1)` to
retry once instead of using `onErrorReturn`. The following example shows how to do sl:

要记住的是，它通过重新订阅上游的Flux而起作用。这实际上是一个不同的序列，原始序列仍然终止。为了验证这一点，我们可以重用前面的示例，并在其中附加一个`retry（1）`。
重试一次，而不要使用`onErrorReturn`。 以下示例显示了如何执行sl：

====
[source,java]
----
Flux.interval(Duration.ofMillis(250))
    .map(input -> {
        if (input < 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .retry(1)
    .elapsed() // <1>
    .subscribe(System.out::println, System.err::println); // <2>

Thread.sleep(2100); // <3>
----
<1> `elapsed` associates each value with the duration since previous value was emitted.
<2> We also want to see when there is an `onError`.
<3> Ensure we have enough time for our 4x2 ticks.
====

The preceding example produces the following output:

====
[source]
----
259,tick 0
249,tick 1
251,tick 2
506,tick 0 <1>
248,tick 1
253,tick 2
java.lang.RuntimeException: boom
----
<1> A new `interval` started, from tick 0. The additional 250ms duration is
coming from the 4th tick, the one that causes the exception and subsequent
retry. 	从滴答0开始一个新的interval。额外的250毫秒持续时间来自第4个滴答，它引起异常并随后重试。
====

As you can see from the preceding example, `retry(1)` merely re-subscribed to the original `interval`
once, restarting the tick from 0. The second time around, since the exception
still occurs, it gives up and propagates the error downstream.

从前面的示例中可以看到，retry(1)只重新订阅了interval 一次，从0重新开始了滴答。第二次，由于仍然发生异常，它放弃并向下游传播错误。

There is a more advanced version of `retry` (called `retryWhen`) that uses a "`companion`"
`Flux` to tell whether or not a particular failure should retry. This companion `Flux` is
created by the operator but decorated by the user, in order to customize the retry
condition.

有一个更高级的版本retry（称为retryWhen），它使用“companion” Flux来告知是否应重试特定的故障。
该同伴Flux由操作员创建但由用户修饰，以自定义重试条件。

The companion `Flux` is a `Flux<Throwable>` that gets passed to a `Function`, the sole
parameter of `retryWhen`. As the user, you define that function and make it return a new
`Publisher<?>`. Retry cycles go as follows:

Companiond的Flux是Flux<Throwable>，它传递给retryWhen的唯一参数Function。
作为使用者，您可以定义该函数并使它返回new Publisher<?>。重试周期如下：

. Each time an error happens (giving potential for a retry), the error is emitted into the
companion `Flux`, which has been decorated by your function. Having a `Flux` here
gives a bird eye's view of all the attempts so far.
. If the companion `Flux` emits a value, a retry happens.
. If the companion `Flux` completes, the error is swallowed, the retry cycle stops,
and the resulting sequence completes, too.
. If the companion `Flux` produces an error (`e`), the retry cycle stops and the
resulting sequence errors with `e`.

. 每次发生错误（重试的可能性）时，错误就会被发送到伴随Flux函数中，该伴随函数已由您的函数修饰。在Flux这里有一个鸟瞰图，可以看到到目前为止的所有尝试。
. 果同伴Flux发出一个值，则重试。
. 如果伴随程序Flux完成，则错误将被吞没，重试周期将停止，并且所生成的序列也将完成。
. 如果随companion Flux产生错误（e），则重试周期停止，并且产生的序列错误为e。

The distinction between the previous two cases is important. Simply completing the
companion would effectively swallow an error. Consider the following way of emulating
`retry(3)` by using `retryWhen`:

前两种情况之间的区别很重要。只需完成companion 即可有效地吞下一个错误。考虑使用retryWhen 以模拟 retry(3)方法：

====
[source,java]
----
Flux<String> flux = Flux
    .<String>error(new IllegalArgumentException()) // <1>
    .doOnError(System.out::println) // <2>
    .retryWhen(companion -> companion.take(3)); // <3>
----
<1> This continuously produces errors, calling for retry attempts.这会不断产生错误，要求重试。
<2> `doOnError` before the retry lets us log and see all failures. 	doOnError 重试之前，让我们记录并查看所有失败
<3> Here, we consider the first three errors as retry-able (`take(3)`) and then give up. 在这里，我们将前三个错误视为可重试（take(3)），然后放弃。
====

In effect, the preceding example results in an empty `Flux`, but it completes successfully. Since
`retry(3)` on the same `Flux` would have terminated with the latest error, this
`retryWhen` example is not exactly the same as a `retry(3)`.

实际上，前面的示例导致为空Flux，但它成功完成。
由于 retry(3)同一Flux错误会因最新错误而终止，因此此retryWhen示例与并不完全与retry(3)相同。

Getting to the same behavior involves a few additional tricks:
include::snippetRetryWhenRetry.adoc[]

达到相同的行为还涉及其他一些技巧：

TIP: You can use similar code to implement an "`exponential backoff and retry`" pattern,
as shown in the <<faq.exponentialBackoff,FAQ>>.

您可以使用类似的代码来实现“指数退避和重试”模式，如FAQ中所示。

=== Handling Exceptions in Operators or Functions

In general, all operators can themselves contain code that potentially trigger an
exception or calls to a user-defined callback that can similarly fail, so they all
contain some form of error handling.

通常，所有运算符都可以自己包含可能触发异常的代码或对用户定义的回调的调用（同样可能失败），因此它们都包含某种形式的错误处理。

As a rule of thumb, an unchecked exception is always propagated through `onError`. For
instance, throwing a `RuntimeException` inside a `map` function translates to an
`onError` event, as the following code shows:

根据经验，始终会通过传播未经检查的异常onError。
例如，将函数RuntimeException内部的内容map转换为 onError事件，如以下代码所示：

====
[source,java]
----
Flux.just("foo")
    .map(s -> { throw new IllegalArgumentException(s); })
    .subscribe(v -> System.out.println("GOT VALUE"),
               e -> System.out.println("ERROR: " + e));
----
====

The preceding code prints out the following:

====
[source]
----
ERROR: java.lang.IllegalArgumentException: foo
----
====

TIP: You can tune the `Exception` before it is passed to `onError`, through the use of a
<<hooks-internal,hook>>.

您可以使用 <<hooks-internal,hook>> 来调整Exception传递给它之前的状态。 onError

Reactor, however, defines a set of exceptions (such as `OutOfMemoryError`) that are
always deemed to be fatal. See the `Exceptions.throwIfFatal` method. These errors mean that
Reactor cannot keep operating and are thrown rather than propagated.

但是，Reactor定义了一组OutOfMemoryError总是被认为是致命的异常（例如）。
参见Exceptions.throwIfFatal方法。这些错误意味着Reactor无法继续运行，并且会被抛出而不是传播。

NOTE: Internally, there are also cases where an unchecked exception still cannot be
propagated (most notably during the subscribe and request phases), due to concurrency
races that could lead to double `onError` or `onComplete` conditions. When these races
happen, the error that cannot be propagated is "`dropped`". These cases can still be
managed to some extent by using customizable hooks. See <<hooks-dropping>>.

NOTE: 在内部，由于并发竞争可能导致重复onError或onComplete情况，因此在某些情况下仍无法传播未经检查的异常（最值得注意的是在订阅和请求阶段）。
当发生这些竞争时，无法传播的错误将被“丢弃”。通过使用可定制的挂钩，仍可以在某种程度上管理这些情况。请参阅 <<hooks-dropping>>。


You may ask: "`What about checked exceptions?`"

您可能会问：“如何检查异常？”

If, for example, you need to call some method that declares it `throws` exceptions, you
still have to deal with those exceptions in a `try-catch` block. You have several
options, though:

例如，如果您需要调用某个声明其throws异常的方法，则仍必须在一个try-catch块中处理这些异常。不过，您有几种选择：

. Catch the exception and recover from it. The sequence continues normally.
. Catch the exception, wrap it into an _unchecked_ exception, and then throw it
(interrupting the sequence). The `Exceptions` utility class can help you with that (we
get to that next).
. If you need to return a `Flux` (for example, you are in a `flatMap`), wrap the
exception in an error-producing `Flux`, as follows: `return Flux.error(checkedException)`. (The
sequence also terminates.)


. 获异常并从中恢复。该序列正常继续。
. 捕获异常，将其包装为未经检查的异常，然后将其抛出（中断序列）。该Exceptions实用工具类可以帮你
. 如果需要返回Flux（例如，你在中flatMap），则将异常包装在一个错误生产器的`Flux`中，如下所示：return Flux.error(checkedException)。（该序列也终止。）



Reactor has an `Exceptions` utility class that you can use to ensure that exceptions are
wrapped only if they are checked exceptions:

Reactor有一个Exceptions实用程序类，您可以使用它来确保仅是检查异常的情况下包装这些异常：

* Use the `Exceptions.propagate` method to wrap exceptions, if necessary. It also calls
`throwIfFatal` first and does not wrap `RuntimeException`.
* Use the `Exceptions.unwrap` method to get the original unwrapped exception (going back
to the root cause of a hierarchy of reactor-specific exceptions).

* Exceptions.propagate如有必要，使用该方法包装异常。它还throwIfFatal先调用 ，并且不包装RuntimeException。
* 使用该Exceptions.unwrap方法来获取原始的未包装的异常（返回到具体于reactor的异常的层次结构的根本原因）。

Consider the following example of a `map` that uses a conversion method that can throw an
`IOException`:

考虑以下示例，该示例map使用可以引发的转换方法 IOException：

====
[source,java]
----
public String convert(int i) throws IOException {
    if (i > 3) {
        throw new IOException("boom " + i);
    }
    return "OK " + i;
}
----
====

Now imagine that you want to use that method in a `map`. You must now explicitly catch
the exception, and your map function cannot re-throw it. So you can propagate it to the
map's `onError` method as a `RuntimeException`, as follows:

现在，假设您要在中使用该方法map。现在，您必须显式捕获异常，并且您的map函数无法将其重新引发。
因此，您可以将其像 RuntimeException 传播到Map的onError方法，如下所示：

====
[source,java]
----
Flux<String> converted = Flux
    .range(1, 10)
    .map(i -> {
        try { return convert(i); }
        catch (IOException e) { throw Exceptions.propagate(e); }
    });
----
====

Later on, when subscribing to the preceding `Flux` and reacting to errors (such as in the
UI), you could revert back to the original exception if you want to do something
special for IOExceptions. The following example shows how to do so:

稍后，在订阅上述内容Flux并对错误做出反应时（例如在UI中），如果您想对IOExceptions做一些特殊的事情，则可以恢复到原始异常。
以下示例显示了如何执行此操作：

====
[source,java]
----
converted.subscribe(
    v -> System.out.println("RECEIVED: " + v),
    e -> {
        if (Exceptions.unwrap(e) instanceof IOException) {
            System.out.println("Something bad happened with I/O");
        } else {
            System.out.println("Something bad happened");
        }
    }
);
----
====

[[processors]]
== Processors
include::processors.adoc[leveloffset=3]
