<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Stephane Maldini, Simon Baslé">
<title>Reactor 3 Reference Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Reactor 3 Reference Guide</h1>
<div class="details">
<span id="author" class="author">Stephane Maldini</span><br>
<span id="email" class="email"><a href="https://twitter.com/smaldini">@smaldini</a></span><br>
<span id="author2" class="author">Simon Baslé</span><br>
<span id="email2" class="email"><a href="https://twitter.com/simonbasle">@simonbasle</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#about-doc">1. About the Documentation</a>
<ul class="sectlevel2">
<li><a href="#_latest_version_copyright_notice">1.1. Latest Version &amp; Copyright Notice</a></li>
<li><a href="#_contributing_to_the_documentation">1.2. Contributing to the Documentation</a></li>
<li><a href="#_getting_help">1.3. Getting Help</a></li>
<li><a href="#_where_to_go_from_here">1.4. Where to Go from Here</a></li>
</ul>
</li>
<li><a href="#getting-started">2. Getting Started</a>
<ul class="sectlevel2">
<li><a href="#getting-started-introducing-reactor">2.1. Introducing Reactor</a></li>
<li><a href="#prerequisites">2.2. Prerequisites</a></li>
<li><a href="#getting-started-understanding-bom">2.3. Understanding the BOM</a></li>
<li><a href="#getting">2.4. Getting Reactor</a></li>
</ul>
</li>
<li><a href="#intro-reactive">3. Introduction to Reactive Programming</a>
<ul class="sectlevel2">
<li><a href="#_blocking_can_be_wasteful">3.1. Blocking Can Be Wasteful</a></li>
<li><a href="#_asynchronicity_to_the_rescue">3.2. Asynchronicity to the Rescue?</a></li>
<li><a href="#_from_imperative_to_reactive_programming">3.3. From Imperative to Reactive Programming</a></li>
</ul>
</li>
<li><a href="#core-features">4. Reactor Core Features</a>
<ul class="sectlevel2">
<li><a href="#flux">4.1. <code>Flux</code>, an Asynchronous Sequence of 0-N Items</a></li>
<li><a href="#mono">4.2. <code>Mono</code>, an Asynchronous 0-1 Result</a></li>
<li><a href="#_simple_ways_to_create_a_flux_or_mono_and_subscribe_to_it">4.3. Simple Ways to Create a Flux or Mono and Subscribe to It</a></li>
<li><a href="#producing">4.4. Programmatically creating a sequence</a></li>
<li><a href="#schedulers">4.5. Threading and Schedulers</a></li>
<li><a href="#error.handling">4.6. Handling Errors</a></li>
<li><a href="#processors">4.7. Processors</a></li>
</ul>
</li>
<li><a href="#kotlin">5. Kotlin support</a>
<ul class="sectlevel2">
<li><a href="#kotlin-requirements">5.1. Requirements</a></li>
<li><a href="#kotlin-extensions">5.2. Extensions</a></li>
<li><a href="#kotlin-null-safety">5.3. Null Safety</a></li>
</ul>
</li>
<li><a href="#testing">6. Testing</a>
<ul class="sectlevel2">
<li><a href="#_testing_a_scenario_with_stepverifier">6.1. Testing a Scenario with <code>StepVerifier</code></a></li>
<li><a href="#_manipulating_time">6.2. Manipulating Time</a></li>
<li><a href="#_performing_post_execution_assertions_with_stepverifier">6.3. Performing Post-execution Assertions with <code>StepVerifier</code></a></li>
<li><a href="#_testing_the_context">6.4. Testing the <code>Context</code></a></li>
<li><a href="#_manually_emitting_with_testpublisher">6.5. Manually Emitting with <code>TestPublisher</code></a></li>
<li><a href="#_checking_the_execution_path_with_publisherprobe">6.6. Checking the Execution Path with <code>PublisherProbe</code></a></li>
</ul>
</li>
<li><a href="#debugging">7. Debugging Reactor</a>
<ul class="sectlevel2">
<li><a href="#_the_typical_reactor_stack_trace">7.1. The Typical Reactor Stack Trace</a></li>
<li><a href="#debug-activate">7.2. Activating Debug Mode - aka tracebacks</a></li>
<li><a href="#_reading_a_stack_trace_in_debug_mode">7.3. Reading a Stack Trace in Debug Mode</a></li>
<li><a href="#reactor-tools-debug">7.4. Production-ready Global Debugging</a></li>
<li><a href="#_logging_a_sequence">7.5. Logging a Sequence</a></li>
</ul>
</li>
<li><a href="#metrics">8. Exposing Reactor metrics</a>
<ul class="sectlevel2">
<li><a href="#_scheduler_metrics">8.1. Scheduler metrics</a></li>
<li><a href="#_publisher_metrics">8.2. Publisher metrics</a></li>
</ul>
</li>
<li><a href="#advanced">9. Advanced Features and Concepts</a>
<ul class="sectlevel2">
<li><a href="#advanced-mutualizing-operator-usage">9.1. Mutualizing Operator Usage</a></li>
<li><a href="#reactor.hotCold">9.2. Hot Versus Cold</a></li>
<li><a href="#advanced-broadcast-multiple-subscribers-connectableflux">9.3. Broadcasting to Multiple Subscribers with <code>ConnectableFlux</code></a></li>
<li><a href="#advanced-three-sorts-batching">9.4. Three Sorts of Batching</a></li>
<li><a href="#advanced-parallelizing-parralelflux">9.5. Parallelizing Work with <code>ParallelFlux</code></a></li>
<li><a href="#scheduler-factory">9.6. Replacing Default <code>Schedulers</code></a></li>
<li><a href="#hooks">9.7. Using Global Hooks</a></li>
<li><a href="#context">9.8. Adding a Context to a Reactive Sequence</a></li>
<li><a href="#cleanup">9.9. Dealing with Objects that Need Cleanup</a></li>
<li><a href="#null-safety">9.10. Null Safety</a></li>
</ul>
</li>
<li><a href="#which-operator">Appendix A: Which operator do I need?</a>
<ul class="sectlevel2">
<li><a href="#which.create">A.1. Creating a New Sequence&#8230;&#8203;</a></li>
<li><a href="#which.values">A.2. Transforming an Existing Sequence</a></li>
<li><a href="#which.peeking">A.3. Peeking into a Sequence</a></li>
<li><a href="#which.filtering">A.4. Filtering a Sequence</a></li>
<li><a href="#which.errors">A.5. Handling Errors</a></li>
<li><a href="#which.time">A.6. Working with Time</a></li>
<li><a href="#which.window">A.7. Splitting a <code>Flux</code></a></li>
<li><a href="#which.blocking">A.8. Going Back to the Synchronous World</a></li>
<li><a href="#which.multicasting">A.9. Multicasting a <code>Flux</code> to several <code>Subscribers</code></a></li>
</ul>
</li>
<li><a href="#faq">Appendix B: FAQ, Best Practices, and "How do I&#8230;&#8203;?"</a>
<ul class="sectlevel2">
<li><a href="#faq.wrap-blocking">B.1. How Do I Wrap a Synchronous, Blocking Call? 如何包装同步阻塞呼叫?</a></li>
<li><a href="#faq.chain">B.2. I Used an Operator on my <code>Flux</code> but it Doesn&#8217;t Seem to Apply. What Gives?</a></li>
<li><a href="#faq.retryWhen">B.3. How to Use <code>retryWhen</code> to Emulate <code>retry(3)</code>?</a></li>
<li><a href="#faq.exponentialBackoff">B.4. How can I use <code>retryWhen</code> for Exponential Backoff?</a></li>
<li><a href="#faq.thread-affinity-publishon">B.5. How Do I Ensure Thread Affinity when I Use <code>publishOn()</code>?</a></li>
<li><a href="#faq.mdc">B.6. What Is a Good Pattern for Contextual Logging? (MDC)</a></li>
</ul>
</li>
<li><a href="#reactor-extra">Appendix C: Reactor-Extra</a>
<ul class="sectlevel2">
<li><a href="#extra-tuples">C.1. <code>TupleUtils</code> and Functional Interfaces</a></li>
<li><a href="#extra-math">C.2. Math Operators With <code>MathFlux</code></a></li>
<li><a href="#extra-repeat-retry">C.3. Repeat and Retry Utilities</a></li>
<li><a href="#extra-schedulers">C.4. Schedulers</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="about-doc"><a class="anchor" href="#about-doc"></a>1. About the Documentation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section provides a brief overview of Reactor reference documentation. You do not
need to read this guide in a linear fashion. Each piece stands on its own, though they
often refer to other pieces.</p>
</div>
<div class="sect2">
<h3 id="_latest_version_copyright_notice"><a class="anchor" href="#_latest_version_copyright_notice"></a>1.1. Latest Version &amp; Copyright Notice</h3>
<div class="paragraph">
<p>The Reactor reference guide is available as HTML documents. The latest copy is available
at <a href="https://projectreactor.io/docs/core/release/reference/index.html" class="bare">https://projectreactor.io/docs/core/release/reference/index.html</a></p>
</div>
<div class="paragraph">
<p>Copies of this document may be made for your own use and for distribution to others,
provided that you do not charge any fee for such copies and further provided that each
copy contains this Copyright Notice, whether distributed in print or electronically.</p>
</div>
</div>
<div class="sect2">
<h3 id="_contributing_to_the_documentation"><a class="anchor" href="#_contributing_to_the_documentation"></a>1.2. Contributing to the Documentation</h3>
<div class="paragraph">
<p>The reference guide is written in
<a href="https://asciidoctor.org/docs/asciidoc-writers-guide/">Asciidoc</a>, and you can find its sources at
<a href="https://github.com/reactor/reactor-core/tree/master/docs/asciidoc" class="bare">https://github.com/reactor/reactor-core/tree/master/docs/asciidoc</a>.</p>
</div>
<div class="paragraph">
<p>If you have an improvement or a suggestion, we will be happy to get a pull request from you!</p>
</div>
<div class="paragraph">
<p>We recommend that you check out a local copy of the repository so that you can
generate the documentation by running the <code>asciidoctor</code> gradle task and checking the
rendering. Some of the sections rely on included files, so GitHub rendering is
not always complete.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To facilitate documentation edits, most sections have a link at the end that opens
an edit UI directly on GitHub for the main source file for that section. These links are
only present in the HTML5 version of this reference guide. They look like the following:
<a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/aboutDoc.adoc" class="fa fa-edit" target="_blank" rel="noopener">Suggest Edit</a> to <a href="#about-doc">About the Documentation</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_getting_help"><a class="anchor" href="#_getting_help"></a>1.3. Getting Help</h3>
<div class="paragraph">
<p>You can reach out for help in several ways with Reactor:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Get in touch with the community on <a href="https://gitter.im/reactor/reactor">Gitter</a>.</p>
</li>
<li>
<p>Ask a question on stackoverflow.com at
<a href="https://stackoverflow.com/tags/project-reactor"><code>project-reactor</code></a>.</p>
</li>
<li>
<p>Report bugs in Github issues. We closely monitor the following repositories:
<a href="https://github.com/reactor/reactor-core/issues">reactor-core</a> (which covers the
essential features) and <a href="https://github.com/reactor/reactor-addons/issues">reactor-addons</a>
(which covers reactor-test and adapters issues).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All of Reactor is open source,
<a href="https://github.com/reactor/reactor-core/tree/master/docs/asciidoc">including this
documentation</a>. If you find problems with the docs or if you want to improve them,
please <a href="https://github.com/reactor/.github/blob/master/CONTRIBUTING.md">get involved</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_where_to_go_from_here"><a class="anchor" href="#_where_to_go_from_here"></a>1.4. Where to Go from Here</h3>
<div class="ulist">
<ul>
<li>
<p>如果你喜欢直接开始代码，请跳转到  <a href="#getting-started">Getting Started</a></p>
</li>
<li>
<p>如果你第一次接触 reactive 编程, 你应该从
<a href="#intro-reactive">Introduction to Reactive Programming</a> 开始.</p>
</li>
<li>
<p>如果你比较熟悉 Reactor 相关感念，只是想为工作中找些正确到方法，但是对用哪些运算符有不是很了解，你可以访问 <a href="#which-operator">Which operator do I need?</a> 附录.</p>
</li>
<li>
<p>为了更深入对了解 Reactor 核心功能, 点击 <a href="#core-features">Reactor Core Features</a> 学习相关内容:</p>
<div class="ulist">
<ul>
<li>
<p>更多对学习了解 Reactor&#8217;s 反应类型，在 <a href="#flux"><code>Flux</code>, an Asynchronous Sequence of 0-N Items</a> 和 <a href="#mono"><code>Mono</code>, an Asynchronous 0-1 Result</a>
章节中.</p>
</li>
<li>
<p>如何选中线程上下文去使用 <a href="#schedulers">a scheduler</a>.</p>
</li>
<li>
<p>如何捕获处理错误 <a href="#error.handling">Handling Errors</a> 章节.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Unit 单元测试? 是以通过 <code>reactor-test</code> 项目做到! 查看 <a href="#testing">Testing</a>.</p>
</li>
<li>
<p><a href="#producing">Programmatically creating a sequence</a> 学习跟多高级的方法去创建 reactive 源码.</p>
</li>
<li>
<p>其他高级主题都在 <a href="#advanced">Advanced Features and Concepts</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/aboutDoc.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#about-doc">About the Documentation</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>2. Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章节都内容信息将帮助大家更好的学习理解Reactor，主要包括以下小节内容</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#getting-started-introducing-reactor">Introducing Reactor</a></p>
</li>
<li>
<p><a href="#prerequisites">Prerequisites</a></p>
</li>
<li>
<p><a href="#getting-started-understanding-bom">Understanding the BOM</a></p>
</li>
<li>
<p><a href="#getting">Getting Reactor</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="getting-started-introducing-reactor"><a class="anchor" href="#getting-started-introducing-reactor"></a>2.1. Introducing Reactor</h3>
<div class="paragraph">
<p>Reactor 是一个给予JVM实现的完全非堵塞的 reactive 编程基础, 具有高效的 demand 管理 (以 "`backpressure`"的形式管理). 它们直接与Java 8 的
functional APIs 就行了整合, 特别整合了 <code>CompletableFuture</code>, <code>Stream</code>, and
<code>Duration</code>. 提供了一系列的可组合的异步 APIs&#8201;&#8212;&#8201;<code>Flux</code> (为了 [N] 元素) and
<code>Mono</code> (为了 [0|1] 元素)&#8201;&#8212;&#8201;并大量的实现了
<a href="https://www.reactive-streams.org/">Reactive Streams</a> 规范要求.</p>
</div>
<div class="paragraph">
<p>Reactor 还支持与给予`reactor-netty` 的项目进行非堵塞的进程间的通信
. 适用于微服务架构, Reactor Netty 为  HTTP (包括 Websockets), TCP, and UDP
提供了支持 backpressure 的网络引擎. Reactive 的编码与解码方式是完全支持.</p>
</div>
</div>
<div class="sect2">
<h3 id="prerequisites"><a class="anchor" href="#prerequisites"></a>2.2. Prerequisites</h3>
<div class="paragraph">
<p>Reactor Core runs on <code>Java 8</code> and above.</p>
</div>
<div class="paragraph">
<p>It has a transitive dependency on <code>org.reactivestreams:reactive-streams:1.0.3</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Android Support</div>
<div class="ulist">
<ul>
<li>
<p>Reactor 3 does not officially support or target Android (consider using RxJava 2 if
such support is a strong requirement).</p>
</li>
<li>
<p>However, it should work fine with Android SDK 26 (Android O) and above.</p>
</li>
<li>
<p>We are open to evaluating changes that benefit Android support in a best-effort
fashion. However, we cannot make guarantees. Each decision must be made on a
case-by-case basis.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="getting-started-understanding-bom"><a class="anchor" href="#getting-started-understanding-bom"></a>2.3. Understanding the BOM</h3>
<div class="paragraph">
<p>Reactor 3 uses a BOM (Bill of Materials) model (since <code>reactor-core 3.0.4</code>, with the <code>Aluminium</code> release train).
This curated list groups artifacts that are meant to work well together, providing
the relevant versions despite potentially divergent versioning schemes in these artifacts.</p>
</div>
<div class="paragraph">
<p>The BOM is itself versioned, using a release train scheme
with a codename followed by a qualifier. The following list shows a few examples:</p>
</div>
<div class="verseblock">
<pre class="content">Aluminium-RELEASE
Californium-BUILD-SNAPSHOT
Aluminium-SR1
Bismuth-RELEASE
Californium-SR32</pre>
</div>
<div class="paragraph">
<p>The codenames represent what would traditionally be the MAJOR.MINOR number. They (mostly)
come from the <a href="https://en.wikipedia.org/wiki/Periodic_table#Overview">Periodic Table of
Elements</a>, in increasing alphabetical order.</p>
</div>
<div class="paragraph">
<p>The qualifiers are (in chronological order):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BUILD-SNAPSHOT</code>: Builds for development and testing.</p>
</li>
<li>
<p><code>M1</code>..<code>N</code>: Milestones or developer previews.</p>
</li>
<li>
<p><code>RELEASE</code>: The first GA (General Availability) release in a codename series.</p>
</li>
<li>
<p><code>SR1</code>..<code>N</code>: The subsequent GA releases in a codename series&#8201;&#8212;&#8201;equivalent to a PATCH
number. (SR stands for &#8220;Service Release&#8221;).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="getting"><a class="anchor" href="#getting"></a>2.4. Getting Reactor</h3>
<div class="paragraph">
<p>As <a href="#getting-started-understanding-bom">mentioned earlier</a>, the easiest way to use Reactor in your core is to use the BOM and
add the relevant dependencies to your project. Note that, when you add such a dependency,
you must omit the version so that the version gets picked up from the BOM.</p>
</div>
<div class="paragraph">
<p>However, if you want to force the use of a specific artifact&#8217;s version, you can specify
it when adding your dependency, as you usually would. You can also forgo the BOM entirely
and specify dependencies by their artifact versions.</p>
</div>
<div class="sect3">
<h4 id="_maven_installation"><a class="anchor" href="#_maven_installation"></a>2.4.1. Maven Installation</h4>
<div class="paragraph">
<p>Maven natively supports the BOM concept. First, you need to import the BOM by
adding the following snippet to your <code>pom.xml</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
            &lt;artifactId&gt;reactor-bom&lt;/artifactId&gt;
            &lt;version&gt;Bismuth-RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Notice the <code>dependencyManagement</code> tag. This is in addition to the regular
<code>dependencies</code> section.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>If the top section (<code>dependencyManagement</code>) already exists in your pom, add only the contents.</p>
</div>
<div class="paragraph">
<p>Next, add your dependencies to the relevant reactor projects, as usual, except without a
<code>&lt;version&gt;</code>, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; <i class="conum" data-value="3"></i><b>(3)</b>
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dependency on the core library.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>No version tag here.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>reactor-test</code> provides facilities to unit test reactive streams.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gradle_installation"><a class="anchor" href="#_gradle_installation"></a>2.4.2. Gradle Installation</h4>
<div class="paragraph">
<p>Prior to version 5.0, Gradle has no core support for Maven BOMs, but you can use Spring&#8217;s
<a href="https://github.com/spring-gradle-plugins/dependency-management-plugin">gradle-dependency-management</a>
plugin.</p>
</div>
<div class="paragraph">
<p>First, apply the plugin from the Gradle Plugin Portal, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id "io.spring.dependency-management" version "1.0.7.RELEASE" <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>as of this writing, 1.0.7.RELEASE is the latest version of the plugin.
Check for updates.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Then use it to import the BOM, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencyManagement {
     imports {
          mavenBom "io.projectreactor:reactor-bom:Bismuth-RELEASE"
     }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally add a dependency to your project, without a version number, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
     implementation 'io.projectreactor:reactor-core' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>There is no third <code>:</code> separated section for the version. It is taken from
the BOM.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Since Gradle 5.0, you can use the native Gradle support for BOMs:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
     implementation platform('io.projectreactor:reactor-bom:Bismuth-RELEASE')
     implementation 'io.projectreactor:reactor-core' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>There is no third <code>:</code> separated section for the version. It is taken from
the BOM.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_milestones_and_snapshots"><a class="anchor" href="#_milestones_and_snapshots"></a>2.4.3. Milestones and Snapshots</h4>
<div class="paragraph">
<p>Milestones and developer previews are distributed through the Spring Milestones
repository rather than Maven Central. To add it to your build configuration
file, use the following snippet:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Milestones in Maven</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones Repository&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For Gradle, use the following snippet:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Milestones in Gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
  maven { url 'https://repo.spring.io/milestone' }
  mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Similarly, snapshots are also available in a separate dedicated repository, as the following example show:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. BUILD-SNAPSHOTs in Maven</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshot Repository&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 4. BUILD-SNAPSHOTs in Gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
  maven { url 'https://repo.spring.io/snapshot' }
  mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/gettingStarted.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#getting-started">Getting Started</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="intro-reactive"><a class="anchor" href="#intro-reactive"></a>3. Introduction to Reactive Programming</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reactor 是反应式编程范例的实现，可以总结如下:</p>
</div>
<div class="quoteblock">
<blockquote>
Reactive 编程是一种异步编程范式，它涉及数据流和变化的传播.
现在可以通过所采用的编程语言轻松表达静态（例如数组）或动态（例如事件发射器）数据流。
</blockquote>
<div class="attribution">
&#8212; https://en.wikipedia.org/wiki/Reactive_programming
</div>
</div>
<div class="paragraph">
<p>As a first step in the direction of reactive programming, Microsoft created the Reactive
Extensions (Rx) library in the .NET ecosystem. Then RxJava implemented reactive
programming on the JVM.  As time went on, a standardization for Java emerged through the
Reactive Streams effort, a specification that defines a set of interfaces and
interaction rules for reactive libraries on the JVM. Its interfaces have been
integrated into Java 9 under the <code>Flow</code> class.</p>
</div>
<div class="paragraph">
<p>作为响应式编程方向上的第一步，Microsoft在.NET生态系统中创建了响应式扩展（Rx）库。
然后RxJava在JVM上实现了反应式编程。随着时间的流逝，通过Reactive Streams的努力出现了Java的标准化，
该规范定义了JVM上的响应库的一组接口和交互规则。它的接口已集成到了Java 9中的Flow类下。</p>
</div>
<div class="paragraph">
<p>The reactive programming paradigm is often presented in object-oriented languages as an
extension of the Observer design pattern. You can also compare the main reactive streams
pattern with the familiar Iterator design pattern, as there is a duality to the
<code>Iterable</code>-<code>Iterator</code> pair in all of these libraries. One major difference is that, while
an Iterator is pull-based, reactive streams are push-based.</p>
</div>
<div class="paragraph">
<p>反应式编程范例通常以面向对象的语言表示，像是一个Observer设计模式的扩展。
您还可以将主要的反应流模式与熟悉的Iterator设计模式进行比较，因为所有这些库中的Iterable- Iterator对都有双重性 。
一个主要的区别是，虽然Iterator是基于pull的，但是反应流却是基于push的。</p>
</div>
<div class="paragraph">
<p>Using an iterator is an imperative programming pattern, even though the method of
accessing values is solely the responsibility of the <code>Iterable</code>. Indeed, it is up to the
developer to choose when to access the <code>next()</code> item in the sequence. In reactive
streams, the equivalent of the above pair is <code>Publisher-Subscriber</code>. But it is the
<code>Publisher</code> that notifies the Subscriber of newly available values <em>as they come</em>, and
this push aspect is the key to being reactive. Also, operations applied to pushed values
are expressed declaratively rather than imperatively: The programmer expresses the logic
of the computation rather than describing its exact control flow.</p>
</div>
<div class="paragraph">
<p>使用迭代器是命令式编程模式，即使访问值的方法仅由负责Iterable。
实际上，由开发人员决定何时选择next()序列中的项目。
在反应流中，上述对的等价物为Publisher-Subscriber。
但是，当 Publisher新可用值出现时，正是通知订户，而这一推动方面是做出反应的关键。
同样，应用于推入值的操作以声明方式而不是命令方式表示：程序员表示计算的逻辑，而不是描述其确切的控制流程。</p>
</div>
<div class="paragraph">
<p>In addition to pushing values, the error-handling and completion aspects are also covered
in a well defined manner. A <code>Publisher</code> can push new values to its <code>Subscriber</code> (by
calling <code>onNext</code>) but can also signal an error (by calling <code>onError</code>) or completion (by
calling <code>onComplete</code>). Both errors and completion terminate the sequence. This can
be summed up as follows:</p>
</div>
<div class="paragraph">
<p>除了推送值之外，还以明确定义的方式涵盖了错误处理和完成方面。
A Publisher可以Subscriber（通过调用onNext）将新值推入其值，但也可以发出错误信号（调用onError）或完成信号（通过调用onComplete）。
错误和完成都会终止序列。可以总结如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>onNext x 0..N [onError | onComplete]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This approach is very flexible. The pattern supports use cases where there is no value,
one value, or n values (including an infinite sequence of values, such as the continuing
ticks of a clock).</p>
</div>
<div class="paragraph">
<p>这种方法非常灵活。该模式支持没有值，一个值或n个值（包括无限个有值序列，例如时钟的连续滴答声）的用例。</p>
</div>
<div class="paragraph">
<p>But why do we need such an asynchronous reactive library in the first place?</p>
</div>
<div class="paragraph">
<p>但是为什么我们首先需要这样的异步反应式库？</p>
</div>
<div class="sect2">
<h3 id="_blocking_can_be_wasteful"><a class="anchor" href="#_blocking_can_be_wasteful"></a>3.1. Blocking Can Be Wasteful</h3>
<div class="paragraph">
<p>Modern applications can reach huge numbers of concurrent users, and, even though the
capabilities of modern hardware have continued to improve, performance of
modern software is still a key concern.</p>
</div>
<div class="paragraph">
<p>现代应用程序可以吸引大量的并发用户，即使现代硬件的功能不断提高，现代软件的性能仍然是关键问题。</p>
</div>
<div class="paragraph">
<p>There are, broadly, two ways one can improve a program&#8217;s performance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>parallelize</strong> to use more threads and more hardware resources.</p>
</li>
<li>
<p><strong>seek more efficiency</strong> in how current resources are used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>广义上讲，有两种方法可以提高程序的性能：</p>
</div>
<div class="paragraph">
<p>并行使用更多线程和更多硬件资源。</p>
</div>
<div class="paragraph">
<p>在使用现有资源方面寻求更高的效率。</p>
</div>
<div class="paragraph">
<p>Usually, Java developers write programs by using blocking code. This practice
is fine until there is a performance bottleneck. Then it is time
to introduce additional threads, running similar blocking code. But this
scaling in resource utilization can quickly introduce contention and concurrency
problems.</p>
</div>
<div class="paragraph">
<p>通常，Java开发人员通过使用阻塞代码来编写程序。除非存在性能瓶颈，否则这种做法很好。
然后是时候引入其他线程，运行类似的阻塞代码了。但是这种资源利用的扩展会迅速引入竞争和并发问题。</p>
</div>
<div class="paragraph">
<p>Worse still, blocking wastes resources. If you look closely, as soon as a
program involves some latency (notably I/O, such as a database request or a
network call), resources are wasted because threads (possibly many threads)
now sit idle, waiting for data.</p>
</div>
<div class="paragraph">
<p>更糟糕的是，阻塞会浪费资源。
如果仔细观察，程序一旦遇到一些延迟（特别是I / O，例如数据库请求或网络调用），就会浪费资源，
因为线程（可能有很多线程）现在处于空闲状态，等待数据。</p>
</div>
<div class="paragraph">
<p>So the parallelization approach is not a silver bullet. It is necessary
to access the full power of the hardware, but it is also complex to
reason about and susceptible to resource wasting.</p>
</div>
<div class="paragraph">
<p>因此，并行化方法不是灵丹妙药。有必要访问硬件的全部功能，但是推理和资源浪费也很复杂。</p>
</div>
</div>
<div class="sect2">
<h3 id="_asynchronicity_to_the_rescue"><a class="anchor" href="#_asynchronicity_to_the_rescue"></a>3.2. Asynchronicity to the Rescue?</h3>
<div class="paragraph">
<p>The second approach mentioned earlier, seeking more efficiency, can be a solution
to the resource wasting problem. By writing asynchronous, non-blocking code,
you let the execution switch to another active task that uses the same underlying
resources and later comes back to the current process when the asynchronous
processing has finished.</p>
</div>
<div class="paragraph">
<p>前面提到的第二种方法，寻求更高的效率，可以解决资源浪费的问题。
通过编写异步的非阻塞代码，您可以将执行切换到使用相同基础资源的另一个活动任务，
并在异步处理完成后返回到当前进程。</p>
</div>
<div class="paragraph">
<p>But how can you produce asynchronous code on the JVM? Java offers two models of
asynchronous programming:</p>
</div>
<div class="paragraph">
<p>但是如何在JVM上生成异步代码？Java提供了两种异步编程模型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Callbacks</strong>: Asynchronous methods do not have a return value but take an extra
<code>callback</code> parameter (a lambda or anonymous class) that gets called when the result is
available. A well known example is Swing&#8217;s <code>EventListener</code> hierarchy.</p>
</li>
<li>
<p><strong>Futures</strong>: Asynchronous methods <em>immediately</em> return a <code>Future&lt;T&gt;</code>. The asynchronous
process computes a <code>T</code> value, but the <code>Future</code> object wraps access to it. The value is
not immediately available, and the object can be polled until the value is available. For
instance, an <code>ExecutorService</code> running <code>Callable&lt;T&gt;</code> tasks use <code>Future</code> objects.</p>
</li>
<li>
<p><strong>Callbacks</strong>: 异步方法没有返回值，但带有一个额外的 callback参数（lambda或匿名类），该参数在结果可用时被调用。一个著名的例子是Swing的EventListener层次结构.</p>
</li>
<li>
<p><strong>Futures</strong>: 异步方法立即返回Future&lt;T&gt;。异步过程计算一个T值，但是Future对象包装了对其的访问。该值不是立即可用的，并且可以轮询该对象，直到该值可用为止。例如，ExecutorService正在运行的Callable&lt;T&gt;任务使用Future对象.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Are these techniques good enough? Not for every use case, and both approaches have
limitations.</p>
</div>
<div class="paragraph">
<p>这些技术够好吗？并非针对每个用例，这两种方法都有局限性。</p>
</div>
<div class="paragraph">
<p>Callbacks are hard to compose together, quickly leading to code that is difficult to read
and maintain (known as &#8220;Callback Hell&#8221;).</p>
</div>
<div class="paragraph">
<p>回调很难组合在一起，迅速导致难以阅读和维护的代码（称为“回调地狱”）。</p>
</div>
<div class="paragraph">
<p>Consider an example: showing the top five favorites from a user on the UI or suggestions
if she does not have a favorite. This goes through three services (one gives favorite IDs,
the second fetches favorite details, and the third offers suggestions with details), as
follows:</p>
</div>
<div class="paragraph">
<p>考虑一个示例：在用户界面上显示用户的前五个收藏夹，如果没有收藏夹则显示建议。这需要三项服务（一项提供喜欢的ID，第二项获取喜欢的详细信息，第三项提供带有详细信息的建议），如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Example of Callback Hell</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">userService.getFavorites(userId, new Callback&lt;List&lt;String&gt;&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>
  public void onSuccess(List&lt;String&gt; list) { <i class="conum" data-value="2"></i><b>(2)</b>
    if (list.isEmpty()) { <i class="conum" data-value="3"></i><b>(3)</b>
      suggestionService.getSuggestions(new Callback&lt;List&lt;Favorite&gt;&gt;() {
        public void onSuccess(List&lt;Favorite&gt; list) { <i class="conum" data-value="4"></i><b>(4)</b>
          UiUtils.submitOnUiThread(() -&gt; { <i class="conum" data-value="5"></i><b>(5)</b>
            list.stream()
                .limit(5)
                .forEach(uiList::show); <i class="conum" data-value="6"></i><b>(6)</b>
            });
        }

        public void onError(Throwable error) { <i class="conum" data-value="7"></i><b>(7)</b>
          UiUtils.errorPopup(error);
        }
      });
    } else {
      list.stream() <i class="conum" data-value="8"></i><b>(8)</b>
          .limit(5)
          .forEach(favId -&gt; favoriteService.getDetails(favId, <i class="conum" data-value="9"></i><b>(9)</b>
            new Callback&lt;Favorite&gt;() {
              public void onSuccess(Favorite details) {
                UiUtils.submitOnUiThread(() -&gt; uiList.show(details));
              }

              public void onError(Throwable error) {
                UiUtils.errorPopup(error);
              }
            }
          ));
    }
  }

  public void onError(Throwable error) {
    UiUtils.errorPopup(error);
  }
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们有基于回调的服务：一种Callback接口，该接口的方法在异步过程成功时被调用，在错误发生时被调用。.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个服务使用收藏夹ID列表调用其回调.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果列表为空，则必须转到suggestionService.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在suggestionService给出了一个List&lt;Favorite&gt;到第二个回调.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>由于我们处理的是UI，因此我们需要确保使用的代码在UI线程中运行.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>我们使用Java 8 Stream将处理的建议数限制为五个，并在UI的图形列表中显示它们.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>在每个级别，我们以相同的方式处理错误：在弹出窗口中显示它们.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>返回收藏夹ID级别。如果服务返回了完整列表，则需要转到favoriteService以获取详细的Favorite对象。由于我们只需要五个，因此我们首先传输ID列表以将其限制为五个.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>再一次，回调。这次，我们得到了一个完整的Favorite对象，我们将该对象压入UI线程中的UI.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>That is a lot of code, and it is a bit hard to follow and has repetitive parts.
Consider its equivalent in Reactor:</p>
</div>
<div class="paragraph">
<p>那是很多代码，很难遵循并且包含重复的部分。考虑它在Reactor中的等效功能:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. Example of Reactor code equivalent to callback code</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">userService.getFavorites(userId) <i class="conum" data-value="1"></i><b>(1)</b>
           .flatMap(favoriteService::getDetails) <i class="conum" data-value="2"></i><b>(2)</b>
           .switchIfEmpty(suggestionService.getSuggestions()) <i class="conum" data-value="3"></i><b>(3)</b>
           .take(5) <i class="conum" data-value="4"></i><b>(4)</b>
           .publishOn(UiUtils.uiThreadScheduler()) <i class="conum" data-value="5"></i><b>(5)</b>
           .subscribe(uiList::show, UiUtils::errorPopup); <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们从收藏夹ID的流开始.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们将这些异步转换为详细的Favorite对象（flatMap）。现在我们有一个流程Favorite.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果的流程Favorite为空，则通过切换到后备广告 suggestionService.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们最多只对结果流中的五个元素感兴趣.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>最后，我们要处理UI线程中的每个数据.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>我们通过描述如何处理数据的最终形式（在UI列表中显示）以及发生错误的情况（显示弹出窗口）来触发流程.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>What if you want to ensure the favorite IDs are retrieved in less than 800ms or, if it
takes longer, get them from a cache? In the callback-based code, that is a complicated
task. In Reactor it becomes as easy as adding a <code>timeout</code> operator in the chain, as follows:</p>
</div>
<div class="paragraph">
<p>如果要确保在少于800毫秒的时间内检索喜欢的ID，或者如果花费更长的时间我们就从缓存中获取它们，该怎么办？
在基于回调的代码中，这是一项复杂的任务。在Reactor中，就像在链中添加一个timeout运算符一样容易，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. Example of Reactor code with timeout and fallback</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">userService.getFavorites(userId)
           .timeout(Duration.ofMillis(800)) <i class="conum" data-value="1"></i><b>(1)</b>
           .onErrorResume(cacheService.cachedFavoritesFor(userId)) <i class="conum" data-value="2"></i><b>(2)</b>
           .flatMap(favoriteService::getDetails) <i class="conum" data-value="3"></i><b>(3)</b>
           .switchIfEmpty(suggestionService.getSuggestions())
           .take(5)
           .publishOn(UiUtils.uiThreadScheduler())
           .subscribe(uiList::show, UiUtils::errorPopup);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果以上部分在800ms内没有发出任何光，则传播一个错误.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果发生错误，请退回到cacheService.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>链的其余部分与前面的示例相似.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><code>Future</code> objects are a bit better than callbacks, but they still do not do well at composition,
despite the improvements brought in Java 8 by <code>CompletableFuture</code>. Orchestrating multiple
<code>Future</code> objects together is doable but not easy. Also, <code>Future</code> has other problems:</p>
</div>
<div class="paragraph">
<p>Future对象比回调要好一些，但是尽管Java 8带来了改进，但它们在组合方面仍然表现不佳CompletableFuture。
Future一起编排多个 对象是可行的，但并不容易。另外，Future还有其他问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is easy to end up with another blocking situation with <code>Future</code> objects by calling
the <code>get()</code> method.</p>
</li>
<li>
<p>They do not support lazy computation.</p>
</li>
<li>
<p>They lack support for multiple values and advanced error handling.</p>
</li>
<li>
<p>Future通过调用该get()方法很容易导致对象的另一种阻塞情况.</p>
</li>
<li>
<p>它们不支持惰性计算.</p>
</li>
<li>
<p>他们缺乏对多个值和高级错误处理的支持.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider another example: We get a list of IDs from which we want to fetch a name and a
statistic and combine these pair-wise, all of it asynchronously. The following example
does so with a list of type <code>CompletableFuture</code>:</p>
</div>
<div class="paragraph">
<p>再看一个例子：我们得到一个ID列表，我们要从中获取一个名称和一个统计信息，并将它们成对组合，所有这些信息都是异步的。
以下示例使用类型列表进行操作CompletableFuture:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. Example of <code>CompletableFuture</code> combination</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CompletableFuture&lt;List&lt;String&gt;&gt; ids = ifhIds(); <i class="conum" data-value="1"></i><b>(1)</b>

CompletableFuture&lt;List&lt;String&gt;&gt; result = ids.thenComposeAsync(l -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
	Stream&lt;CompletableFuture&lt;String&gt;&gt; zip =
			l.stream().map(i -&gt; { <i class="conum" data-value="3"></i><b>(3)</b>
				CompletableFuture&lt;String&gt; nameTask = ifhName(i); <i class="conum" data-value="4"></i><b>(4)</b>
				CompletableFuture&lt;Integer&gt; statTask = ifhStat(i); <i class="conum" data-value="5"></i><b>(5)</b>

				return nameTask.thenCombineAsync(statTask, (name, stat) -&gt; "Name " + name + " has stats " + stat); <i class="conum" data-value="6"></i><b>(6)</b>
			});
	List&lt;CompletableFuture&lt;String&gt;&gt; combinationList = zip.collect(Collectors.toList()); <i class="conum" data-value="7"></i><b>(7)</b>
	CompletableFuture&lt;String&gt;[] combinationArray = combinationList.toArray(new CompletableFuture[combinationList.size()]);

	CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(combinationArray); <i class="conum" data-value="8"></i><b>(8)</b>
	return allDone.thenApply(v -&gt; combinationList.stream()
			.map(CompletableFuture::join) <i class="conum" data-value="9"></i><b>(9)</b>
			.collect(Collectors.toList()));
});

List&lt;String&gt; results = result.join(); <i class="conum" data-value="10"></i><b>(10)</b>
assertThat(results).contains(
		"Name NameJoe has stats 103",
		"Name NameBart has stats 104",
		"Name NameHenry has stats 105",
		"Name NameNicole has stats 106",
		"Name NameABSLAJNFOAJNFOANFANSF has stats 121");</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们从一个可以为我们提供id价值清单的Future开始.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>一旦获得列表，我们想开始更深层次的异步处理.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>对于列表中的每个元素:</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>异步获取关联名称.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>异步获取关联的任务.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>合并两个结果.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>现在，我们有了代表所有组合任务的期货清单。要执行这些任务，我们需要将列表转换为数组.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>将数组传递给CompletableFuture.allOf，在所有任务完成后输出CompletableFuture.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>棘手的一点是allOfreturn CompletableFuture&lt;Void&gt;，因此我们在期货列表上重申，通过使用收集其结果join() （此处不会阻塞，因为allOf确保了期货全部完成了）.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>一旦整个异步管道被触发，我们等待它被处理并返回结果列表.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Since Reactor has more combination operators out of the box, this process can be
simplified, as follows:</p>
</div>
<div class="paragraph">
<p>由于Reactor提供了更多组合运算符，因此可以简化此过程，如下所示</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. Example of Reactor code equivalent to future code</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; ids = ifhrIds(); <i class="conum" data-value="1"></i><b>(1)</b>

Flux&lt;String&gt; combinations =
		ids.flatMap(id -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
			Mono&lt;String&gt; nameTask = ifhrName(id); <i class="conum" data-value="3"></i><b>(3)</b>
			Mono&lt;Integer&gt; statTask = ifhrStat(id); <i class="conum" data-value="4"></i><b>(4)</b>

			return nameTask.zipWith(statTask, <i class="conum" data-value="5"></i><b>(5)</b>
					(name, stat) -&gt; "Name " + name + " has stats " + stat);
		});

Mono&lt;List&lt;String&gt;&gt; result = combinations.collectList(); <i class="conum" data-value="6"></i><b>(6)</b>

List&lt;String&gt; results = result.block(); <i class="conum" data-value="7"></i><b>(7)</b>
assertThat(results).containsExactly( <i class="conum" data-value="8"></i><b>(8)</b>
		"Name NameJoe has stats 103",
		"Name NameBart has stats 104",
		"Name NameHenry has stats 105",
		"Name NameNicole has stats 106",
		"Name NameABSLAJNFOAJNFOANFANSF has stats 121"
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这次，我们从ids（a Flux&lt;String&gt;）的异步提供序列开始.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>对于序列中的每个元素，我们（在主体flatMap调用的函数内部）异步处理两次.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>获取关联的名称.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>获取相关的统计信息.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>异步组合两个值.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>当值可用完成可用时，将值汇总到List中.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>在生产中，我们将Flux通过进一步组合或订阅来继续异步处理。很可能会返回result Mono。由于我们正在测试中，因此我们改为阻塞，等待处理完成，然后直接返回汇总的值列表.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>声明结果.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The perils of using callbacks and <code>Future</code> objects are similar and are what reactive programming
addresses with the <code>Publisher-Subscriber</code> pair.</p>
</div>
<div class="paragraph">
<p>使用回调和Future对象的风险是相似的，这是响应式编程Publisher-Subscriber它们一起要解决的问题</p>
</div>
</div>
<div class="sect2">
<h3 id="_from_imperative_to_reactive_programming"><a class="anchor" href="#_from_imperative_to_reactive_programming"></a>3.3. From Imperative to Reactive Programming</h3>
<div class="paragraph">
<p>Reactive libraries, such as Reactor, aim to address these drawbacks of &#8220;classic&#8221;
asynchronous approaches on the JVM while also focusing on a few additional aspects:</p>
</div>
<div class="paragraph">
<p>反应性库（例如Reactor）旨在解决JVM上“经典”异步方法的这些缺点，同时还着重于其他一些方面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Composability</strong> and <strong>readability</strong></p>
</li>
<li>
<p>Data as a <strong>flow</strong> manipulated with a rich vocabulary of <strong>operators</strong></p>
</li>
<li>
<p>Nothing happens until you <strong>subscribe</strong></p>
</li>
<li>
<p><strong>Backpressure</strong> or <em>the ability for the consumer to signal the producer that the rate of
emission is too high</em></p>
</li>
<li>
<p><strong>High level</strong> but <strong>high value</strong> abstraction that is <em>concurrency-agnostic</em></p>
</li>
<li>
<p>可组合性和可读性</p>
</li>
<li>
<p>以丰富的运算符词汇操纵数据流</p>
</li>
<li>
<p>subscribe之前没有任何反应</p>
</li>
<li>
<p><strong>Backpressure</strong> 或消费者向生产者发出排放速率过高信号的能力</p>
</li>
<li>
<p>并发不可知的高级但高价值的抽象</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_composability_and_readability"><a class="anchor" href="#_composability_and_readability"></a>3.3.1. Composability and Readability</h4>
<div class="paragraph">
<p>By &#8220;composability&#8221;, we mean the ability to orchestrate multiple asynchronous tasks, in
which we use results from previous tasks to feed input to subsequent ones.
Alternatively, we can run several tasks in a fork-join style.
In addition, we can reuse asynchronous tasks as discrete components in a
higher-level system.</p>
</div>
<div class="paragraph">
<p>The ability to orchestrate tasks is tightly coupled to the readability and
maintainability of code. As the layers of asynchronous processes increase in both number
and complexity, being able to compose and read code becomes increasingly difficult. As we
saw, the callback model is simple, but one of its main drawbacks is that, for complex
processes, you need to have a callback executed from a callback, itself nested inside
another callback, and so on. That mess is known as &#8220;Callback Hell&#8221;. As you can guess (or
know from experience), such code is pretty hard to go back to and reason about.</p>
</div>
<div class="paragraph">
<p>Reactor offers rich composition options, wherein code mirrors the organization of the
abstract process, and everything is generally kept at the same level (nesting is
minimized).</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_assembly_line_analogy"><a class="anchor" href="#_the_assembly_line_analogy"></a>3.3.2. The Assembly Line Analogy</h4>
<div class="paragraph">
<p>You can think of data processed by a reactive application as moving through an assembly
line. Reactor is both the conveyor belt and the workstations. The raw material pours from
a source (the original <code>Publisher</code>) and ends up as a finished product ready to be pushed
to the consumer (or <code>Subscriber</code>).</p>
</div>
<div class="paragraph">
<p>您可以将反应式应用程序处理的数据视为流水线。反应堆既是传送带又是工作站。原材料从来源（原始Publisher）倾泻而出，最终成为准备好推向消费者（或Subscriber）的成品</p>
</div>
<div class="paragraph">
<p>The raw material can go through various transformations and other intermediary steps or
be part of a larger assembly line that aggregates intermediate pieces together. If there
is a glitch or clogging at one point (perhaps boxing the products takes a
disproportionately long time), the afflicted workstation can signal upstream to limit the
flow of raw material.</p>
</div>
<div class="paragraph">
<p>原材料可以经过各种转换和其他中间步骤，也可以成为将中间件聚集在一起的较大装配线的一部分。如果某一点出现故障或堵塞（也许装箱产品花费的时间过长），那么受灾的工作站可以向上游发出信号，以限制原材料的流动</p>
</div>
</div>
<div class="sect3">
<h4 id="_operators"><a class="anchor" href="#_operators"></a>3.3.3. Operators</h4>
<div class="paragraph">
<p>In Reactor, operators are the workstations in our assembly analogy. Each operator adds
behavior to a <code>Publisher</code> and wraps the previous step&#8217;s <code>Publisher</code> into a new instance.
The whole chain is thus linked, such that data originates from the first <code>Publisher</code> and
moves down the chain, transformed by each link. Eventually, a <code>Subscriber</code> finishes the
process. Remember that nothing happens until a <code>Subscriber</code> subscribes to a <code>Publisher</code>,
as we see shortly.</p>
</div>
<div class="paragraph">
<p>在Reactor中，操作员是我们装配类比中的工作站。每个运算符都将行为添加到Publisher，并将上一步包装Publisher到新实例中。
因此，整个链被链接在一起，这样数据就从第一个Publisher链开始并向下移动，并由每个链接转换。
最终，Subscriber完成该过程。请记住，直到a Subscriber订阅了Publisher，什么都不会发生，正如我们很快看到的那样。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Understanding that operators create new instances can help you avoid a common
mistake that would lead you to believe that an operator you used in your chain is not
being applied. See this <a href="#faq.chain">item</a> in the FAQ.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>While the Reactive Streams specification does not specify operators at all, one of the
best added values of reactive libraries, such as Reactor, is the rich vocabulary of
operators that they provide. These cover a lot of ground, from simple transformation and
filtering to complex orchestration and error handling.</p>
</div>
<div class="paragraph">
<p>虽然反应式流规范根本没有指定运算符，
但是反应式库的最佳附加值之一（例如Reactor）是它们提供的运算符的丰富词汇表。
从简单的转换和过滤到复杂的编排和错误处理，这些内容涉及很多领域</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.subscribe"><a class="anchor" href="#reactive.subscribe"></a>3.3.4. Nothing Happens Until You <code>subscribe()</code></h4>
<div class="paragraph">
<p>In Reactor, when you write a <code>Publisher</code> chain, data does not start pumping into it by
default. Instead, you create an abstract description of your asynchronous process (which
can help with reusability and composition).</p>
</div>
<div class="paragraph">
<p>在Reactor中，当您编写Publisher链时，默认情况下不会开始将数据泵入链中。
相反，您可以创建异步过程的抽象描述（这有助于重用和组合）。</p>
</div>
<div class="paragraph">
<p>By the act of <strong>subscribing</strong>, you tie the <code>Publisher</code> to a <code>Subscriber</code>, which triggers
the flow of data in the whole chain. This is achieved internally by a single <code>request</code>
signal from the <code>Subscriber</code> that is propagated upstream, all the way back to the source
<code>Publisher</code>.</p>
</div>
<div class="paragraph">
<p>通过subscribing操作，您可以将绑定Publisher到Subscriber，从而触发整个链中的数据流。
这是通过request 来自的信号在内部实现的，该信号在Subscriber上游传播，一直传回到信号源 Publisher。</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.backpressure"><a class="anchor" href="#reactive.backpressure"></a>3.3.5. Backpressure</h4>
<div class="paragraph">
<p>Propagating signals upstream is also used to implement <strong>backpressure</strong>, which we described
in the assembly line analogy as a feedback signal sent up the line when a workstation
processes more slowly than an upstream workstation.</p>
</div>
<div class="paragraph">
<p>上游传播的信号也用于实现背压，我们在组装流水线中将其描述为当工作站的处理速度比上游工作站慢时，沿生产线向上发送的反馈信号。</p>
</div>
<div class="paragraph">
<p>The real mechanism defined by the Reactive Streams specification is pretty close to the
analogy: A subscriber can work in <em>unbounded</em> mode and let the source push all the data
at its fastest achievable rate or it can use the <code>request</code> mechanism to signal the source
that it is ready to process at most <code>n</code> elements.</p>
</div>
<div class="paragraph">
<p>Reactive Streams规范定义的实际机制与类推非常接近：
subscriber 可以以无界模式工作，并让源以最快可达到的速率推送所有数据，或者可以使用该request机制向源发出已准备就绪的信号处理最多的n元素。</p>
</div>
<div class="paragraph">
<p>Intermediate operators can also change the request in-transit. Imagine a <code>buffer</code>
operator that groups elements in batches of ten. If the subscriber requests one buffer, it
is acceptable for the source to produce ten elements. Some operators also implement
<strong>prefetching</strong> strategies, which avoid <code>request(1)</code> round-trips and is beneficial
if producing the elements before they are requested is not too costly.</p>
</div>
<div class="paragraph">
<p>中间的Intermediate还可以在途中更改请求。想象一下，一个buffer 运算符将元素以十个为一组进行分组。
如果subscriber请求一个缓冲区，则源产生十个元素是可以接受的。
一些operators还实施了 预取策略，该策略可避免request(1)往返，并且如果在请求之前生产元素的成本不太高的话，则是有益的。</p>
</div>
<div class="paragraph">
<p>This transforms the push model into a <strong>push-pull hybrid</strong>, where the downstream can pull n
elements from upstream if they are readily available. But if the elements are not ready,
they get pushed by the upstream whenever they are produced.</p>
</div>
<div class="paragraph">
<p>这会将推模型转换为推拉混合模型，如果下游可以随时使用，则下游可以从上游拉取n个元素。
但是，如果元素尚未准备就绪，则每当它们被生产时就会被上游推出。</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.hotCold"><a class="anchor" href="#reactive.hotCold"></a>3.3.6. Hot vs Cold</h4>
<div class="paragraph">
<p>The Rx family of reactive libraries distinguishes two broad categories of
reactive sequences: <strong>hot</strong> and <strong>cold</strong>. This distinction mainly has to do with how the
reactive stream reacts to subscribers:</p>
</div>
<div class="paragraph">
<p>Rx反应库的家族将反应序列分为两大类：热和冷。这种区别主要与反应流对订户的反应有关：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <strong>Cold</strong> sequence starts anew for each <code>Subscriber</code>, including at the source of data.
For example, if the source wraps an HTTP call, a new HTTP request is made for each subscription.</p>
</li>
<li>
<p>A <strong>Hot</strong> sequence does not start from scratch for each <code>Subscriber</code>. Rather, late
subscribers receive signals emitted <em>after</em> they subscribed. Note, however, that some hot
reactive streams can cache or replay the history of emissions totally or partially. From
a general perspective, a hot sequence can even emit when no subscriber is listening (an
exception to the &#8220;nothing happens before you subscribe&#8221; rule).</p>
</li>
<li>
<p>每一个冷序列都重新开始Subscriber，包括在数据源处。例如，如果源包装了一个HTTP调用，则会为每个订阅发出一个新的HTTP请求.</p>
</li>
<li>
<p>每个Hot序列都不是从头开始的Subscriber。相反，后期用户接收发出的信号后，他们认购。但是请注意，某些热反应流可以全部或部分缓存或重放排放历史。从一般的角度来看，即使没有订阅者在收听，热序列甚至会发出（“订阅之前什么也没有发生”规则的例外）.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information on hot vs cold in the context of Reactor, see
<a href="#reactor.hotCold">this reactor-specific section</a>.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/reactiveProgramming.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#intro-reactive">Introduction to Reactive Programming</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="core-features"><a class="anchor" href="#core-features"></a>4. Reactor Core Features</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Reactor project main artifact is <code>reactor-core</code>, a reactive library that focuses on
the Reactive Streams specification and targets Java 8.</p>
</div>
<div class="paragraph">
<p>Reactor项目的主要工件是reactor-core一个反应式库，该库侧重于Reactive Streams规范，并针对Java 8。</p>
</div>
<div class="paragraph">
<p>Reactor introduces composable reactive types that implement <code>Publisher</code> but also provide
a rich vocabulary of operators: <code>Flux</code> and <code>Mono</code>. A <code>Flux</code> object
represents a reactive sequence of 0..N items, while a <code>Mono</code> object represents a
single-value-or-empty (0..1) result.</p>
</div>
<div class="paragraph">
<p>Reactor引入了可实现的可反应类型，这些可实现Publisher但也提供了丰富的运算符词汇：Flux和Mono。
Flux对象表示的0..N项的反应序列，而一个Mono对象表示单值或空（0..1）的结果。</p>
</div>
<div class="paragraph">
<p>This distinction carries a bit of semantic information into the type, indicating the
rough cardinality of the asynchronous processing. For instance, an HTTP request produces
only one response, so there is not much sense in doing a <code>count</code> operation. Expressing
the result of such an HTTP call as a <code>Mono&lt;HttpResponse&gt;</code> thus makes more sense than
expressing it as a <code>Flux&lt;HttpResponse&gt;</code>, as it offers only operators that are relevant to
a context of zero items or one item.</p>
</div>
<div class="paragraph">
<p>这种区别在类型中包含了一些语义信息，表明了异步处理的粗略基数。
例如，一个HTTP请求仅产生一个响应，因此进行count操作没有太大意义。
因此，将HTTP调用的结果表示为 Mono&lt;HttpResponse&gt;比将其表示为Flux&lt;HttpResponse&gt;更有意义，因为它仅提供与零项或一个项的上下文相关的运算符。</p>
</div>
<div class="paragraph">
<p>Operators that change the maximum cardinality of the processing also switch to the
relevant type. For instance, the <code>count</code> operator exists in <code>Flux</code>, but it returns a
<code>Mono&lt;Long&gt;</code>.</p>
</div>
<div class="paragraph">
<p>更改处理最大基数的运算符也将切换到相关类型。例如，count运算符存在于中Flux，但返回 Mono&lt;Long&gt;。</p>
</div>
<div class="sect2">
<h3 id="flux"><a class="anchor" href="#flux"></a>4.1. <code>Flux</code>, an Asynchronous Sequence of 0-N Items</h3>
<div class="paragraph">
<p>The following image shows how a <code>Flux</code> transforms items:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/flux.png" alt="Flux">
</div>
</div>
<div class="paragraph">
<p>A <code>Flux&lt;T&gt;</code> is a standard <code>Publisher&lt;T&gt;</code> that represents an asynchronous sequence of 0 to N
emitted items, optionally terminated by either a completion signal or an error.
As in the Reactive Streams spec, these three types of signal translate to calls to a downstream
Subscriber&#8217;s <code>onNext</code>, <code>onComplete</code>, and <code>onError</code> methods.</p>
</div>
<div class="paragraph">
<p>Flux&lt;T&gt;是Publisher&lt;T&gt;代表0到N个发射项目的异步序列的标准，可以选择通过完成信号或错误终止。
如反应式流规范中，这三种类型的信号转换为呼叫到下游Subscriber的onNext，onComplete和onError方法。</p>
</div>
<div class="paragraph">
<p>With this large scope of possible signals, <code>Flux</code> is the general-purpose reactive type.
Note that all events, even terminating ones, are optional: no <code>onNext</code> event but an
<code>onComplete</code> event represents an <em>empty</em> finite sequence, but remove the <code>onComplete</code> and
you have an <em>infinite</em> empty sequence (not particularly useful, except for tests around cancellation).
Similarly, infinite sequences are not necessarily empty. For example, <code>Flux.interval(Duration)</code>
produces a <code>Flux&lt;Long&gt;</code> that is infinite and emits regular ticks from a clock.</p>
</div>
<div class="paragraph">
<p>在这么大范围的可能信号中，Flux是通用信号类型。
请注意，所有事件，甚至是终止事件，都是可选的：没有onNext事件，但一个 onComplete事件表示一个空的有限序列，但是删除onComplete，您将获得一个无限的空序列（除了取消测试外，它不是特别有用）。
同样，无限序列不一定为空。例如，Flux.interval(Duration) 产生一个Flux&lt;Long&gt;无限的并且从时钟发出规则的滴答声。</p>
</div>
</div>
<div class="sect2">
<h3 id="mono"><a class="anchor" href="#mono"></a>4.2. <code>Mono</code>, an Asynchronous 0-1 Result</h3>
<div class="paragraph">
<p>The following image shows how a <code>Mono</code> transforms an item:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/mono.png" alt="Mono">
</div>
</div>
<div class="paragraph">
<p>A <code>Mono&lt;T&gt;</code> is a specialized <code>Publisher&lt;T&gt;</code> that emits at most one item and then
(optionally) terminates with an <code>onComplete</code> signal or an <code>onError</code> signal.</p>
</div>
<div class="paragraph">
<p>Mono&lt;T&gt;是一个专门的Publisher&lt;T&gt;，最多发出一个项目，
然后（可选）以一个onComplete信号或一个onError信号终止。</p>
</div>
<div class="paragraph">
<p>It offers only a subset of the operators that are available for a <code>Flux</code>, and
some operators (notably those that combine the <code>Mono</code> with another <code>Publisher</code>)
switch to a <code>Flux</code>.
For example, <code>Mono#concatWith(Publisher)</code> returns a <code>Flux</code> while <code>Mono#then(Mono)</code>
returns another <code>Mono</code>.</p>
</div>
<div class="paragraph">
<p>它仅提供可用于Flux的运算符的一个子集，而某些运算符（特别是那些Mono与另一个结合的运算符Publisher）切换到Flux。
例如，Mono#concatWith(Publisher)返回Flux一会儿Mono#then(Mono) 返回另一个Mono。</p>
</div>
<div class="paragraph">
<p>Note that you can use a <code>Mono</code> to represent no-value asynchronous processes that only
have the concept of completion (similar to a <code>Runnable</code>). To create one, you can use an empty
<code>Mono&lt;Void&gt;</code>.</p>
</div>
<div class="paragraph">
<p>请注意，您可以使用 Mono表示仅具有完成概念的无值异步流程（类似于Runnable）。要创建一个，您可以使用empty Mono&lt;Void&gt;。</p>
</div>
</div>
<div class="sect2">
<h3 id="_simple_ways_to_create_a_flux_or_mono_and_subscribe_to_it"><a class="anchor" href="#_simple_ways_to_create_a_flux_or_mono_and_subscribe_to_it"></a>4.3. Simple Ways to Create a Flux or Mono and Subscribe to It</h3>
<div class="paragraph">
<p>The easiest way to get started with <code>Flux</code> and <code>Mono</code> is to use one of the numerous
factory methods found in their respective classes.</p>
</div>
<div class="paragraph">
<p>最简单的方式开始使用Flux和Mono是使用在各自的类别中的众多工厂方法之一。</p>
</div>
<div class="paragraph">
<p>For instance, to create a sequence of <code>String</code>, you can either enumerate them or put them
in a collection and create the Flux from it, as follows:</p>
</div>
<div class="paragraph">
<p>例如，要创建的序列String，您可以枚举它们或将它们放入集合中并从中创建Flux，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; seq1 = Flux.just("foo", "bar", "foobar");

List&lt;String&gt; iterable = Arrays.asList("foo", "bar", "foobar");
Flux&lt;String&gt; seq2 = Flux.fromIterable(iterable);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Other examples of factory methods include the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Mono&lt;String&gt; noData = Mono.empty(); <i class="conum" data-value="1"></i><b>(1)</b>

Mono&lt;String&gt; data = Mono.just("foo");

Flux&lt;Integer&gt; numbersFromFiveToSeven = Flux.range(5, 3); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>请注意，即使工厂方法没有任何价值，它也会尊重该泛型类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个参数是范围的开始，而第二个参数是要生成的项目数.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>When it comes to subscribing, <code>Flux</code> and <code>Mono</code> make use of Java 8 lambdas. You
have a wide choice of <code>.subscribe()</code> variants that take lambdas for different
combinations of callbacks, as shown in the following method signatures:</p>
</div>
<div class="paragraph">
<p>当谈到订阅，Flux以及Mono 采用Java 8 lambda表达式。
您可以选择多种.subscribe()类型的变体，它们针对不同的回调组合采用lambda表达式，如以下方法签名所示：</p>
</div>
<div id="subscribeMethods" class="exampleblock">
<div class="title">Example 10. Lambda-based subscribe variants for <code>Flux</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">subscribe(); <i class="conum" data-value="1"></i><b>(1)</b>

subscribe(Consumer&lt;? super T&gt; consumer); <i class="conum" data-value="2"></i><b>(2)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer); <i class="conum" data-value="3"></i><b>(3)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer); <i class="conum" data-value="4"></i><b>(4)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer,
          Consumer&lt;? super Subscription&gt; subscriptionConsumer); <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>订阅并触发序列.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>为每个产生的值做点事.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>处理值，但也会对错误做出反应.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>处理值和错误，但在序列成功完成后还要运行一些代码.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>处理值和错误并成功完成，但还要处理因subscribe调用产生的结果Subscription.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
These variants return a reference to the subscription that you can use to cancel the
subscription when no more data is needed. Upon cancellation, the source should stop
producing values and clean up any resources it created. This cancel-and-clean-up behavior
is represented in Reactor by the general-purpose <code>Disposable</code> interface.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
这些变体返回对订阅的引用，您可以在不需要更多数据时使用该引用来取消订阅。
取消后，源应停止产生值并清除其创建的任何资源。这种取消和清理行为在Reactor中由通用Disposable接口表示。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_subscribe_method_examples"><a class="anchor" href="#_subscribe_method_examples"></a>4.3.1. <code>subscribe</code> Method Examples</h4>
<div class="paragraph">
<p>This section contains minimal examples of each of the five signatures for the <code>subscribe</code>
method. The following code shows an example of the basic method with no arguments:</p>
</div>
<div class="paragraph">
<p>本节包含该subscribe 方法的五个签名中每个签名的最少示例。以下代码显示了不带参数的基本方法的示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 3); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置一个Flux在订阅者加入时产生三个值的。以最简单的方式订阅.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>以最简单的方式订阅.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces no visible output, but it does work. The <code>Flux</code> produces
three values. If we provide a lambda, we can make the values visible. The next example
for the <code>subscribe</code> method shows one way to make the values appear:</p>
</div>
<div class="paragraph">
<p>前面的代码没有产生可见的输出，但是它确实起作用。将Flux产生三个值。如果提供lambda，则可以使值可见。
该subscribe方法的下一个示例显示了一种使值出现的方法</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 3); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(i -&gt; System.out.println(i)); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置一个Flux在订阅者加入时产生三个值的.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>用将打印值的订阅者订阅.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>1
2
3</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To demonstrate the next signature, we intentionally introduce an error, as
shown in the following example:</p>
</div>
<div class="paragraph">
<p>为了演示下一个签名，我们有意引入一个错误，如以下示例所示</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4) <i class="conum" data-value="1"></i><b>(1)</b>
      .map(i -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
        if (i &lt;= 3) return i; <i class="conum" data-value="3"></i><b>(3)</b>
        throw new RuntimeException("Got to 4"); <i class="conum" data-value="4"></i><b>(4)</b>
      });
ints.subscribe(i -&gt; System.out.println(i), <i class="conum" data-value="5"></i><b>(5)</b>
      error -&gt; System.err.println("Error: " + error));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置一个Flux，当订阅者连接时它会产生四个值.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们需要一个map，以便我们可以不同地处理某些值.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>对于大多数值，请返回该值.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>对于一个值，强制执行错误.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>用包含错误处理程序的订阅者进行Subscribe.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>We now have two lambda expressions: one for the content we expect and one for
errors. The preceding code produces the following output:</p>
</div>
<div class="paragraph">
<p>现在，我们有两个lambda表达式：一个用于期望的内容，另一个用于错误。上面的代码产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>1
2
3
Error: java.lang.RuntimeException: Got to 4</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The next signature of the <code>subscribe</code> method includes both an error handler and
a handler for completion events, as shown in the following example:</p>
</div>
<div class="paragraph">
<p>该subscribe方法的下一个签名包括错误处理程序和完成事件处理程序，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; System.out.println("Done")); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置一个Flux，当订阅者连接时它会产生四个值.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用包括完成事件处理程序的订阅服务器进行订阅.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Error signals and completion signals are both terminal events and are exclusive of one
another (you never get both). To make the completion consumer work, we must take care not
to trigger an error.</p>
</div>
<div class="paragraph">
<p>错误信号和完成信号都是终端事件，并且彼此互斥（您永远不会都得到）。为了使完成消费者工作，我们必须注意不要触发错误</p>
</div>
<div class="paragraph">
<p>The completion callback has no input, as represented by an empty pair of
parentheses: It matches the <code>run</code> method in the <code>Runnable</code> interface. The preceding code
produces the following output:</p>
</div>
<div class="paragraph">
<p>完成回调没有输入，由一对空括号表示：它与接口中的run方法匹配Runnable。上面的代码产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>1
2
3
4
Done</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The last signature of the <code>subscribe</code> method includes a <code>Consumer&lt;Subscription&gt;</code>.</p>
</div>
<div class="paragraph">
<p>该subscribe方法的最后一个签名包括Consumer&lt;Subscription&gt;。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
That variant requires you to do something with the <code>Subscription</code> (perform a
<code>request(long)</code> on it or <code>cancel()</code> it). Otherwise the <code>Flux</code> hangs.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
该变体要求您对Subscription进行某些操作（request(long)或 cancel()）。否则Flux会挂起。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the last signature of the <code>subscribe</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; System.out.println("Done"),
    sub -&gt; sub.request(10)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>当我们订阅时，我们会收到Subscription。表示我们要从源头获取 10 个元素（实际上将发出4个元素并完成).</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cancelling_a_subscribe_with_its_disposable"><a class="anchor" href="#_cancelling_a_subscribe_with_its_disposable"></a>4.3.2. Cancelling a <code>subscribe()</code> with Its <code>Disposable</code></h4>
<div class="paragraph">
<p>All these lambda-based variants of <code>subscribe()</code> have a <code>Disposable</code> return type.
In this case, the <code>Disposable</code> interface represents the fact that the subscription
can be <em>cancelled</em>, by calling its <code>dispose()</code> method.</p>
</div>
<div class="paragraph">
<p>所有这些基于lambda的变体subscribe()都具有Disposable返回类型。
在这种情况下，该Disposable接口表示可以实现通过调用方法dispose()来取消订阅。</p>
</div>
<div class="paragraph">
<p>For a <code>Flux</code> or <code>Mono</code>, cancellation is a signal that the source should stop
producing elements. However, it is NOT guaranteed to be immediate: Some sources
might produce elements so fast that they could complete even before receiving the
cancel instruction.</p>
</div>
<div class="paragraph">
<p>对于Flux或Mono，取消表示信号源应停止产生元素。
但是，并不能保证立即执行：某些源可能会产生如此快的元素，以至于甚至在接收到取消指令之前它们也可以完成。</p>
</div>
<div class="paragraph">
<p>Some utilities around <code>Disposable</code> are available in the <code>Disposables</code> class.
Among these, <code>Disposables.swap()</code> creates a <code>Disposable</code> wrapper that lets
you atomically cancel and replace a concrete <code>Disposable</code>. This can be useful,
for instance, in a UI scenario where you want to cancel a request and replace it
with a new one whenever the user clicks on a button. Disposing the wrapper itself
closes it. Doing so disposes the current concrete value and all future attempted replacements.</p>
</div>
<div class="paragraph">
<p>在Disposable类中提供了一些实用程序。
在其中，Disposables.swap()创建一个Disposable包装器，使您可以自动取消和替换具体的Disposable。
例如，这在UI场景中很有用，在UI场景中，您希望在用户单击按钮时取消请求并将其替换为新请求。
包装器本身会将其自动关闭。这样做会处置当前的具体的值以及将来所有尝试的替代品。</p>
</div>
<div class="paragraph">
<p>Another interesting utility is <code>Disposables.composite(&#8230;&#8203;)</code>. This composite
lets you collect several <code>Disposable</code>&#8201;&#8212;&#8201;for instance, multiple in-flight requests
associated with a service call&#8201;&#8212;&#8201;and dispose all of them at once later on.
Once the composite&#8217;s <code>dispose()</code> method has been called, any attempt to add
another <code>Disposable</code> immediately disposes it.</p>
</div>
<div class="paragraph">
<p>另一个有趣的实用程序是Disposables.composite(…​)。通过此组合，您可以收集多个Disposable （例如，与服务调用关联的多个进行中的请求），并在以后一次处理所有这些请求。
一旦复合方法调用了dispose()，任何添加其他Disposable方法的尝试都会立即丢弃掉。</p>
</div>
</div>
<div class="sect3">
<h4 id="_an_alternative_to_lambdas_basesubscriber"><a class="anchor" href="#_an_alternative_to_lambdas_basesubscriber"></a>4.3.3. An Alternative to Lambdas: <code>BaseSubscriber</code></h4>
<div class="paragraph">
<p>There is an additional <code>subscribe</code> method that is more generic and takes a full-blown
<code>Subscriber</code> rather than composing one out of lambdas. In order to help with writing
such a <code>Subscriber</code>, we provide an extendable class called <code>BaseSubscriber</code>.</p>
</div>
<div class="paragraph">
<p>还有一种subscribe更通用的方法，它采用成熟的方法， 使用Subscriber而不是用lambda组成一个方法。
为了帮助编写这样的 Subscriber，我们提供了一个称为的可扩展的类叫 BaseSubscriber。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Instances of <code>BaseSubscriber</code> (or subclasses of it) are <strong>single-use</strong>,
meaning that a <code>BaseSubscriber</code> cancels its subscription to the first <code>Publisher</code> if it
is subscribed to a second <code>Publisher</code>.
That is because using an instance twice would violate the Reactive Streams rule that a
the <code>onNext</code> method of a <code>Subscriber</code> must not be called in parallel.
As a result, anonymous implementations are fine only if they are declared directly within
the call to <code>Publisher#subscribe(Subscriber)</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
BaseSubscriber（或它的子类）的 实例是一次性的，这意味着如果一个 BaseSubscriber 对第二个 Publisher 就行订阅，则它会取消其对第一个的Publisher的订阅。
那是因为两次使用一个实例会违反反应式流规则，即不能并行调用Subscriber的onNext方法。
因此，只有在对的调用中直接声明了匿名实现时，匿名实现才可以Publisher#subscribe(Subscriber)。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can implement one of these. We call it a <code>SampleSubscriber</code>. The following
example shows how it would be attached to a <code>Flux</code>:</p>
</div>
<div class="paragraph">
<p>现在我们可以实现其中之一。我们称它为SampleSubscriber。以下示例显示了如何将其附加到Flux：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SampleSubscriber&lt;Integer&gt; ss = new SampleSubscriber&lt;Integer&gt;();
Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; {System.out.println("Done");},
    s -&gt; s.request(10));
ints.subscribe(ss);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows what <code>SampleSubscriber</code> could look like, as a minimalistic
implementation of a <code>BaseSubscriber</code>:</p>
</div>
<div class="paragraph">
<p>以下示例显示了SampleSubscriber作为一个BaseSubscriber的简约实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package io.projectreactor.samples;

import org.reactivestreams.Subscription;

import reactor.core.publisher.BaseSubscriber;

public class SampleSubscriber&lt;T&gt; extends BaseSubscriber&lt;T&gt; {

	public void hookOnSubscribe(Subscription subscription) {
		System.out.println("Subscribed");
		request(1);
	}

	public void hookOnNext(T value) {
		System.out.println(value);
		request(1);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>SampleSubscriber</code> class extends <code>BaseSubscriber</code>, which is the recommended abstract
class for user-defined <code>Subscribers</code> in Reactor. The class offers hooks that can be
overridden to tune the subscriber&#8217;s behavior. By default, it triggers an unbounded
request and behaves exactly as <code>subscribe()</code>. However, extending <code>BaseSubscriber</code> is
much more useful when you want a custom request amount.</p>
</div>
<div class="paragraph">
<p>这SampleSubscriber类是扩展BaseSubscriber，在Reactor中，推荐使用Subscribers的抽象类SampleSubscriber，去实现自定义功能。
该类提供了可以被覆盖的hook，以调整订阅者的行为。默认情况下，它会触发一个无限制的请求，并且行为与完全相同subscribe()。
但是，当您需要自定义请求量时，BaseSubscriber的扩展功能会更加有用。</p>
</div>
<div class="paragraph">
<p>For a custom request amount, the bare minimum is to implement <code>hookOnSubscribe(Subscription subscription)</code>
and <code>hookOnNext(T value)</code>, as we did. In our case, the <code>hookOnSubscribe</code> method
prints a statement to standard out and makes the first request. Then the <code>hookOnNext</code>
method prints a statement and performs additional requests, one request
at a time.</p>
</div>
<div class="paragraph">
<p>对于自定义请求量，最起码的是实施hookOnSubscribe(Subscription subscription) 和hookOnNext(T value)，就像我们所做的那样。
在我们的例子中，该hookOnSubscribe方法输出标准声明并发出第一个请求。然后，该hookOnNext 方法打印一条语句并执行其他请求，一次执行一个请求。</p>
</div>
<div class="paragraph">
<p>The <code>SampleSubscriber</code> class produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Subscribed
1
2
3
4</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>BaseSubscriber</code> also offers a <code>requestUnbounded()</code> method to switch to unbounded mode
(equivalent to <code>request(Long.MAX_VALUE)</code>), as well as a <code>cancel()</code> method.</p>
</div>
<div class="paragraph">
<p>BaseSubscriber还提供了requestUnbounded()一种切换到无界模式的方法（等效于request(Long.MAX_VALUE)），以及一种cancel()方法。</p>
</div>
<div class="paragraph">
<p>It also has additional hooks: <code>hookOnComplete</code>, <code>hookOnError</code>, <code>hookOnCancel</code>, and <code>hookFinally</code>
(which is always called when the sequence terminates, with the type of termination passed
in as a <code>SignalType</code> parameter)</p>
</div>
<div class="paragraph">
<p>它还具有另外的钩：hookOnComplete，hookOnError，hookOnCancel，和hookFinally （其总是在序列终止时调用，并在序列通过后，传入类型为SignalType的参数）</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You almost certainly want to implement the <code>hookOnError</code>, <code>hookOnCancel</code>, and
<code>hookOnComplete</code> methods. You may also want to implement the <code>hookFinally</code> method.
<code>SampleSubscribe</code> is the absolute minimum implementation of a <code>Subscriber</code> <em>that performs
bounded requests</em>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你几乎可以肯定要实现的hookOnError，hookOnCancel和 hookOnComplete方法。
您可能还想实现该hookFinally方法。 SampleSubscribe是Subscriber 执行受限请求的的绝对最小的实现。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_on_backpressure_and_ways_to_reshape_requests"><a class="anchor" href="#_on_backpressure_and_ways_to_reshape_requests"></a>4.3.4. On Backpressure and Ways to Reshape Requests</h4>
<div class="paragraph">
<p>When implementing backpressure in Reactor, the way consumer pressure is propagated back to the source is by sending a <code>request</code> to the upstream operator.
The sum of current requests is sometimes referenced to as the current &#8220;demand&#8221;, or &#8220;pending request&#8221;.
Demand is capped at <code>Long.MAX_VALUE</code>, representing an unbounded request (meaning &#8220;produce as fast as you can&#8221;&#8201;&#8212;&#8201;basically disabling backpressure).</p>
</div>
<div class="paragraph">
<p>在Reactor中实施背压时，通过将压力发送request给上游操作员，将用户压力传播回源。
当前请求的总和有时被称为当前“需求”或“待处理请求”。
需求上限为Long.MAX_VALUE，表示无限制的请求（意思是“尽可能快地生成”，基本上是禁止背压）。</p>
</div>
<div class="paragraph">
<p>The first request comes from the final subscriber at subscription time,
yet the most direct ways of subscribing all immediately trigger an unbounded request of <code>Long.MAX_VALUE</code>:</p>
</div>
<div class="paragraph">
<p>第一个请求在订阅时来自最终订户，但是最直接的订阅方式立即触发了以下无限请求Long.MAX_VALUE：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subscribe()</code> and most of its lambda-based variants (to the exception of the one that has a Consumer&lt;Subscription&gt;)</p>
</li>
<li>
<p><code>block()</code>, <code>blockFirst()</code> and <code>blockLast()</code></p>
</li>
<li>
<p>iterating over a <code>toIterable()</code> or <code>toStream()</code></p>
</li>
<li>
<p>subscribe() 及其大多数基于lambda的变体（具有Consumer &lt;Subscription&gt;的变体除外）</p>
</li>
<li>
<p>block()，blockFirst()和blockLast()</p>
</li>
<li>
<p>遍历在一个toIterable()或toStream()</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The simplest way of customizing the original request is to <code>subscribe</code> with a <code>BaseSubscriber</code> with the <code>hookOnSubscribe</code> method overridden, as the following example shows:</p>
</div>
<div class="paragraph">
<p>定制原始请求的最简单方法是subscribe使用BaseSubscriber，其中hookOnSubscribe方法被重写，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.range(1, 10)
    .doOnRequest(r -&gt; System.out.println("request of " + r))
    .subscribe(new BaseSubscriber&lt;Integer&gt;() {

      @Override
      public void hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      public void hookOnNext(Integer integer) {
        System.out.println("Cancelling after having received " + integer);
        cancel();
      }
    });</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding snippet prints out the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>request of 1
Cancelling after having received 1</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When manipulating a request, you must be careful to produce enough demand for
the sequence to advance, or your Flux can get &#8220;stuck&#8221;. That is why <code>BaseSubscriber</code>
defaults to an unbounded request in <code>hookOnSubscribe</code>. When overriding this hook, you should usually
call <code>request</code> at least once.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
在处理请求时，您必须小心以产生足够的需求来推进序列，否则您的Flux可能会“卡住”。
这就是为什么BaseSubscriber中的hookOnSubscribe 默认为无限制请求。覆盖此钩子时，通常应request至少调用一次。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_operators_that_change_the_demand_from_downstream"><a class="anchor" href="#_operators_that_change_the_demand_from_downstream"></a>Operators that Change the Demand from Downstream</h5>
<div class="paragraph">
<p>One thing to keep in mind is that demand expressed at the subscribe level <strong>can</strong> be reshaped by each operator in the upstream chain.
A textbook case is the <code>buffer(N)</code> operator: If it receives a <code>request(2)</code>, it is interpreted as a demand for <strong>two full buffers</strong>.
As a consequence, since buffers need <code>N</code> elements to be considered full, the <code>buffer</code> operator reshapes the request to <code>2 x N</code>.</p>
</div>
<div class="paragraph">
<p>要记住的一件事是，上游链中的每个operator都可以调整在订阅级别表达的需求。
教科书的情况是buffer(N)运算符：如果它收到 request(2)，则解释为对两个完整缓冲区的需求。
结果，由于缓冲区需要将N元素视为已满，因此buffer运算符将请求调整为2 x N。</p>
</div>
<div class="paragraph">
<p>You might also have noticed that some operators have variants that take an <code>int</code> input parameter called <code>prefetch</code>.
This is another category of operators that modify the downstream request.
These are usually operators that deal with inner sequences, deriving a <code>Publisher</code> from each incoming element (like <code>flatMap</code>).</p>
</div>
<div class="paragraph">
<p>您可能还已经注意到，某些运算符的变体采用了int称为的输入参数prefetch。这是修改下游请求的另一类运算符。
这些通常是处理内部序列的运算符，它们Publisher从每个传入元素（如flatMap）派生一个。</p>
</div>
<div class="paragraph">
<p><strong>Prefetch</strong> is a way to tune the initial request made on these inner sequences.
If unspecified, most of these operators start with a demand of <code>32</code>.</p>
</div>
<div class="paragraph">
<p>Prefetch是一种调整对这些内部序列发出的初始请求的方法。如果未指定，则大多数这些运算符的起始要求为32。</p>
</div>
<div class="paragraph">
<p>These operators usually also implement a <strong>replenishing optimization</strong>: Once the operator has seen 75% of the prefetch request fulfilled, it re-requests 75% from upstream.
This is a heuristic optimization made so that these operators proactively anticipate the upcoming requests.</p>
</div>
<div class="paragraph">
<p>这些操作员通常还会实现补充优化：一旦操作员看到预取请求的75％已完成，它就会从上游重新请求75％。
进行启发式优化，以便这些操作员主动预测即将到来的请求。</p>
</div>
<div class="paragraph">
<p>Finally, a couple of operators let you directly tune the request: <code>limitRate</code> and <code>limitRequest</code>.</p>
</div>
<div class="paragraph">
<p>最后，几个运算符可让您直接调整请求：limitRate和limitRequest。</p>
</div>
<div class="paragraph">
<p><code>limitRate(N)</code> splits the downstream requests so that they are propagated upstream in smaller batches.
For instance, a request of <code>100</code> made to <code>limitRate(10)</code> would result in, at most, <code>10</code> requests of <code>10</code> being propagated to the upstream.
Note that, in this form, <code>limitRate</code> actually implements the replenishing optimization discussed earlier.</p>
</div>
<div class="paragraph">
<p>limitRate(N)拆分下游请求，以便将它们以较小的批次传播到上游。例如，一个请求100到由limitRate(10)将导致，顶多10的请求10传播到上游。
注意，以这种形式，limitRate实际上实现了前面讨论的补充优化。</p>
</div>
<div class="paragraph">
<p>The operator has a variant that also lets you tune the replenishing amount (referred to as the <code>lowTide</code> in the variant): <code>limitRate(highTide, lowTide)</code>.
Choosing a <code>lowTide</code> of <code>0</code> results in <strong>strict</strong> batches of <code>highTide</code> requests, instead of batches further reworked by the replenishing strategy.</p>
</div>
<div class="paragraph">
<p>经营者有一个变种，也可以让你调整补充量（简称lowTide中变体）： limitRate(highTide, lowTide)。
选择一个 lowTide 参数0 会导致严格的批次highTide请求，而不是通过补充策略进一步重做的批次。</p>
</div>
<div class="paragraph">
<p><code>limitRequest(N)</code>, on the other hand, <strong>caps</strong> the downstream request to a maximum total demand.
It adds up requests up to <code>N</code>. If a single <code>request</code> does not make the total demand overflow over <code>N</code>, that particular request is wholly propagated upstream.
After that amount has been emitted by the source, <code>limitRequest</code> considers the sequence complete, sends an <code>onComplete</code> signal downstream, and cancels the source.</p>
</div>
<div class="paragraph">
<p>limitRequest(N)，另一方面，限额了下游请求的最大总需求。它将请求总计为N。如果单个请求request没有使总需求超出N，则该特定请求将完全向上游传播。
在源头发出该数量的信号后，limitRequest认为序列已完成，向下游发送onComplete信号，然后取消源。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="producing"><a class="anchor" href="#producing"></a>4.4. Programmatically creating a sequence</h3>
<div class="paragraph">
<p>In this section, we introduce the creation of a <code>Flux</code> or a <code>Mono</code> by
programmatically defining its associated events (<code>onNext</code>, <code>onError</code>, and
<code>onComplete</code>). All these methods share the fact that they expose an API to
trigger the events that we call a <strong>sink</strong>. There are actually a few sink
variants, which we&#8217;ll get to shortly.</p>
</div>
<div class="paragraph">
<p>在本节中，我们介绍的创建Flux或Mono通过编程方式定义及其相关事件（onNext，onError，和 onComplete）。
所有这些方法都满足相同的设计：它们公开一个API来触发我们称为接收器的事件。实际上有一些接收器变体，稍后我们将介绍。</p>
</div>
<div class="sect3">
<h4 id="producing.generate"><a class="anchor" href="#producing.generate"></a>4.4.1. Synchronous <code>generate</code></h4>
<div class="paragraph">
<p>The simplest form of programmatic creation of a <code>Flux</code> is through the <code>generate</code>
method, which takes a generator function.</p>
</div>
<div class="paragraph">
<p>以编程方式创建“ Flux”的最简单形式是通过“ generate”方法，通过使用生成器功能。</p>
</div>
<div class="paragraph">
<p>This is for <strong>synchronous</strong> and <strong>one-by-one</strong> emissions, meaning that
the sink is a <code>SynchronousSink</code> and that its <code>next()</code> method can only be called
at most once per callback invocation. You can then additionally call <code>error(Throwable)</code>
or <code>complete()</code>, but this is optional.</p>
</div>
<div class="paragraph">
<p>这用于*同步发射*和*一对一*发射，这意味着接收器为 SynchronousSink，并且其next()方法最多只能在每次回调调用时调用一次。
然后，您可以另外调用error(Throwable) 或complete()，但这是可选的。</p>
</div>
<div class="paragraph">
<p>The most useful variant is probably the one that also lets you keep a state
that you can refer to in your sink usage to decide what to emit next. The generator
function then becomes a <code>BiFunction&lt;S, SynchronousSink&lt;T&gt;, S&gt;</code>, with <code>&lt;S&gt;</code> the
type of the state object. You have to provide a <code>Supplier&lt;S&gt;</code> for the initial
state, and your generator function now returns a new state on each round.</p>
</div>
<div class="paragraph">
<p>最有用的变体可能是一种变体，它还可以让您保持在接收器使用中可以参考的状态，以决定接下来要发射什么。
然后，生成器函数变为BiFunction&lt;S, SynchronousSink&lt;T&gt;, S&gt;带有&lt;S&gt;状态对象类型的。
您必须Supplier&lt;S&gt;为初始状态提供一个，并且生成器函数现在在每个回合中都返回一个新状态。</p>
</div>
<div class="paragraph">
<p>For instance, you could use an <code>int</code> as the state:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Example of state-based <code>generate</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    () -&gt; 0, <i class="conum" data-value="1"></i><b>(1)</b>
    (state, sink) -&gt; {
      sink.next("3 x " + state + " = " + 3*state); <i class="conum" data-value="2"></i><b>(2)</b>
      if (state == 10) sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
      return state + 1; <i class="conum" data-value="4"></i><b>(4)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们提供初始状态值0</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们使用状态来选择要发出的信号（乘法表3中的一行）.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们还使用它来选择何时停止</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们返回在下一个调用中使用的新状态（除非序列在此调用中终止).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code generates the table of 3, as the following sequence:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>3 x 0 = 0
3 x 1 = 3
3 x 2 = 6
3 x 3 = 9
3 x 4 = 12
3 x 5 = 15
3 x 6 = 18
3 x 7 = 21
3 x 8 = 24
3 x 9 = 27
3 x 10 = 30</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use a mutable <code>&lt;S&gt;</code>. The example above could for instance be
rewritten using a single <code>AtomicLong</code> as the state, mutating it on each round:</p>
</div>
<div class="paragraph">
<p>您也可以使用可变的&lt;S&gt;。例如，上面的示例可以使用一个AtomicLong状态作为重写状态，在每个回合中对其进行更改</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. Mutable state variant</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::new, <i class="conum" data-value="1"></i><b>(1)</b>
    (state, sink) -&gt; {
      long i = state.getAndIncrement(); <i class="conum" data-value="2"></i><b>(2)</b>
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state; <i class="conum" data-value="3"></i><b>(3)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这次，我们生成一个可变对象作为状态.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们在这里改变状态.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们返回与新状态相同的实例.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If your state object needs to clean up some resources, use the
<code>generate(Supplier&lt;S&gt;, BiFunction, Consumer&lt;S&gt;)</code> variant to clean up the last
state instance.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果您的状态对象需要清理一些资源，请使用 generate(Supplier&lt;S&gt;, BiFunction, Consumer&lt;S&gt;)变体来清理最后一个状态实例
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example uses the <code>generate</code> method that includes a <code>Consumer</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::new,
      (state, sink) -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
      long i = state.getAndIncrement(); <i class="conum" data-value="2"></i><b>(2)</b>
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state; <i class="conum" data-value="3"></i><b>(3)</b>
    }, (state) -&gt; System.out.println("state: " + state)); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>同样，我们生成一个可变对象作为状态.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们在这里改变状态.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们返回与新状态相同的实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们将最后一个状态值（11）视为此Consumerlambda 的输出.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>In the case of the state containing a database connection or other resource
that needs to be handled at the end of the process, the <code>Consumer</code> lambda could
close the connection or  otherwise handle any tasks that should be done at the
end of the process.</p>
</div>
<div class="paragraph">
<p>如果状态包含在过程结束时需要处理的数据库连接或其他资源，则Consumer lambda可以关闭连接或以其他方式处理应在过程结束时完成的任何任务</p>
</div>
</div>
<div class="sect3">
<h4 id="producing.create"><a class="anchor" href="#producing.create"></a>4.4.2. Asynchronous and Multi-threaded: <code>create</code></h4>
<div class="paragraph">
<p><code>create</code> is a more advanced form of programmatic creation of a <code>Flux</code> which is
suitable for multiple emissions per round, even from multiple threads.</p>
</div>
<div class="paragraph">
<p>create是Flux内的一种更高级的程序化创建形式，适用于每轮多次排放，甚至来自多个线程。</p>
</div>
<div class="paragraph">
<p>It exposes a <code>FluxSink</code>, with its <code>next</code>, <code>error</code>, and <code>complete</code> methods.
Contrary to <code>generate</code>, it doesn&#8217;t have a state-based variant. On the other
hand, it can trigger multi-threaded events in the callback.</p>
</div>
<div class="paragraph">
<p>它暴露了FluxSink，与它的next，error和complete方法。与此相反generate，它没有基于状态的变体。另一方面，它可以触发回调中的多线程事件。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>create</code> can be very useful to bridge an existing API with the reactive
world - such as an asynchronous API based on listeners.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
create 将现有的API与响应世界联系起来非常有用-例如基于侦听器的异步API。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>create</code> <strong>doesn&#8217;t parallelize your code nor does it make it asynchronous</strong>, even
though it <em>can</em> be used with asynchronous APIs. If you block within the <code>create</code> lambda,
you expose yourself to deadlocks and similar side effects. Even with the use of <code>subscribeOn</code>,
there&#8217;s the caveat that a long-blocking <code>create</code> lambda (such as an infinite loop calling
<code>sink.next(t)</code>) can lock the pipeline: the requests would never be performed due to the
loop starving the same thread they are supposed to run from. Use the <code>subscribeOn(Scheduler, false)</code>
variant: <code>requestOnSeparateThread = false</code> will use the <code>Scheduler</code> thread for the <code>create</code>
and still let data flow by performing <code>request</code> in the original thread.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
create 即使它可以与异步API一起使用，也不会并行化您的代码，也不会使其异步。
如果您在createlambda中阻塞，则会使自己陷入僵局和类似的副作用。
即使使用subscribeOn，也有一个警告，即长阻塞的create lambda（例如无限循环调用 sink.next(t)）可以锁定管道：由于循环会饿死它们应该从中运行的相同线程，因此将永远不会执行请求。
使用subscribeOn(Scheduler, false) 变体：requestOnSeparateThread = false将Scheduler线程用于，create 并仍然通过request在原始线程中执行来让数据流动。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Imagine that you use a listener-based API. It processes data by chunks
and has two events: (1) a chunk of data is ready and (2) the processing is
complete (terminal event), as represented in the <code>MyEventListener</code> interface:</p>
</div>
<div class="paragraph">
<p>假设您使用基于侦听器的API。
它按块处理数据并有两个事件：（1）数据块已准备就绪，并且（2）处理完成（终端事件），如MyEventListener接口所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface MyEventListener&lt;T&gt; {
    void onDataChunk(List&lt;T&gt; chunk);
    void processComplete();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can use <code>create</code> to bridge this into a <code>Flux&lt;T&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myEventProcessor.register( <i class="conum" data-value="4"></i><b>(4)</b>
      new MyEventListener&lt;String&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
          }
        }

        public void processComplete() {
            sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>桥接到MyEventListenerAPI</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>块中的每个元素都成为中的一个元素Flux.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>该processComplete事件已翻译为onComplete.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>每当myEventProcessor执行时，所有这些操作都是异步完成的.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Additionally, since <code>create</code> can bridge asynchronous APIs and manages backpressure, you
can refine how to behave backpressure-wise, by indicating an <code>OverflowStrategy</code>:</p>
</div>
<div class="paragraph">
<p>此外，由于create可以桥接异步API并管理背压，因此您可以通过指示以下内容来优化如何进行背压行为OverflowStrategy：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IGNORE</code> to Completely ignore downstream backpressure requests.
This may yield <code>IllegalStateException</code> when queues get full downstream.</p>
</li>
<li>
<p><code>ERROR</code> to signal an <code>IllegalStateException</code> when the downstream can&#8217;t keep
up.</p>
</li>
<li>
<p><code>DROP</code> to drop the incoming signal if the downstream is not ready to receive
it.</p>
</li>
<li>
<p><code>LATEST</code> to let downstream only get the latest signals from upstream.</p>
</li>
<li>
<p><code>BUFFER</code> (the default) to buffer all signals if the downstream can&#8217;t keep up.
(this does unbounded buffering and may lead to <code>OutOfMemoryError</code>).</p>
</li>
<li>
<p>IGNORE完全忽略下游背压请求。IllegalStateException当队列下游充满时，可能会产生这种情况.</p>
</li>
<li>
<p>ERROR 去发送一个 IllegalStateException信号，当下游无法跟上时发出信号.</p>
</li>
<li>
<p>DROP 如果下游尚未准备好接收信号，则丢弃该信号.</p>
</li>
<li>
<p>LATEST 让下游只从上游获取最新信号.</p>
</li>
<li>
<p>BUFFER（默认设置）以在下游无法跟上时缓冲所有信号。（这会实现无限缓冲，并可能导致OutOfMemoryError).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Mono</code> also has a <code>create</code> generator. The <code>MonoSink</code> of Mono&#8217;s create
doesn&#8217;t allow several emissions. It will drop all signals after the first one.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Mono也有一个create创造器。在MonoSink的创造方法中不允许几个发射。它将在第一个信号之后丢弃所有信号
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_asynchronous_but_single_threaded_push"><a class="anchor" href="#_asynchronous_but_single_threaded_push"></a>4.4.3. Asynchronous but single-threaded: <code>push</code></h4>
<div class="paragraph">
<p><code>push</code> is a middle ground between <code>generate</code> and <code>create</code> which is suitable for
processing events from a single producer. It is similar to <code>create</code> in the sense
that it can also be asynchronous and can manage backpressure using any of the
overflow strategies supported by <code>create</code>. However, <strong>only one producing thread</strong>
may invoke <code>next</code>, <code>complete</code> or <code>error</code> at a time.</p>
</div>
<div class="paragraph">
<p>push是之间的中间接地generate并且create其适用于从一个生产者处理事件。从create某种意义上讲，它类似于，它也可以是异步的，并且可以使用所支持的任何溢出策略来管理背压create。
但是，只有一个线程生产 可以调用next，complete或error在同一时间。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; bridge = Flux.push(sink -&gt; {
    myEventProcessor.register(
      new SingleThreadEventListener&lt;String&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
          }
        }

        public void processComplete() {
            sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
        }

        public void processError(Throwable e) {
            sink.error(e); <i class="conum" data-value="4"></i><b>(4)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>桥接到SingleThreadEventListener API.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用next单个侦听器线程将事件推送到接收器.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>complete 从同一侦听器线程生成的事件.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>error 事件也从同一侦听器线程生成.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_a_hybrid_pushpull_model"><a class="anchor" href="#_a_hybrid_pushpull_model"></a>A hybrid push/pull model</h5>
<div class="paragraph">
<p>Most Reactor operators, like <code>create</code>, follow a hybrid <strong>push/pull</strong> model.
What we mean by that is that despite most of the processing being asynchronous
(suggesting a <em>push</em> approach), there is a small <em>pull</em> component to it: the
request.</p>
</div>
<div class="paragraph">
<p>像的大多数Reactor运算符都create遵循混合 推/拉模型。
我们的意思是，尽管大多数处理都是异步的（建议采用推送方法），但其中有一个很小的拉组件：请求。</p>
</div>
<div class="paragraph">
<p>The consumer <em>pulls</em> data from the source in the sense that it won&#8217;t emit anything
until first requested. The source <em>pushes</em> data to the consumer whenever it
becomes available, but within the bounds of its requested amount.</p>
</div>
<div class="paragraph">
<p>消费者从源中提取数据，这意味着直到第一次请求它才发出任何东西。
只要有可用，源就会将数据推送到使用者，但要在其请求数量的范围内</p>
</div>
<div class="paragraph">
<p>Note that <code>push()</code> and <code>create()</code> both allow to set up an <code>onRequest</code> consumer
in order to manage the request amount and to ensure that data is pushed through
the sink only when there is pending request.</p>
</div>
<div class="paragraph">
<p>请注意，push()并且create()两者都允许设置onRequest使用者以管理请求量，并确保仅在有待处理的请求时才通过接收器推送数据</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myMessageProcessor.register(
      new MyMessageListener&lt;String&gt;() {

        public void onMessage(List&lt;String&gt; messages) {
          for(String s : messages) {
            sink.next(s); <i class="conum" data-value="3"></i><b>(3)</b>
          }
        }
    });
    sink.onRequest(n -&gt; {
        List&lt;String&gt; messages = myMessageProcessor.getHistory(n); <i class="conum" data-value="1"></i><b>(1)</b>
        for(String s : message) {
           sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>发出请求时轮询消息.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果消息立即可用，请将其推入接收器.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>其余的消息也将在稍后被异步传递到达.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_cleaning_up_after_push_or_create"><a class="anchor" href="#_cleaning_up_after_push_or_create"></a>Cleaning up after <code>push()</code> or <code>create()</code></h5>
<div class="paragraph">
<p>Two callbacks, <code>onDispose</code> and <code>onCancel</code>, perform any cleanup on cancellation
or termination. <code>onDispose</code> can be used to perform cleanup when the <code>Flux</code>
completes, errors out, or is cancelled. <code>onCancel</code> can be used to perform any
action specific to cancellation prior to cleanup with <code>onDispose</code>.</p>
</div>
<div class="paragraph">
<p>两个回调onDispose和onCancel在取消时执行任何清理或终止。 当`Flux` 完成，出错或者被取消时，`onDispose`可用于执行清理。
`onCancel`可用于执行任何在使用onDispose进行清理之前，特定于取消的操作。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    sink.onRequest(n -&gt; channel.poll(n))
        .onCancel(() -&gt; channel.cancel()) <i class="conum" data-value="1"></i><b>(1)</b>
        .onDispose(() -&gt; channel.close())  <i class="conum" data-value="2"></i><b>(2)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>onCancel 首先调用，仅用于取消信号.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>onDispose 调用为完成，错误或取消信号而调用.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handle"><a class="anchor" href="#_handle"></a>4.4.4. Handle</h4>
<div class="paragraph">
<p>The <code>handle</code> method is a bit different: it is an instance method, meaning that
it is chained on an existing source (as are the common operators). It is present
in both <code>Mono</code> and <code>Flux</code>.</p>
</div>
<div class="paragraph">
<p>handle方法有点不同：它是一个实例方法，这意味着它被链接在一个现有的源上（常见的运算符也是如此）。它存在于Mono和中Flux。</p>
</div>
<div class="paragraph">
<p>It is close to <code>generate</code>, in the sense that it uses a <code>SynchronousSink</code> and
only allows one-by-one emissions. However, <code>handle</code> can be used to generate an
arbitrary value out of each source element, possibly skipping some elements. In
this way, it can serve as a combination of <code>map</code> and <code>filter</code>. The signature of
handle is as follows:</p>
</div>
<div class="paragraph">
<p>它接近generate，从某种意义上说，它使用 SynchronousSink 且仅允许一对一的发射。
但是，handle可用于从每个源元素中生成任意值，可能会跳过某些元素。通过这种方式，它可以作为map和filter组合一样使用。
handle的签名如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;R&gt; handle(BiConsumer&lt;T, SynchronousSink&lt;R&gt;&gt;);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s consider an example. The reactive streams specification disallows <code>null</code>
values in a sequence. What if you want to perform a <code>map</code> but you want to use
a preexisting method as the map function, and that method sometimes returns null?</p>
</div>
<div class="paragraph">
<p>让我们考虑一个例子。反应性流规范不允许null值在序列中。如果要执行一个 map方法，但想使用一个预先存在的方法作为map函数，而该方法有时返回null怎么办？</p>
</div>
<div class="paragraph">
<p>For instance, the following method can be applied safely to a source of
integers:</p>
</div>
<div class="paragraph">
<p>例如，以下方法可以安全地应用于整数源：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public String alphabet(int letterNumber) {
	if (letterNumber &lt; 1 || letterNumber &gt; 26) {
		return null;
	}
	int letterIndexAscii = 'A' + letterNumber - 1;
	return "" + (char) letterIndexAscii;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We can then use <code>handle</code> to remove any nulls:</p>
</div>
<div class="paragraph">
<p>然后，我们可以使用handle删除任何空值：</p>
</div>
<div class="paragraph">
<div class="title">Using <code>handle</code> for a "map and eliminate nulls" scenario</div>
<p>handle用于“映射并消除空值”场景</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; alphabet = Flux.just(-1, 30, 13, 9, 20)
    .handle((i, sink) -&gt; {
        String letter = alphabet(i); <i class="conum" data-value="1"></i><b>(1)</b>
        if (letter != null) <i class="conum" data-value="2"></i><b>(2)</b>
            sink.next(letter); <i class="conum" data-value="3"></i><b>(3)</b>
    });

alphabet.subscribe(System.out::println);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>映射到字母.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果“ map function”返回null</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>通过不调用过滤掉它sink.next.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Which will print out:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>M
I
T</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="schedulers"><a class="anchor" href="#schedulers"></a>4.5. Threading and Schedulers</h3>
<div class="paragraph">
<p>Reactor, like RxJava, can be considered to be <strong>concurrency-agnostic</strong>. That is, it does not
enforce a concurrency model. Rather, it leaves you, the developer, in command. However,
that does not prevent the library from helping you with concurrency.</p>
</div>
<div class="paragraph">
<p>像RxJava一样，Reactor可以被视为与并发无关的。
也就是说，它不强制执行并发模型。相反，它使您（开发人员）处于命令状态。但是，这不会阻止你使用并发库。</p>
</div>
<div class="paragraph">
<p>Obtaining a <code>Flux</code> or a <code>Mono</code> does not necessarily mean that it runs in a dedicated
<code>Thread</code>. Instead, most operators continue working in the <code>Thread</code> on which the
previous operator executed. Unless specified, the topmost operator (the source)
itself runs on the <code>Thread</code> in which the <code>subscribe()</code> call was made. The following
example runs a <code>Mono</code> in a new thread:</p>
</div>
<div class="paragraph">
<p>获得 Flux或 Mono不一定意味着它运行在专用的Thread 中。取而代之的是，大多数运算符Thread将在先前的运算符执行时继续工作。
除非另有说明，最上面的操作（源）本身上运行，Thread其在subscribe()有人呼吁。以下示例Mono在新线程中运行：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static void main(String[] args) throws InterruptedException {
  final Mono&lt;String&gt; mono = Mono.just("hello "); <i class="conum" data-value="1"></i><b>(1)</b>

  Thread t = new Thread(() -&gt; mono
      .map(msg -&gt; msg + "thread ")
      .subscribe(v -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
          System.out.println(v + Thread.currentThread().getName()) <i class="conum" data-value="3"></i><b>(3)</b>
      )
  )
  t.start();
  t.join();

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>该Mono&lt;String&gt;组装在线程main.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>但是，它是在thread中订阅的Thread-0.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>因此，map和onNext回调实际上都在Thread-0</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>hello thread Thread-0</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In Reactor, the execution model and where the execution happens is determined by the
<code>Scheduler</code> that is used. A
<a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html"><code>Scheduler</code></a>
has scheduling responsibilities similar to an <code>ExecutorService</code>, but having a
dedicated abstraction lets it do more, notably acting as a clock and enabling
a wider range of implementations (virtual time for tests, trampolining or
immediate scheduling, and so on).</p>
</div>
<div class="paragraph">
<p>在Reactor中，执行模型以及执行的位置由所Scheduler使用所确定的 。
Scheduler 具有与ExecutorService相似的调度职责，但是具有专用的抽象使其可以做更多的事情，
尤其是充当时钟并支持更广泛的实现（测试的虚拟时间，蹦床或即时调度等）。</p>
</div>
<div class="paragraph">
<p>The <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html"><code>Schedulers</code></a>
class has static methods that give access to the following execution contexts:
Schedulers 类有给访问以下执行上下文的静态方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No execution context (<code>Schedulers.immediate()</code>): at processing time, the submitted <code>Runnable</code>
will be directly executed, effectively running them on the current <code>Thread</code> (can be seen as a "null object" or no-op <code>Scheduler</code>).</p>
</li>
<li>
<p>A single, reusable thread (<code>Schedulers.single()</code>). Note that this method reuses the
same thread for all callers, until the Scheduler is disposed. If you want a per-call
dedicated thread, use <code>Schedulers.newSingle()</code> for each call.</p>
</li>
<li>
<p>An unbounded elastic thread pool (<code>Schedulers.elastic()</code>). This one is no longer preferred
with the introduction of <code>Schedulers.boundedElastic()</code>, as it has a tendency to hide backpressure
problems and lead to too many threads (see below).</p>
</li>
<li>
<p>A bounded elastic thread pool (<code>Schedulers.boundedElastic()</code>). Like its predecessor <code>elastic()</code>, it
creates new worker pools as needed and reuses idle ones. Worker pools that stay idle for too long (the default is 60s) are
also disposed. Unlike its <code>elastic()</code> predecessor, it has a cap on the number of backing threads it can create (default is number of CPU cores x 10).
Up to 100 000 tasks submitted after the cap has been reached are enqueued and will be re-scheduled when a thread becomes available
(when scheduling with a delay, the delay starts when the thread becomes available). This is a better choice for I/O blocking work.
<code>Schedulers.boundedElastic()</code> is a handy way to give a blocking process its own thread so that
it does not tie up other resources. See <a href="#faq.wrap-blocking">How Do I Wrap a Synchronous, Blocking Call? 如何包装同步阻塞呼叫?</a>, but doesn&#8217;t pressure the system too much with new threads.</p>
</li>
<li>
<p>A fixed pool of workers that is tuned for parallel work (<code>Schedulers.parallel()</code>). It
creates as many workers as you have CPU cores.</p>
</li>
<li>
<p>没有执行上下文（Schedulers.immediate()）：在处理时，提交的文件Runnable 将被直接执行，从而有效地在当前Thread上运行（可以视为“空对象”或no-op Scheduler）。</p>
</li>
<li>
<p>单个可重用线程（Schedulers.single()）。请注意，此方法对所有调用方都使用相同的线程，直到调度程序被释放为止。如果您需要一个每次调用专用线程，请Schedulers.newSingle()为每个调用使用。</p>
</li>
<li>
<p>无限制的弹性线程池（Schedulers.elastic()）。引入时Schedulers.boundedElastic()，不再首选该线程，因为它倾向于隐藏背压问题并导致线程过多（请参见下文）。</p>
</li>
<li>
<p>有界的弹性线程池（Schedulers.boundedElastic()）。像其前身一样elastic()，它根据需要创建新的工作池，并重用空闲的工作池。闲置时间过长（默认值为60s）的工作池也将被丢弃。
与之前的elastic()版本不同，它对可以创建的支持线程数进行了限制（默认值为CPU内核数x 10）。达到上限后，最多可提交10万个任务，并在线程可用时重新调度（当延迟调度时，延迟在线程可用时开始）。
这是I / O阻止工作的更好选择。 Schedulers.boundedElastic()是一种为阻塞进程分配自己的线程的简便方法，这样它就不会占用其他资源。请参阅<a href="#faq.wrap-blocking">How Do I Wrap a Synchronous, Blocking Call? 如何包装同步阻塞呼叫?</a>，但使用新线程不会对系统造成太大压力。</p>
</li>
<li>
<p>已调整为并行工作的固定工作池（Schedulers.parallel()）。它创建的工作线程数量与CPU内核数量一样多。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, you can create a <code>Scheduler</code> out of any pre-existing <code>ExecutorService</code> by
using <code>Schedulers.fromExecutorService(ExecutorService)</code>. (You can also create one from an
<code>Executor</code>, although doing so is discouraged.)</p>
</div>
<div class="paragraph">
<p>此外，您可以创建一个Scheduler不存在ExecutorService的对象使用Schedulers.fromExecutorService(ExecutorService)。
（Executor尽管不建议这样做，也可以从中创建一个 。）</p>
</div>
<div class="paragraph">
<p>You can also create new instances of the various scheduler types by using the <code>newXXX</code>
methods. For example, <code>Schedulers.newParallel(yourScheduleName)</code> creates a new parallel
scheduler named <code>yourScheduleName</code>.</p>
</div>
<div class="paragraph">
<p>您还可以使用这些newXXX 方法来创建各种调度程序类型的新实例。
例如，Schedulers.newParallel(yourScheduleName)创建一个名为 yourScheduleName 的新并行调度程序。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>While <code>boundedElastic</code> is made to help with legacy blocking code if it cannot be avoided,
<code>single</code> and <code>parallel</code> are not. As a consequence, the use of Reactor blocking APIs
(<code>block()</code>, <code>blockFirst()</code>, <code>blockLast()</code> (as well as iterating over <code>toIterable()</code>
or <code>toStream()</code>) inside the default single and parallel schedulers) results in
an <code>IllegalStateException</code> being thrown.</p>
</div>
<div class="paragraph">
<p>Custom <code>Schedulers</code> can also be marked as "non blocking only" by creating instances of <code>Thread</code>
that implement the <code>NonBlocking</code> marker interface.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然boundedElastic是帮助制造与传统的阻塞代码，如果无法避免， single而且parallel都没有。因此，使用反应器阻塞的API（ ，block()，blockFirst()（blockLast()以及遍历toIterable() 或toStream()）的默认单和并行调度器内）导致在IllegalStateException被抛出。</p>
</div>
<div class="paragraph">
<p>Schedulers通过创建Thread 实现NonBlocking标记接口的实例，也可以将Custom 标记为“仅非阻塞” 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some operators use a specific scheduler from <code>Schedulers</code> by default (and usually give
you the option of providing a different one). For instance, calling the
<code>Flux.interval(Duration.ofMillis(300))</code> factory method produces a <code>Flux&lt;Long&gt;</code> that ticks every 300ms.
By default, this is enabled by <code>Schedulers.parallel()</code>. The following line changes the
Scheduler to a new instance similar to <code>Schedulers.single()</code>:</p>
</div>
<div class="paragraph">
<p>某些操作员Schedulers默认情况下使用特定的调度程序（通常会为您提供提供其他调度程序的选项）。
例如，调用 Flux.interval(Duration.ofMillis(300))factory方法会产生一个Flux&lt;Long&gt;每300毫秒滴答一次的滴答声。
默认情况下，通过启用Schedulers.parallel()。以下行将Scheduler更改为类似于Schedulers.single()的新实例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.interval(Duration.ofMillis(300), Schedulers.newSingle("test"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Reactor offers two means of switching the execution context (or <code>Scheduler</code>) in a
reactive chain: <code>publishOn</code> and <code>subscribeOn</code>. Both take a <code>Scheduler</code> and let you switch
the execution context to that scheduler. But the placement of <code>publishOn</code> in the chain
matters, while the placement of <code>subscribeOn</code> does not. To understand that difference,
you first have to remember that <a href="#reactive.subscribe">nothing happens until you
subscribe</a>.</p>
</div>
<div class="paragraph">
<p>Reactor提供了两种在反应式链中切换执行上下文（或 Scheduler）的方式：publishOn和subscribeOn。两者都使用Scheduler，让您将执行上下文切换到该调度程序。
但是publishOn在链中的位置很重要，而在链中的位置subscribeOn并不重要。要了解这种差异，您首先必须记住，<a href="#reactive.subscribe">nothing happens until yousubscribe</a>。</p>
</div>
<div class="paragraph">
<p>In Reactor, when you chain operators, you can wrap as many <code>Flux</code> and <code>Mono</code>
implementations inside one another as you need. Once you subscribe, a chain of
<code>Subscriber</code> objects is created, backward (up the chain) to the first
publisher. This is effectively hidden from you. All you can see is the outer layer of
<code>Flux</code> (or <code>Mono</code>) and <code>Subscription</code>, but these intermediate operator-specific
subscribers are where the real work happens.</p>
</div>
<div class="paragraph">
<p>在Reactor中，当您链接运算符时，可以根据需要将许多 实现Flux和Mono实现彼此包装在一起。
订阅后，一个Subscriber对象链将被创建 ，向后（向上）到第一个发布者。
这实际上对您是隐藏的。您所看到的只是Flux（和Mono）和 Subscription的外层，但是这些中间操作员特定的订户才是真正工作的地方。</p>
</div>
<div class="paragraph">
<p>With that knowledge, we can have a closer look at the <code>publishOn</code> and <code>subscribeOn</code>
operators:</p>
</div>
<div class="paragraph">
<p>有了这些知识，我们可以更详细地了解publishOnand subscribeOn 运算符</p>
</div>
<div class="sect3">
<h4 id="_the_publishon_method"><a class="anchor" href="#_the_publishon_method"></a>4.5.1. The <code>publishOn</code> Method</h4>
<div class="paragraph">
<p><code>publishOn</code> applies in the same way as any other operator, in the middle of the
subscriber chain. It takes signals from upstream and replays them downstream while
executing the callback on a worker from the associated <code>Scheduler</code>. Consequently, it
<strong>affects where the subsequent operators execute</strong> (until another <code>publishOn</code> is
chained in), as follows:</p>
</div>
<div class="paragraph">
<p>publishOn在订户链的中间以与任何其他运营商相同的方式应用。它从上游获取信号并在下游重播它们，同时在关联的上对worker执行回调Scheduler。
因此，它 会影响后续运算符的执行位置（直到publishOn链接另一个运算符），如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Changes the execution context to one <code>Thread</code> picked by the <code>Scheduler</code></p>
</li>
<li>
<p>as per the specification, <code>onNext</code> calls happen in sequence, so this uses up a single thread</p>
</li>
<li>
<p>unless they work on a specific <code>Scheduler</code>, operators after <code>publishOn</code> continue execution on that same thread</p>
</li>
<li>
<p>将执行上下文更改Thread为由Scheduler</p>
</li>
<li>
<p>根据规范，onNext调用是按顺序发生的，因此这会占用一个线程</p>
</li>
<li>
<p>除非他们在特定的Scheduler，执行publishOn后在同一线程上工作</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example uses the <code>publishOn</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); <i class="conum" data-value="1"></i><b>(1)</b>

final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    .map(i -&gt; 10 + i)  <i class="conum" data-value="2"></i><b>(2)</b>
    .publishOn(s)  <i class="conum" data-value="3"></i><b>(3)</b>
    .map(i -&gt; "value " + i);  <i class="conum" data-value="4"></i><b>(4)</b>

new Thread(() -&gt; flux.subscribe(System.out::println));  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建一个Scheduler由四个Thread实例支持的新对象。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个map在&lt;5&gt;中的匿名线程上运行。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>publishOn 切换整个序列到在 Thread&lt;1&gt;中。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>第二个map在Thread&lt;1&gt; 上运行.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>这匿名Thread是进行订阅的地方。打印发生在最新的执行上下文中，是从publishOn创建出来的</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_subscribeon_method"><a class="anchor" href="#_the_subscribeon_method"></a>4.5.2. The <code>subscribeOn</code> Method</h4>
<div class="paragraph">
<p><code>subscribeOn</code> applies to the subscription process, when that backward chain is
constructed. As a consequence, no matter where you place the <code>subscribeOn</code> in the chain,
<strong>it always affects the context of the source emission</strong>. However, this does not affect the
behavior of subsequent calls to <code>publishOn</code>&#8201;&#8212;&#8201;they still switch the execution context for
the part of the chain after them.</p>
</div>
<div class="paragraph">
<p>subscribeOn当构造了反向链时，适用于订阅过程。因此，无论将其放置subscribeOn在链中的什么位置， 它始终会影响源发射的环境。
但是，这不会影响后续调用的行为，publishOn 它们仍会在其后的部分链中切换执行上下文。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从全链的订阅中更改Thread</p>
</li>
<li>
<p>从Scheduler中选择一个线程</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Only the earliest <code>subscribeOn</code> call in the chain is actually taken into account.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>subscribeOn实际上仅考虑链中 最早的呼叫。</p>
</div>
<div class="paragraph">
<p>The following example uses the <code>subscribeOn</code> method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); <i class="conum" data-value="1"></i><b>(1)</b>

final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    .map(i -&gt; 10 + i)  <i class="conum" data-value="2"></i><b>(2)</b>
    .subscribeOn(s)  <i class="conum" data-value="3"></i><b>(3)</b>
    .map(i -&gt; "value " + i);  <i class="conum" data-value="4"></i><b>(4)</b>

new Thread(() -&gt; flux.subscribe(System.out::println));  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建一个Scheduler由4个Thread。.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个map运行在这四个线程之一上</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>因为 subscribeOn从订阅时间（&lt;5&gt;）的位置，就开始切换了整个序列的线程</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>第二个map也运行在同一线程上.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>匿名Thread是最初发生预订的那个，但subscribeOn立即将其转移到四个调度程序线程之一。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="error.handling"><a class="anchor" href="#error.handling"></a>4.6. Handling Errors</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For a quick look at the available operators for error handling, see
<a href="#which.errors">the relevant operator decision tree</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In Reactive Streams, errors are terminal events. As soon as an error occurs, it stops the
sequence and gets propagated down the chain of operators to the last step, the
<code>Subscriber</code> you defined and its <code>onError</code> method.</p>
</div>
<div class="paragraph">
<p>在反应式流中，错误是终端事件。一旦发生错误，它就会停止序列，并沿操作链传播到最后一步Subscriber上，你定义的onError方法。</p>
</div>
<div class="paragraph">
<p>Such errors should still be dealt with at the application level. For instance, you might
display an error notification in a UI or send a meaningful error payload in a REST
endpoint. For this reason, the subscriber&#8217;s <code>onError</code> method should always be defined.</p>
</div>
<div class="paragraph">
<p>此类错误仍应在应用程序级别处理。例如，您可能在UI中显示错误通知，或在REST端点中发送有意义的错误有效负载。
因此，onError应始终定义订户的方法。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If not defined, <code>onError</code> throws an <code>UnsupportedOperationException</code>. You can
further detect and triage it with the <code>Exceptions.isErrorCallbackNotImplemented</code> method.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
如果未定义，则onError抛出UnsupportedOperationException。您可以使用该Exceptions.isErrorCallbackNotImplemented方法进一步对其进行检测和分类。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reactor also offers alternative means of dealing with errors in the middle of the chain,
as error-handling operators. The following example shows how to do so:</p>
</div>
<div class="paragraph">
<p>作为错误处理运算符，Reactor还提供了处理链中间错误的替代方法。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just(1, 2, 0)
    .map(i -&gt; "100 / " + i + " = " + (100 / i)) //this triggers an error with 0
    .onErrorReturn("Divided by zero :("); // error handling example</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Before you learn about error-handling operators, you must keep in mind that
<em>any error in a reactive sequence is a terminal event</em>. Even if an error-handling
operator is used, it does not let the original sequence continue. Rather, it
converts the <code>onError</code> signal into the start of a new sequence (the fallback one). In
other words, it replaces the terminated sequence <em>upstream</em> of it.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
在学习错误处理运算符之前，必须记住，反应序列中的 任何错误都是终端事件。
即使使用了错误处理运算符，它也不会让原始序列继续。相反，它将onError信号转换为新序列的开始（后备序列）。
换句话说，它将替换其上游的终止序列。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can consider each means of error handling one-by-one. When relevant, we make a
parallel with imperative programming&#8217;s <code>try</code> patterns.</p>
</div>
<div class="paragraph">
<p>现在，我们可以考虑各种错误处理方式。我们看做与命令式编程的try模式相平行。</p>
</div>
<div class="sect3">
<h4 id="_error_handling_operators"><a class="anchor" href="#_error_handling_operators"></a>4.6.1. Error Handling Operators</h4>
<div class="paragraph">
<p>You may be familiar with several ways of dealing with exceptions in a try-catch block.
Most notably, these include the following:</p>
</div>
<div class="paragraph">
<p>您可能熟悉在try-catch块中处理异常的几种方法。最值得注意的是，这些内容包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Catch and return a static default value.</p>
</li>
<li>
<p>Catch and execute an alternative path with a fallback method.</p>
</li>
<li>
<p>Catch and dynamically compute a fallback value.</p>
</li>
<li>
<p>Catch, wrap to a <code>BusinessException</code>, and re-throw.</p>
</li>
<li>
<p>Catch, log an error-specific message, and re-throw.</p>
</li>
<li>
<p>Use the <code>finally</code> block to clean up resources or a Java 7 &#8220;try-with-resource&#8221; construct.</p>
</li>
<li>
<p>捕获并返回静态默认值。</p>
</li>
<li>
<p>使用后备方法捕获并执行替代路径</p>
</li>
<li>
<p>捕获并动态计算后备值</p>
</li>
<li>
<p>接住，包装成BusinessException，然后重新抛出。</p>
</li>
<li>
<p>捕获，记录特定于错误的消息，然后重新抛出。</p>
</li>
<li>
<p>使用该finally块清除资源或Java 7“ try-with-resource”构造。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of these have equivalents in Reactor, in the form of error-handling operators.
Before looking into these operators, we first want to establish a parallel between a reactive
chain and a try-catch block.</p>
</div>
<div class="paragraph">
<p>所有这些都以错误处理运算符的形式在Reactor中具有等效项。在研究这些运算符之前，我们首先要在反应链和try-catch块之间建立并行。</p>
</div>
<div class="paragraph">
<p>When subscribing, the <code>onError</code> callback at the end of the chain is akin to a <code>catch</code>
block. There, execution skips to the catch in case an <code>Exception</code> is thrown, as the
following example shows:</p>
</div>
<div class="paragraph">
<p>订阅时，onError链末尾的回调类似于一个catch 块。Exception如下面的示例所示，在此情况下，执行会跳到捕获到的情况：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; s = Flux.range(1, 10)
    .map(v -&gt; doSomethingDangerous(v)) <i class="conum" data-value="1"></i><b>(1)</b>
    .map(v -&gt; doSecondTransform(v)); <i class="conum" data-value="2"></i><b>(2)</b>
s.subscribe(value -&gt; System.out.println("RECEIVED " + value), <i class="conum" data-value="3"></i><b>(3)</b>
            error -&gt; System.err.println("CAUGHT " + error) <i class="conum" data-value="4"></i><b>(4)</b>
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>执行了可能引发异常的转换</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果一切顺利，则执行第二次转换</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>每个成功转换的值都会打印出来</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>发生错误时，序列终止，并显示错误消息</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example is conceptually similar to the following try-catch block:</p>
</div>
<div class="paragraph">
<p>前面的示例在概念上类似于以下try-catch块：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    for (int i = 1; i &lt; 11; i++) {
        String v1 = doSomethingDangerous(i); <i class="conum" data-value="1"></i><b>(1)</b>
        String v2 = doSecondTransform(v1); <i class="conum" data-value="2"></i><b>(2)</b>
        System.out.println("RECEIVED " + v2);
    }
} catch (Throwable t) {
    System.err.println("CAUGHT " + t); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If an exception is thrown here&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;the rest of the loop is skipped&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203; and the execution goes straight to here.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Now that we have established a parallel, we can look at the different error handling cases
and their equivalent operators.</p>
</div>
<div class="paragraph">
<p>既然我们已经建立了并行，我们就可以研究不同的错误处理情况及其等效的运算符</p>
</div>
<div class="sect4">
<h5 id="_static_fallback_value"><a class="anchor" href="#_static_fallback_value"></a>Static Fallback Value</h5>
<div class="paragraph">
<p>The equivalent of &#8220;Catch and return a static default value&#8221; is <code>onErrorReturn</code>.
The following example shows how to use it:</p>
</div>
<div class="paragraph">
<p>等效于“捕获并返回静态默认值” onErrorReturn。以下示例显示了如何使用它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
  return doSomethingDangerous(10);
}
catch (Throwable error) {
  return "RECOVERED";
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the Reactor equivalent:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn("RECOVERED");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You also have the option of applying a <code>Predicate</code> on the exception to decided
whether or not to recover, as the folloiwng example shows:</p>
</div>
<div class="paragraph">
<p>你还可以选择Predicate对异常应用，以决定是否恢复，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn(e -&gt; e.getMessage().equals("boom10"), "recovered10"); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Recover only if the message of the exception is <code>"boom10"</code></td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_fallback_method"><a class="anchor" href="#_fallback_method"></a>Fallback Method</h5>
<div class="paragraph">
<p>If you want more than a single default value and you have an alternative (safer) way of
processing your data, you can use <code>onErrorResume</code>. This would be the equivalent of
&#8220;Catch and execute an alternative path with a fallback method&#8221;.</p>
</div>
<div class="paragraph">
<p>如果您需要多个默认值，并且有另一种（更安全的）数据处理方式，则可以使用onErrorResume。这相当于“使用后备方法捕获并执行替代路径”。</p>
</div>
<div class="paragraph">
<p>For example, if your nominal process is fetching data from an external and unreliable
service but you also keep a local cache of the same data that <em>can</em> be a bit more out of
date but is more reliable, you could do the following:</p>
</div>
<div class="paragraph">
<p>例如，如果您的标称进程正在从外部且不可靠的服务中获取数据，但是您还保留了相同数据的本地缓存，该缓存可能会过时但更可靠，则可以执行以下操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String v1;
try {
  v1 = callExternalService("key1");
}
catch (Throwable error) {
  v1 = getFromCache("key1");
}

String v2;
try {
  v2 = callExternalService("key2");
}
catch (Throwable error) {
  v2 = getFromCache("key2");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows the Reactor equivalent:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just("key1", "key2")
    .flatMap(k -&gt; callExternalService(k) <i class="conum" data-value="1"></i><b>(1)</b>
        .onErrorResume(e -&gt; getFromCache(k)) <i class="conum" data-value="2"></i><b>(2)</b>
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>对于每个键，异步调用外部服务。.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果外部服务调用失败，则退回到该密钥的缓存。请注意，无论源错误e是什么，我们总是应用相同的后备.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Like <code>onErrorReturn</code>, <code>onErrorResume</code> has variants that let you filter which exceptions
to fall back on, based either on the exception&#8217;s class or on a <code>Predicate</code>. The fact that it
takes a <code>Function</code> also lets you choose a different fallback sequence to switch to,
depending on the error encountered. The following example shows how to do so:</p>
</div>
<div class="paragraph">
<p>像 onErrorReturn，onErrorResume 那样具有变体，可让您根据异常的类或来过滤要回退的异常或断言。
事实上内部是执行了一个Function，使您可以根据遇到的错误选择不同的后备序列来切换。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just("timeout1", "unknown", "key2")
    .flatMap(k -&gt; callExternalService(k)
        .onErrorResume(error -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
            if (error instanceof TimeoutException) <i class="conum" data-value="2"></i><b>(2)</b>
                return getFromCache(k);
            else if (error instanceof UnknownKeyException)  <i class="conum" data-value="3"></i><b>(3)</b>
                return registerNewEntry(k, "DEFAULT");
            else
                return Flux.error(error); <i class="conum" data-value="4"></i><b>(4)</b>
        })
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>该功能允许动态选择如何继续.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果源超时，请访问本地缓存.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果源显示密钥未知，请创建一个新条目.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在所有其他情况下，“重新抛出”.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_dynamic_fallback_value"><a class="anchor" href="#_dynamic_fallback_value"></a>Dynamic Fallback Value</h5>
<div class="paragraph">
<p>Even if you do not have an alternative (safer) way of processing your data, you might want
to compute a fallback value out of the exception you received. This would be the
equivalent of &#8220;Catch and dynamically compute a fallback value&#8221;.</p>
</div>
<div class="paragraph">
<p>即使没有其他（更安全）的数据处理方式，您也可能希望根据收到的异常来计算回退值。这相当于“捕获并动态计算后备值”。</p>
</div>
<div class="paragraph">
<p>For instance, if your return type (<code>MyWrapper</code>) has a variant dedicated to holding an exception (think
<code>Future.complete(T success)</code> versus <code>Future.completeExceptionally(Throwable error)</code>), you
could instantiate the error-holding variant and pass the exception.</p>
</div>
<div class="paragraph">
<p>例如，如果您的返回类型（MyWrapper）具有专用于保存异常的变量（认为 Future.complete(T success)与Future.completeExceptionally(Throwable error)），则可以实例化错误保存变量并传递异常。</p>
</div>
<div class="paragraph">
<p>An imperative example would look like the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
  Value v = erroringMethod();
  return MyWrapper.fromValue(v);
}
catch (Throwable error) {
  return MyWrapper.fromError(error);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can do this reactively in the same way as the fallback method solution,
by using <code>onErrorResume</code>, with a tiny bit of boilerplate, as follows:</p>
</div>
<div class="paragraph">
<p>您可以通过使用onErrorResume，与一小部分样板程序一样，以与后备方法解决方案相同的方式进行反应，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">erroringFlux.onErrorResume(error -&gt; Mono.just( <i class="conum" data-value="1"></i><b>(1)</b>
        MyWrapper.fromError(error) <i class="conum" data-value="2"></i><b>(2)</b>
));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>由于您期望返回MyWrapper为错误的表示形式，因此需要获得 Mono&lt;MyWrapper&gt; 从 onErrorResume 中。我们用 Mono.just() 来完成.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们需要计算异常值。在这里，我们通过使用相关的MyWrapper工厂方法包装异常来实现这一目标。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_catch_and_rethrow"><a class="anchor" href="#_catch_and_rethrow"></a>Catch and Rethrow</h5>
<div class="paragraph">
<p>"Catch, wrap to a <code>BusinessException</code>, and re-throw" looks like the following in the
imperative world:</p>
</div>
<div class="paragraph">
<p>在命令式世界中，“捕获 BusinessException 包装并重新抛出” 看起来像以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
  return callExternalService(k);
}
catch (Throwable error) {
  throw new BusinessException("oops, SLA exceeded", error);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the &#8220;fallback method&#8221; example, the last line inside the <code>flatMap</code> gives us a hint
at achieving the same reactively, as follows:</p>
</div>
<div class="paragraph">
<p>在“后备方法”示例中，内的最后一行为flatMap我们提供了一个提示，以提示您以被动方式实现相同目标，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just("timeout1")
    .flatMap(k -&gt; callExternalService(k))
    .onErrorResume(original -&gt; Flux.error(
            new BusinessException("oops, SLA exceeded", original))
    );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>However, there is a more straightforward way of achieving the same effect with <code>onErrorMap</code>:</p>
</div>
<div class="paragraph">
<p>但是，还有一种更简单的方法可以达到以下效果onErrorMap：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just("timeout1")
    .flatMap(k -&gt; callExternalService(k))
    .onErrorMap(original -&gt; new BusinessException("oops, SLA exceeded", original));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_log_or_react_on_the_side"><a class="anchor" href="#_log_or_react_on_the_side"></a>Log or React on the Side</h5>
<div class="paragraph">
<p>For cases where you want the error to continue propagating but still want to react to
it without modifying the sequence (logging it, for instance), you can use the <code>doOnError</code>
operator. This is the equivalent of &#8220;Catch, log an error-specific message, and re-throw&#8221;
pattern, as the following example shows:</p>
</div>
<div class="paragraph">
<p>对于希望错误继续传播但仍希望对错误做出反应而又不修改顺序（例如记录错误）的情况，可以使用doOnError 运算符。这等效于“捕获，记录特定于错误的消息并重新抛出”模式，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
  return callExternalService(k);
}
catch (RuntimeException error) {
  //make a record of the error
  log("uh oh, falling back, service failed for key " + k);
  throw error;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>doOnError</code> operator, as well as all operators prefixed with <code>doOn</code> , are sometimes
referred to as having a &#8220;side-effect&#8221;. They let you peek inside the sequence&#8217;s events without
modifying them.</p>
</div>
<div class="paragraph">
<p>doOnError操作者，以及与所有前缀为doOn的操作符，有时被称为具有“副作用”。它们使您可以查看序列的事件而无需修改它们。</p>
</div>
<div class="paragraph">
<p>Like the imperative example shown earlier, the following example still propagates the error yet
ensures that we at least log that the external service had a failure:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">LongAdder failureStat = new LongAdder();
Flux&lt;String&gt; flux =
Flux.just("unknown")
    .flatMap(k -&gt; callExternalService(k) <i class="conum" data-value="1"></i><b>(1)</b>
        .doOnError(e -&gt; {
            failureStat.increment();
            log("uh oh, falling back, service failed for key " + k); <i class="conum" data-value="2"></i><b>(2)</b>
        })
        <i class="conum" data-value="3"></i><b>(3)</b>
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>可能失败的外部服务调用.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>具有日志和统计方面的副作用</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>之后，它仍然会以错误终止，除非我们在此处使用错误恢复操作符。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>We can also imagine we have statistic counters to increment as a second error side-effect.</p>
</div>
<div class="paragraph">
<p>我们还可以想象，我们有统计计数器会增加，这是第二个错误副作用。</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_resources_and_the_finally_block"><a class="anchor" href="#_using_resources_and_the_finally_block"></a>Using Resources and the Finally Block</h5>
<div class="paragraph">
<p>The last parallel to draw with imperative programming is the cleaning up that can be done
either by using a &#8220;Use of the <code>finally</code> block to clean up resources&#8221; or by using a
&#8220;Java 7 try-with-resource construct&#8221;, both shown below:</p>
</div>
<div class="paragraph">
<p>命令式编程的最后一个并行处理是清理，可以通过使用“使用finally块清理资源”或通过使用“ Java 7 try-with-resource构造”来完成，两者均显示如下：</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. Imperative use of finally</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Stats stats = new Stats();
stats.startTimer();
try {
  doSomethingDangerous();
}
finally {
  stats.stopTimerAndRecordTiming();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 14. Imperative use of try-with-resource</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try (SomeAutoCloseable disposableInstance = new SomeAutoCloseable()) {
  return disposableInstance.toString();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Both have their Reactor equivalents: <code>doFinally</code> and <code>using</code>.</p>
</div>
<div class="paragraph">
<p>两者都有其Reactor等效方法：doFinally和using。</p>
</div>
<div class="paragraph">
<p><code>doFinally</code> is about side-effects that you want to be executed whenever the
sequence terminates (with <code>onComplete</code> or <code>onError</code>) or is cancelled.
It gives you a hint as to what kind of termination triggered the side-effect.
The following example shows how to use <code>doFinally</code>:</p>
</div>
<div class="paragraph">
<p>doFinally与序列终止（用onComplete或onError或取消）时要执行的副作用有关。它提示您哪种终止方式会引起副作用。以下示例显示如何使用doFinally：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Reactive finally: <code>doFinally()</code></div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Stats stats = new Stats();
LongAdder statsCancel = new LongAdder();

Flux&lt;String&gt; flux =
Flux.just("foo", "bar")
    .doOnSubscribe(s -&gt; stats.startTimer())
    .doFinally(type -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
        stats.stopTimerAndRecordTiming();<i class="conum" data-value="2"></i><b>(2)</b>
        if (type == SignalType.CANCEL) <i class="conum" data-value="3"></i><b>(3)</b>
          statsCancel.increment();
    })
    .take(1); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>doFinally</code> consumes a <code>SignalType</code> for the type of termination. 	doFinally使用终止类型的SignalType。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Similarly to <code>finally</code> blocks, we always record the timing.  与“ finally”块类似，我们总是记录时间。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here we also increment statistics in case of cancellation only.  在这里，我们还仅在取消的情况下增加统计信息。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>take(1)</code> cancels after one item is emitted. <code>take（1）</code> 表示 发出一项后即取消，</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>On the other hand, <code>using</code> handles the case where a <code>Flux</code> is derived from a
resource and that resource must be acted upon whenever processing is done.
In the following example, we replace the <code>AutoCloseable</code> interface of &#8220;try-with-resource&#8221; with a
<code>Disposable</code>:</p>
</div>
<div class="paragraph">
<p>另一方面，“using”处理了“Flux”来自于资源，并且每当处理完成时都必须对资源进行操作。
在以下示例中，我们将“ try-with-resource”的“ AutoCloseable”界面替换为
<code>一次性</code>：</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. The Disposable resource</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AtomicBoolean isDisposed = new AtomicBoolean();
Disposable disposableInstance = new Disposable() {
    @Override
    public void dispose() {
        isDisposed.set(true); <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @Override
    public String toString() {
        return "DISPOSABLE";
    }
};</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now we can do the reactive equivalent of &#8220;try-with-resource&#8221; on it, which looks
like the following:</p>
</div>
<div class="paragraph">
<p>现在，我们可以在其上执行与“ try-with-resource”等效的效果，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. Reactive try-with-resource: <code>using()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux =
Flux.using(
        () -&gt; disposableInstance, <i class="conum" data-value="1"></i><b>(1)</b>
        disposable -&gt; Flux.just(disposable.toString()), <i class="conum" data-value="2"></i><b>(2)</b>
        Disposable::dispose <i class="conum" data-value="3"></i><b>(3)</b>
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The first lambda generates the resource. Here, we return our mock <code>Disposable</code>. 	第一个lambda生成资源。在这里，我们返回我们的模拟Disposable</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The second lambda processes the resource, returning a <code>Flux&lt;T&gt;</code>. 第二个lambda处理资源，返回Flux&lt;T&gt;。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The third lambda is called when the <code>Flux</code> from &lt;2&gt; terminates or is cancelled, to
clean up resources. 当Fluxfrom &lt;2&gt;终止或取消时，将调用第三个lambda 以清理资源。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>After subscription and execution of the sequence, the <code>isDisposed</code> atomic boolean
becomes <code>true</code>. 订阅并执行序列后，isDisposed原子布尔值变为true。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_demonstrating_the_terminal_aspect_of_onerror"><a class="anchor" href="#_demonstrating_the_terminal_aspect_of_onerror"></a>Demonstrating the Terminal Aspect of <code>onError</code></h5>
<div class="paragraph">
<p>In order to demonstrate that all these operators cause the upstream original sequence to
terminate when an error happens, we can use a more visual example with a
<code>Flux.interval</code>. The <code>interval</code> operator ticks every x units of time with an increasing
<code>Long</code> value. The following example uses an <code>interval</code> operator:</p>
</div>
<div class="paragraph">
<p>为了证明所有这些运算符都会在发生错误时使上游原始序列终止，我们可以使用带有的更直观的示例 Flux.interval。
该interval运算符每隔x单位时间滴答一次，递增Long值。以下示例使用interval运算符：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux =
Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .onErrorReturn("Uh oh");

flux.subscribe(System.out::println);
Thread.sleep(2100); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note that <code>interval</code> executes on a <strong>timer</strong> <code>Scheduler</code> by default. If we want
to run that example in a main class, we would need to add a <code>sleep</code> call here so that the
application does not exit immediately without any value being produced.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>请注意，默认情况下interval会在计时器上执行Scheduler。如果要在主类中运行该示例，则需要在sleep此处添加一个调用，以便应用程序不会立即退出而不会产生任何值。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example prints out one line every 250ms, as follows:</p>
</div>
<div class="paragraph">
<p>前面的示例每250ms打印出一行，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>tick 0
tick 1
tick 2
Uh oh</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Even with one extra second of runtime, no more tick comes in from the <code>interval</code>. The
sequence was indeed terminated by the error.</p>
</div>
<div class="paragraph">
<p>即使再多一秒的运行时间，也不会再出现滴答声interval。错误确实终止了该序列。</p>
</div>
</div>
<div class="sect4">
<h5 id="_retrying"><a class="anchor" href="#_retrying"></a>Retrying</h5>
<div class="paragraph">
<p>There is another operator of interest with regards to error handling, and you might be
tempted to use it in the case described in the previous section. <code>retry</code>, as its name
indicates, lets you retry an error-producing sequence.</p>
</div>
<div class="paragraph">
<p>关于错误处理，还有另一个有趣的运算符，在上一节中所述的情况下，您可能会想使用它。retry顾名思义，可让您重试产生错误的序列。</p>
</div>
<div class="paragraph">
<p>The thing to keep in mind is that it works by <strong>re-subscribing</strong> to the upstream <code>Flux</code>.
This is really a different sequence, and the original one is still terminated.
To verify that, we can re-use the previous example and append a <code>retry(1)</code> to
retry once instead of using <code>onErrorReturn</code>. The following example shows how to do sl:</p>
</div>
<div class="paragraph">
<p>要记住的是，它通过重新订阅上游的Flux而起作用。这实际上是一个不同的序列，原始序列仍然终止。为了验证这一点，我们可以重用前面的示例，并在其中附加一个`retry（1）<code>。
重试一次，而不要使用`onErrorReturn</code>。 以下示例显示了如何执行sl：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .retry(1)
    .elapsed() <i class="conum" data-value="1"></i><b>(1)</b>
    .subscribe(System.out::println, System.err::println); <i class="conum" data-value="2"></i><b>(2)</b>

Thread.sleep(2100); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>elapsed</code> associates each value with the duration since previous value was emitted.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We also want to see when there is an <code>onError</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Ensure we have enough time for our 4x2 ticks.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding example produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>259,tick 0
249,tick 1
251,tick 2
506,tick 0 <i class="conum" data-value="1"></i><b>(1)</b>
248,tick 1
253,tick 2
java.lang.RuntimeException: boom</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A new <code>interval</code> started, from tick 0. The additional 250ms duration is
coming from the 4th tick, the one that causes the exception and subsequent
retry. 	从滴答0开始一个新的interval。额外的250毫秒持续时间来自第4个滴答，它引起异常并随后重试。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see from the preceding example, <code>retry(1)</code> merely re-subscribed to the original <code>interval</code>
once, restarting the tick from 0. The second time around, since the exception
still occurs, it gives up and propagates the error downstream.</p>
</div>
<div class="paragraph">
<p>从前面的示例中可以看到，retry(1)只重新订阅了interval 一次，从0重新开始了滴答。第二次，由于仍然发生异常，它放弃并向下游传播错误。</p>
</div>
<div class="paragraph">
<p>There is a more advanced version of <code>retry</code> (called <code>retryWhen</code>) that uses a &#8220;companion&#8221;
<code>Flux</code> to tell whether or not a particular failure should retry. This companion <code>Flux</code> is
created by the operator but decorated by the user, in order to customize the retry
condition.</p>
</div>
<div class="paragraph">
<p>有一个更高级的版本retry（称为retryWhen），它使用“companion” Flux来告知是否应重试特定的故障。
该同伴Flux由操作员创建但由用户修饰，以自定义重试条件。</p>
</div>
<div class="paragraph">
<p>The companion <code>Flux</code> is a <code>Flux&lt;Throwable&gt;</code> that gets passed to a <code>Function</code>, the sole
parameter of <code>retryWhen</code>. As the user, you define that function and make it return a new
<code>Publisher&lt;?&gt;</code>. Retry cycles go as follows:</p>
</div>
<div class="paragraph">
<p>Companiond的Flux是Flux&lt;Throwable&gt;，它传递给retryWhen的唯一参数Function。
作为使用者，您可以定义该函数并使它返回new Publisher&lt;?&gt;。重试周期如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Each time an error happens (giving potential for a retry), the error is emitted into the
companion <code>Flux</code>, which has been decorated by your function. Having a <code>Flux</code> here
gives a bird eye&#8217;s view of all the attempts so far.</p>
</li>
<li>
<p>If the companion <code>Flux</code> emits a value, a retry happens.</p>
</li>
<li>
<p>If the companion <code>Flux</code> completes, the error is swallowed, the retry cycle stops,
and the resulting sequence completes, too.</p>
</li>
<li>
<p>If the companion <code>Flux</code> produces an error (<code>e</code>), the retry cycle stops and the
resulting sequence errors with <code>e</code>.</p>
</li>
<li>
<p>每次发生错误（重试的可能性）时，错误就会被发送到伴随Flux函数中，该伴随函数已由您的函数修饰。在Flux这里有一个鸟瞰图，可以看到到目前为止的所有尝试。</p>
</li>
<li>
<p>果同伴Flux发出一个值，则重试。</p>
</li>
<li>
<p>如果伴随程序Flux完成，则错误将被吞没，重试周期将停止，并且所生成的序列也将完成。</p>
</li>
<li>
<p>如果随companion Flux产生错误（e），则重试周期停止，并且产生的序列错误为e。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The distinction between the previous two cases is important. Simply completing the
companion would effectively swallow an error. Consider the following way of emulating
<code>retry(3)</code> by using <code>retryWhen</code>:</p>
</div>
<div class="paragraph">
<p>前两种情况之间的区别很重要。只需完成companion 即可有效地吞下一个错误。考虑使用retryWhen 以模拟 retry(3)方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux
    .&lt;String&gt;error(new IllegalArgumentException()) <i class="conum" data-value="1"></i><b>(1)</b>
    .doOnError(System.out::println) <i class="conum" data-value="2"></i><b>(2)</b>
    .retryWhen(companion -&gt; companion.take(3)); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This continuously produces errors, calling for retry attempts.这会不断产生错误，要求重试。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>doOnError</code> before the retry lets us log and see all failures. 	doOnError 重试之前，让我们记录并查看所有失败</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here, we consider the first three errors as retry-able (<code>take(3)</code>) and then give up. 在这里，我们将前三个错误视为可重试（take(3)），然后放弃。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>In effect, the preceding example results in an empty <code>Flux</code>, but it completes successfully. Since
<code>retry(3)</code> on the same <code>Flux</code> would have terminated with the latest error, this
<code>retryWhen</code> example is not exactly the same as a <code>retry(3)</code>.</p>
</div>
<div class="paragraph">
<p>实际上，前面的示例导致为空Flux，但它成功完成。
由于 retry(3)同一Flux错误会因最新错误而终止，因此此retryWhen示例与并不完全与retry(3)相同。</p>
</div>
<div class="paragraph">
<p>Getting to the same behavior involves a few additional tricks:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux =
Flux.&lt;String&gt;error(new IllegalArgumentException())
    .retryWhen(companion -&gt; companion
    .zipWith(Flux.range(1, 4), <i class="conum" data-value="1"></i><b>(1)</b>
          (error, index) -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
            if (index &lt; 4) return index; <i class="conum" data-value="3"></i><b>(3)</b>
            else throw Exceptions.propagate(error); <i class="conum" data-value="4"></i><b>(4)</b>
          })
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Trick one: use <code>zip</code> and a <code>range</code> of "number of acceptable retries + 1".	技巧一：使用zip和range“可接受的重试次数+ 1”</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>zip</code> function lets you count the retries while keeping track of the original
error.	该zip功能可让您计算重试次数，同时跟踪原始错误</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>To allow for three retries, indexes before 4 return a value to emit.为了允许进行三次重试，4之前的索引将返回一个要发出的值</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In order to terminate the sequence in error, we throw the original exception after
these three retries. 为了终止错误的序列，我们在这三个重试之后抛出了原始异常</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>达到相同的行为还涉及其他一些技巧：</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can use similar code to implement an &#8220;exponential backoff and retry&#8221; pattern,
as shown in the <a href="#faq.exponentialBackoff">FAQ</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以使用类似的代码来实现“指数退避和重试”模式，如FAQ中所示。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handling_exceptions_in_operators_or_functions"><a class="anchor" href="#_handling_exceptions_in_operators_or_functions"></a>4.6.2. Handling Exceptions in Operators or Functions</h4>
<div class="paragraph">
<p>In general, all operators can themselves contain code that potentially trigger an
exception or calls to a user-defined callback that can similarly fail, so they all
contain some form of error handling.</p>
</div>
<div class="paragraph">
<p>通常，所有运算符都可以自己包含可能触发异常的代码或对用户定义的回调的调用（同样可能失败），因此它们都包含某种形式的错误处理。</p>
</div>
<div class="paragraph">
<p>As a rule of thumb, an unchecked exception is always propagated through <code>onError</code>. For
instance, throwing a <code>RuntimeException</code> inside a <code>map</code> function translates to an
<code>onError</code> event, as the following code shows:</p>
</div>
<div class="paragraph">
<p>根据经验，始终会通过传播未经检查的异常onError。
例如，将函数RuntimeException内部的内容map转换为 onError事件，如以下代码所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just("foo")
    .map(s -&gt; { throw new IllegalArgumentException(s); })
    .subscribe(v -&gt; System.out.println("GOT VALUE"),
               e -&gt; System.out.println("ERROR: " + e));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code prints out the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ERROR: java.lang.IllegalArgumentException: foo</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can tune the <code>Exception</code> before it is passed to <code>onError</code>, through the use of a
<a href="#hooks-internal">hook</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以使用 <a href="#hooks-internal">hook</a> 来调整Exception传递给它之前的状态。 onError</p>
</div>
<div class="paragraph">
<p>Reactor, however, defines a set of exceptions (such as <code>OutOfMemoryError</code>) that are
always deemed to be fatal. See the <code>Exceptions.throwIfFatal</code> method. These errors mean that
Reactor cannot keep operating and are thrown rather than propagated.</p>
</div>
<div class="paragraph">
<p>但是，Reactor定义了一组OutOfMemoryError总是被认为是致命的异常（例如）。
参见Exceptions.throwIfFatal方法。这些错误意味着Reactor无法继续运行，并且会被抛出而不是传播。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Internally, there are also cases where an unchecked exception still cannot be
propagated (most notably during the subscribe and request phases), due to concurrency
races that could lead to double <code>onError</code> or <code>onComplete</code> conditions. When these races
happen, the error that cannot be propagated is &#8220;dropped&#8221;. These cases can still be
managed to some extent by using customizable hooks. See <a href="#hooks-dropping">Dropping Hooks</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在内部，由于并发竞争可能导致重复onError或onComplete情况，因此在某些情况下仍无法传播未经检查的异常（最值得注意的是在订阅和请求阶段）。
当发生这些竞争时，无法传播的错误将被“丢弃”。通过使用可定制的挂钩，仍可以在某种程度上管理这些情况。请参阅 <a href="#hooks-dropping">Dropping Hooks</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You may ask: &#8220;What about checked exceptions?&#8221;</p>
</div>
<div class="paragraph">
<p>您可能会问：“如何检查异常？”</p>
</div>
<div class="paragraph">
<p>If, for example, you need to call some method that declares it <code>throws</code> exceptions, you
still have to deal with those exceptions in a <code>try-catch</code> block. You have several
options, though:</p>
</div>
<div class="paragraph">
<p>例如，如果您需要调用某个声明其throws异常的方法，则仍必须在一个try-catch块中处理这些异常。不过，您有几种选择：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Catch the exception and recover from it. The sequence continues normally.</p>
</li>
<li>
<p>Catch the exception, wrap it into an <em>unchecked</em> exception, and then throw it
(interrupting the sequence). The <code>Exceptions</code> utility class can help you with that (we
get to that next).</p>
</li>
<li>
<p>If you need to return a <code>Flux</code> (for example, you are in a <code>flatMap</code>), wrap the
exception in an error-producing <code>Flux</code>, as follows: <code>return Flux.error(checkedException)</code>. (The
sequence also terminates.)</p>
</li>
<li>
<p>获异常并从中恢复。该序列正常继续。</p>
</li>
<li>
<p>捕获异常，将其包装为未经检查的异常，然后将其抛出（中断序列）。该Exceptions实用工具类可以帮你</p>
</li>
<li>
<p>如果需要返回Flux（例如，你在中flatMap），则将异常包装在一个错误生产器的`Flux`中，如下所示：return Flux.error(checkedException)。（该序列也终止。）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Reactor has an <code>Exceptions</code> utility class that you can use to ensure that exceptions are
wrapped only if they are checked exceptions:</p>
</div>
<div class="paragraph">
<p>Reactor有一个Exceptions实用程序类，您可以使用它来确保仅是检查异常的情况下包装这些异常：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the <code>Exceptions.propagate</code> method to wrap exceptions, if necessary. It also calls
<code>throwIfFatal</code> first and does not wrap <code>RuntimeException</code>.</p>
</li>
<li>
<p>Use the <code>Exceptions.unwrap</code> method to get the original unwrapped exception (going back
to the root cause of a hierarchy of reactor-specific exceptions).</p>
</li>
<li>
<p>Exceptions.propagate如有必要，使用该方法包装异常。它还throwIfFatal先调用 ，并且不包装RuntimeException。</p>
</li>
<li>
<p>使用该Exceptions.unwrap方法来获取原始的未包装的异常（返回到具体于reactor的异常的层次结构的根本原因）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the following example of a <code>map</code> that uses a conversion method that can throw an
<code>IOException</code>:</p>
</div>
<div class="paragraph">
<p>考虑以下示例，该示例map使用可以引发的转换方法 IOException：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public String convert(int i) throws IOException {
    if (i &gt; 3) {
        throw new IOException("boom " + i);
    }
    return "OK " + i;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now imagine that you want to use that method in a <code>map</code>. You must now explicitly catch
the exception, and your map function cannot re-throw it. So you can propagate it to the
map&#8217;s <code>onError</code> method as a <code>RuntimeException</code>, as follows:</p>
</div>
<div class="paragraph">
<p>现在，假设您要在中使用该方法map。现在，您必须显式捕获异常，并且您的map函数无法将其重新引发。
因此，您可以将其像 RuntimeException 传播到Map的onError方法，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; converted = Flux
    .range(1, 10)
    .map(i -&gt; {
        try { return convert(i); }
        catch (IOException e) { throw Exceptions.propagate(e); }
    });</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Later on, when subscribing to the preceding <code>Flux</code> and reacting to errors (such as in the
UI), you could revert back to the original exception if you want to do something
special for IOExceptions. The following example shows how to do so:</p>
</div>
<div class="paragraph">
<p>稍后，在订阅上述内容Flux并对错误做出反应时（例如在UI中），如果您想对IOExceptions做一些特殊的事情，则可以恢复到原始异常。
以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">converted.subscribe(
    v -&gt; System.out.println("RECEIVED: " + v),
    e -&gt; {
        if (Exceptions.unwrap(e) instanceof IOException) {
            System.out.println("Something bad happened with I/O");
        } else {
            System.out.println("Something bad happened");
        }
    }
);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="processors"><a class="anchor" href="#processors"></a>4.7. Processors</h3>
<div class="paragraph">
<p>Processors are a special kind of <code>Publisher</code> that are also a <code>Subscriber</code>. That means
that you can <code>subscribe</code> to a <code>Processor</code> (generally, they implement <code>Flux</code>), but you can
also call methods to manually inject data into the sequence or terminate it.</p>
</div>
<div class="paragraph">
<p>处理器是一种特殊的Publisher，同时也是一个Subscriber。
这意味着你可以subscribe到Processor（通常，他们实施Flux），但你也可以手动调用方法来注入数据的序列或终止它。</p>
</div>
<div class="paragraph">
<p>There are several kinds of Processors, each with a few particular semantics, but before
you start looking into these, you need to ask yourself the following question:</p>
</div>
<div class="paragraph">
<p>处理器有几种，每种都有一些特殊的语义，但是在开始研究它们之前，您需要问自己以下问题：</p>
</div>
<div class="sect3">
<h4 id="_do_i_need_a_processor"><a class="anchor" href="#_do_i_need_a_processor"></a>4.7.1. Do I Need a Processor?</h4>
<div class="paragraph">
<p>Most of the time, you should try to avoid using a <code>Processor</code>. They are harder to use
correctly and prone to some corner cases.</p>
</div>
<div class="paragraph">
<p>大多数时候，您应该避免使用Processor。它们很难正确使用，并且容易出现极端情况。</p>
</div>
<div class="paragraph">
<p>If you think a <code>Processor</code> could be a good match for your use case, ask yourself if you
have tried these two alternatives:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Could an operator or combination of operators fit the bill? (See <a href="#which-operator">Which operator do I need?</a>.)</p>
</li>
<li>
<p>Could a <a href="#producing">&#8220;generator&#8221;</a> operator work instead? (Generally, these operators
are made to bridge APIs that are not reactive, providing a &#8220;sink&#8221; that is similar in
concept to a <code>Processor</code>, in the sense that it lets you manually populate the sequence
with data or terminate it).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If, after exploring the above alternatives, you still think you need a <code>Processor</code>, read
the <a href="#processor-overview">Overview of Available Processors</a> section to learn about the different implementations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_safely_produce_from_multiple_threads_by_using_the_sink_facade"><a class="anchor" href="#_safely_produce_from_multiple_threads_by_using_the_sink_facade"></a>4.7.2. Safely Produce from Multiple Threads by Using the <code>Sink</code> Facade</h4>
<div class="paragraph">
<p>Rather than directly using Reactor <code>Processors</code>, it is a good practice to obtain a <code>Sink</code>
for the <code>Processor</code> by calling <code>sink()</code> <strong>once</strong>.</p>
</div>
<div class="paragraph">
<p><code>FluxProcessor</code> sinks safely gate multi-threaded producers and can be used by
applications that generate data from multiple threads concurrently. For example, you can create a
thread-safe serialized sink for <code>UnicastProcessor</code> by doing the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">UnicastProcessor&lt;Integer&gt; processor = UnicastProcessor.create();
FluxSink&lt;Integer&gt; sink = processor.sink(overflowStrategy);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Multiple producer threads may concurrently generate data on the following serialized
sink by doing the following:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">sink.next(n);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Despite the <code>FluxSink</code> being adapted for multi-threaded <strong>manual</strong> feeding
of the <code>Processor</code>, it is not possible to mix the subscriber approach with the
sink approach: You have to either subscribe your <code>FluxProcessor</code> to a source
<code>Publisher</code> or feed it manually though its <code>FluxSink</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Overflow from <code>next</code> behaves in two possible ways, depending on the <code>Processor</code> and its
configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An unbounded processor handles the overflow itself by dropping or buffering.</p>
</li>
<li>
<p>A bounded processor blocks or &#8220;spins&#8221; on the <code>IGNORE</code> strategy or applies the
<code>overflowStrategy</code> behavior specified for the <code>sink</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="processor-overview"><a class="anchor" href="#processor-overview"></a>4.7.3. Overview of Available Processors</h4>
<div class="paragraph">
<p>Reactor Core comes with several flavors of <code>Processor</code>. Not all processors have the same
semantics, but they are roughly split into three categories. The following list briefly
describes the three kinds of processors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>direct</strong> (<code>DirectProcessor</code> and <code>UnicastProcessor</code>): These processors can push
data only through direct user action (calling their methods of their <code>Sink</code> directly).</p>
</li>
<li>
<p><strong>synchronous</strong> (<code>EmitterProcessor</code> and <code>ReplayProcessor</code>): These processors can either push data
through user interaction or by subscribing to an upstream <code>Publisher</code> and synchronously
draining it.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
One way of publishing events onto different threads is to use the <code>EmitterProcessor</code>
combined with <code>publishOn(Scheduler)</code>. This can for example replace the former <code>TopicProcessor</code>,
which was using <code>Unsafe</code> operations and has been moved to
<a href="https://github.com/reactor/reactor-addons/tree/master/reactor-extra/src/main/java/reactor/extra/processor">reactor-extra</a>
in 3.3.0.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_direct_processor"><a class="anchor" href="#_direct_processor"></a>Direct Processor</h5>
<div class="paragraph">
<p>A direct <code>Processor</code> is a processor that can dispatch signals to zero or more
<code>Subscribers</code>. It is the simplest one to instantiate, with a single <code>DirectProcessor#create()</code> static
factory method. On the other hand, <strong>it has the limitation of not handling backpressure</strong>.
As a consequence, a <code>DirectProcessor</code> signals an <code>IllegalStateException</code> to its
subscribers if you push N elements through it but at least one of its subscribers has
requested less than N.</p>
</div>
<div class="paragraph">
<p>Once the <code>Processor</code> has terminated (usually through its sink&#8217;s <code>error(Throwable)</code> or
<code>complete()</code> methods being called), it lets more subscribers subscribe but replays the
termination signal to them immediately.</p>
</div>
</div>
<div class="sect4">
<h5 id="_unicast_processor"><a class="anchor" href="#_unicast_processor"></a>Unicast Processor</h5>
<div class="paragraph">
<p>A unicast <code>Processor</code> can deal with backpressure by using an internal buffer. The trade-off
is that it can have <em>at most one</em> <code>Subscriber</code>.</p>
</div>
<div class="paragraph">
<p>A <code>UnicastProcessor</code> has a few more options than a direct processor, reflected by the existence of a few <code>create</code> static factory
methods. For instance, by default, it is unbounded: If you push any amount of
data through it while its <code>Subscriber</code> has not yet requested data, it buffers all of
the data.</p>
</div>
<div class="paragraph">
<p>You can change this by providing a custom <code>Queue</code> implementation for the internal
buffering in the <code>create</code> factory method. If that queue is bounded, the processor could
reject the push of a value when the buffer is full and not enough requests from
downstream have been received.</p>
</div>
<div class="paragraph">
<p>In that <em>bounded</em> case, you can also build the processor with a callback that is invoked
on each rejected element, allowing for cleanup of these rejected elements.</p>
</div>
</div>
<div class="sect4">
<h5 id="_emitter_processor"><a class="anchor" href="#_emitter_processor"></a>Emitter Processor</h5>
<div class="paragraph">
<p>An emitter <code>Processor</code> can emit to several subscribers while honoring
backpressure for each of its subscribers. It can also subscribe to a <code>Publisher</code> and
relay its signals synchronously.</p>
</div>
<div class="paragraph">
<p>Initially, when it has no subscriber, it can still accept a few data pushes up to a
configurable <code>bufferSize</code>. After that point, if no <code>Subscriber</code> has come in and consumed
the data, calls to <code>onNext</code> block until the processor is drained (which can happen only
concurrently by then).</p>
</div>
<div class="paragraph">
<p>Thus, the first <code>Subscriber</code> to subscribe receives up to <code>bufferSize</code> elements upon
subscribing. However, after that, the processor stops replaying signals to additional
subscribers. These subsequent subscribers instead receive only the signals pushed through
the processor after they have subscribed. The internal buffer is still used for
backpressure purposes.</p>
</div>
<div class="paragraph">
<p>By default, if all of its subscribers are cancelled (which basically means they have all
un-subscribed), it clears its internal buffer and stops accepting new subscribers.
You can tune this by using the <code>autoCancel</code> parameter in the <code>create</code> static factory methods.</p>
</div>
</div>
<div class="sect4">
<h5 id="_replay_processor"><a class="anchor" href="#_replay_processor"></a>Replay Processor</h5>
<div class="paragraph">
<p>A replay <code>Processor</code> caches elements that are either pushed directly through its <code>sink()</code>
or elements from an upstream <code>Publisher</code> and replays them to late subscribers.</p>
</div>
<div class="paragraph">
<p>It can be created in multiple configurations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Caching a single element (<code>cacheLast</code>).</p>
</li>
<li>
<p>Caching a limited history (<code>create(int)</code>) or an unbounded history (<code>create()</code>).</p>
</li>
<li>
<p>Caching a time-based replay window (<code>createTimeout(Duration)</code>).</p>
</li>
<li>
<p>Caching a combination of history size and time window
(<code>createSizeOrTimeout(int, Duration)</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/coreFeatures.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#core-features">Reactor Core Features</a>"</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kotlin"><a class="anchor" href="#kotlin"></a>5. Kotlin support</h2>
<div class="sectionbody">
<div id="kotlin-introduction" class="paragraph">
<p><a href="https://kotlinlang.org">Kotlin</a> is a statically-typed language targeting the JVM (and other platforms),
which allows writing concise and elegant code while providing very good
<a href="https://kotlinlang.org/docs/reference/java-interop.html">interoperability</a> with
existing libraries written in Java.</p>
</div>
<div class="paragraph">
<p>This section describes Reactor&#8217;s support for Kotlin.</p>
</div>
<div class="sect2">
<h3 id="kotlin-requirements"><a class="anchor" href="#kotlin-requirements"></a>5.1. Requirements</h3>
<div class="paragraph">
<p>Reactor supports Kotlin 1.1+ and requires
<a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib"><code>kotlin-stdlib</code></a>
(or one of its <a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib-jre7"><code>kotlin-stdlib-jre7</code></a>
or <a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib-jre8"><code>kotlin-stdlib-jre8</code></a> variants).</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-extensions"><a class="anchor" href="#kotlin-extensions"></a>5.2. Extensions</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of <code>Dysprosium-M1</code> (ie. <code>reactor-core 3.3.0.M1</code>), Kotlin extensions are moved to a
dedicated <a href="https://github.com/reactor/reactor-kotlin-extensions"><code>reactor-kotlin-extensions</code></a>
module with new package names that start with <code>reactor.kotlin</code> instead of simply <code>reactor</code>.</p>
</div>
<div class="paragraph">
<p>As a consequence, Kotlin extensions in <code>reactor-core</code> module are deprecated.
The new dependency&#8217;s groupId and artifactId are:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-gradle" data-lang="gradle">io.projectreactor.kotlin:reactor-kotlin-extensions</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Thanks to its great <a href="https://kotlinlang.org/docs/reference/java-interop.html">Java interoperability</a>
and to <a href="https://kotlinlang.org/docs/reference/extensions.html">Kotlin extensions</a>, Reactor
Kotlin APIs leverage regular Java APIs and are additionally enhanced by a few Kotlin-specific APIs
that are available out of the box within Reactor artifacts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Keep in mind that Kotlin extensions need to be imported to be used. This means
for example that the <code>Throwable.toFlux</code> Kotlin extension
is available only if <code>import reactor.kotlin.core.publisher.toFlux</code> is imported.
That said, similar to static imports, an IDE should automatically suggest the import in most cases.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, <a href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters">Kotlin reified type parameters</a>
provide a workaround for JVM <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">generics type erasure</a>,
and Reactor provides some extensions to take advantage of this feature.</p>
</div>
<div class="paragraph">
<p>The following table compares Reactor with Java against Reactor with Kotlin and extensions:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Java</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Kotlin with extensions</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono.just("foo")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"foo".toMono()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux.fromIterable(list)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>list.toFlux()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono.error(new RuntimeException())</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RuntimeException().toMono()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux.error(new RuntimeException())</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RuntimeException().toFlux()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.ofType(Foo.class)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.ofType&lt;Foo&gt;()</code> or <code>flux.ofType(Foo::class)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StepVerifier.create(flux).verifyComplete()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.test().verifyComplete()</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <a href="https://projectreactor.io/docs/kotlin/release/kdoc-api/">Reactor KDoc API</a> lists and documents
all the available Kotlin extensions.</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-null-safety"><a class="anchor" href="#kotlin-null-safety"></a>5.3. Null Safety</h3>
<div class="paragraph">
<p>One of Kotlin&#8217;s key features is <a href="https://kotlinlang.org/docs/reference/null-safety.html">null safety</a>,
which cleanly deals with <code>null</code> values at compile time rather than bumping into the famous
<code>NullPointerException</code> at runtime. This makes applications safer through nullability
declarations and expressive &#8220;value or no value&#8221; semantics without paying the cost of wrappers such as <code>Optional</code>.
(Kotlin allows using functional constructs with nullable values. See this
<a href="https://www.baeldung.com/kotlin-null-safety">comprehensive guide to Kotlin null-safety</a>.)</p>
</div>
<div class="paragraph">
<p>Although Java does not let one express null safety in its type-system, Reactor <a href="#null-safety">now
provides null safety</a> of the whole Reactor API through tooling-friendly annotations declared
in the <code>reactor.util.annotation</code> package.
By default, types from Java APIs used in Kotlin are recognized as
<a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">platform types</a>
for which null-checks are relaxed.
<a href="https://github.com/Kotlin/KEEP/blob/jsr-305/proposals/jsr-305-custom-nullability-qualifiers.md">Kotlin support for JSR 305 annotations</a>
and Reactor nullability annotations provide null-safety for the whole Reactor API to Kotlin developers,
with the advantage of dealing with <code>null</code>-related issues at compile time.</p>
</div>
<div class="paragraph">
<p>You can configure the JSR 305 checks by adding the <code>-Xjsr305</code> compiler flag with the following
options: <code>-Xjsr305={strict|warn|ignore}</code>.</p>
</div>
<div class="paragraph">
<p>For kotlin versions 1.1.50+, the default behavior is the same as <code>-Xjsr305=warn</code>.
The <code>strict</code> value is required to have the Reactor API full null-safety taken into account
but should be considered experimental, since the Reactor API nullability declaration could evolve
even between minor releases, as more checks may be added in the future).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Nullability for generic type arguments, variable arguments, and array elements is not supported yet,
but itshould be in an upcoming release. See <a href="https://github.com/Kotlin/KEEP/issues/79">this dicussion</a>
for up-to-date information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/kotlin.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#kotlin">Kotlin support</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing"><a class="anchor" href="#testing"></a>6. Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Whether you have written a simple chain of Reactor operators or your own operator,
automated testing is always a good idea.</p>
</div>
<div class="paragraph">
<p>Reactor comes with a few elements dedicated to testing, gathered into their own
artifact: <code>reactor-test</code>. You can find that project
<a href="https://github.com/reactor/reactor-core/tree/master/reactor-test/src">on Github</a>,
inside of the <code>reactor-core</code> repository.</p>
</div>
<div class="paragraph">
<p>To use it in your tests, you must add it as a test dependency.
The following example shows how to add <code>reactor-test</code> as a dependency in Maven:</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. reactor-test in Maven, in <code>&lt;dependencies&gt;</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If you use the <a href="#getting">BOM</a>, you do not need to specify a <code>&lt;version&gt;</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to add <code>reactor-test</code> as a dependency in Gradle:</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. reactor-test in Gradle, amend the <code>dependencies</code> block</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
   testCompile 'io.projectreactor:reactor-test'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The three main uses of <code>reactor-test</code> are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Testing that a sequence follows a given scenario, step-by-step, with <code>StepVerifier</code>.</p>
</li>
<li>
<p>Producing data in order to test the behavior of downstream operators (including you own
operators) with <code>TestPublisher</code>.</p>
</li>
<li>
<p>In sequences that can go through several alternative <code>Publisher</code> (for example, a chain that uses
<code>switchIfEmpty</code>, probing such a <code>Publisher</code> to ensure it was used (that is, subscribed to).</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_testing_a_scenario_with_stepverifier"><a class="anchor" href="#_testing_a_scenario_with_stepverifier"></a>6.1. Testing a Scenario with <code>StepVerifier</code></h3>
<div class="paragraph">
<p>The most common case for testing a Reactor sequence is to have a <code>Flux</code> or a <code>Mono</code> defined
in your code (for example, it might be returned by a method) and to want to test how it
behaves when subscribed to.</p>
</div>
<div class="paragraph">
<p>This situation translates well to defining a &#8220;test scenario,&#8221; where you define your
expectations in terms of events, step-by-step. You can ask and answer questions such as
the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>What is the next expected event?</p>
</li>
<li>
<p>Do you expect the <code>Flux</code> to emit a particular value?</p>
</li>
<li>
<p>Or maybe to do nothing for the next 300ms?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can express all of that through the <code>StepVerifier</code> API.</p>
</div>
<div class="paragraph">
<p>For instance, you could have the following utility method in your codebase that
decorates a <code>Flux</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public &lt;T&gt; Flux&lt;T&gt; appendBoomError(Flux&lt;T&gt; source) {
  return source.concatWith(Mono.error(new IllegalArgumentException("boom")));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In order to test it, you want to verify the following scenario:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>I expect this <code>Flux</code> to first emit <code>thing1</code>, then emit <code>thing2</code>, and then <strong>produce an
error</strong> with the message, <code>boom</code>. Subscribe and <strong>verify</strong> these expectations.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>In the <code>StepVerifier</code> API, this translates to the following test:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void testAppendBoomError() {
  Flux&lt;String&gt; source = Flux.just("thing1", "thing2"); <i class="conum" data-value="1"></i><b>(1)</b>

  StepVerifier.create( <i class="conum" data-value="2"></i><b>(2)</b>
    appendBoomError(source)) <i class="conum" data-value="3"></i><b>(3)</b>
    .expectNext("thing1") <i class="conum" data-value="4"></i><b>(4)</b>
    .expectNext("thing2")
    .expectErrorMessage("boom") <i class="conum" data-value="5"></i><b>(5)</b>
    .verify(); <i class="conum" data-value="6"></i><b>(6)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Since our method needs a source <code>Flux</code>, define a simple one for testing purposes.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create a <code>StepVerifier</code> builder that wraps and verifies a <code>Flux</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Pass the <code>Flux</code> to be tested (the result of calling our utility method).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The first signal we expect to happen upon subscription is an <code>onNext</code>, with a value
of <code>thing1</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The last signal we expect to happen is a termination of the sequence with an
<code>onError</code>. The exception should have <code>boom</code> as a message.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>It is important to trigger the test by calling <code>verify()</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The API is a builder. You start by creating a <code>StepVerifier</code> and passing the
sequence to be tested. This offers a choice of methods that let you:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Express expectations about the next signals to occur. If any other signal is received
(or the content of the signal does not match the expectation), the whole test fails with
a meaningful <code>AssertionError</code>. For example, you might use <code>expectNext(T&#8230;&#8203;)</code> and
<code>expectNextCount(long)</code>.</p>
</li>
<li>
<p>Consume the next signal. This is used when you want to skip part of the sequence or
when you want to apply a custom <code>assertion</code> on the content of the signal (for example, to
check that there is an <code>onNext</code> event and assert that the emitted item is a list of size
5). For example, you might use <code>consumeNextWith(Consumer&lt;T&gt;)</code>.</p>
</li>
<li>
<p>Take miscellaneous actions such as pausing or running arbitrary code. For example, if
you want to manipulate a test-specific state or context. To that effect, you might use
<code>thenAwait(Duration)</code> and <code>then(Runnable)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For terminal events, the corresponding expectation methods (<code>expectComplete()</code> and
<code>expectError()</code> and all their variants) switch to an API where you cannot express
expectations anymore. In that last step, all you can do is perform some additional
configuration on the <code>StepVerifier</code> and then trigger the verification, often
with <code>verify()</code> or one of its variants.</p>
</div>
<div class="paragraph">
<p>What happens at this point is that the <code>StepVerifier</code> subscribes to the tested <code>Flux</code> or
<code>Mono</code> and plays the sequence, comparing each new signal with the next step in the
scenario. As long as these match, the test is considered a success. As soon as there is a
discrepancy, an <code>AssertionError</code> is thrown.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Remember the <code>verify()</code> step, which triggers the verification. To
help, the API includes a few shortcut methods that combine the terminal expectations with
a call to <code>verify()</code>: <code>verifyComplete()</code>, <code>verifyError()</code>, <code>verifyErrorMessage(String)</code>,
and others.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that, if one of the lambda-based expectations throws an <code>AssertionError</code>, it is
reported as is, failing the test. This is useful for custom assertions.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
By default, the <code>verify()</code> method and derived shortcut methods (<code>verifyThenAssertThat</code>,
<code>verifyComplete()</code>, and so on) have no timeout. They can block indefinitely. You can use
<code>StepVerifier.setDefaultTimeout(Duration)</code> to globally set a timeout for these methods,
or specify one on a per-call basis with <code>verify(Duration)</code>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_better_identifying_test_failures"><a class="anchor" href="#_better_identifying_test_failures"></a>6.1.1. Better Identifying Test Failures</h4>
<div class="paragraph">
<p><code>StepVerifier</code> provides two options to better identify exactly which expectation step caused
a test to fail:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>as(String)</code>: Used after most <code>expect*</code> methods to give a description
to the preceding expectation. If the expectation fails, its error message contains the
description. Terminal expectations and <code>verify</code> cannot be described that way.</p>
</li>
<li>
<p><code>StepVerifierOptions.create().scenarioName(String)</code>: By using <code>StepVerifierOptions</code> to create
your <code>StepVerifier</code>, you can use the <code>scenarioName</code> method to give the whole scenario a
name, which is also used in assertion error messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that, in both cases, the use of the description or name in messages is only guaranteed for
<code>StepVerifier</code> methods that produce their own <code>AssertionError</code> (for example, throwing an exception
manually or through an assertion library in <code>assertNext</code> does not add the description or name to
the error&#8217;s message).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_manipulating_time"><a class="anchor" href="#_manipulating_time"></a>6.2. Manipulating Time</h3>
<div class="paragraph">
<p>You can use <code>StepVerifier</code> with time-based operators to avoid long run times for
corresponding tests. You can do so through the <code>StepVerifier.withVirtualTime</code> builder.</p>
</div>
<div class="paragraph">
<p>It looks like the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(1)))
//... continue expectations here</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This virtual time feature plugs in a custom <code>Scheduler</code> in Reactor&#8217;s <code>Schedulers</code>
factory. Since these timed operators usually use the default <code>Schedulers.parallel()</code>
scheduler, replacing it with a <code>VirtualTimeScheduler</code> does the trick. However, an
important prerequisite is that the operator be instantiated after the virtual time
scheduler has been activated.</p>
</div>
<div class="paragraph">
<p>To increase the chances that this happens correctly, the <code>StepVerifier</code> does not take
a simple <code>Flux</code> as input. <code>withVirtualTime</code> takes a <code>Supplier</code>, which guides you into lazily
creating the instance of the tested flux <em>after</em> having done the scheduler set up.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Take extra care to ensure the <code>Supplier&lt;Publisher&lt;T&gt;&gt;</code> can be used in a lazy
fashion. Otherwise, virtual time is not guaranteed. Especially avoid instantiating the
<code>Flux</code> earlier in the test code and having the <code>Supplier</code> return that variable. Instead,
always instantiate the <code>Flux</code> inside the lambda.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are two expectation methods that deal with time, and they are both valid with or
without virtual time:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thenAwait(Duration)</code>: Pauses the evaluation of steps (allowing a few signals to occur
or delays to run out).</p>
</li>
<li>
<p><code>expectNoEvent(Duration)</code>: Also lets the sequence play out for a given duration but
fails the test if <em>any</em> signal occurs during that time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both methods pause the thread for the given duration in classic mode and advance the
virtual clock instead in virtual mode.</p>
</div>
<div id="tip-expectNoEvent" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>expectNoEvent</code> also considers the <code>subscription</code> as an event. If you use it as a
first step, it usually fails because the subscription signal is detected. Use
<code>expectSubscription().expectNoEvent(duration)</code> instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to quickly evaluate the behavior of our <code>Mono.delay</code> above, we can finish
writing our code as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(1)))
    .expectSubscription() <i class="conum" data-value="1"></i><b>(1)</b>
    .expectNoEvent(Duration.ofDays(1)) <i class="conum" data-value="2"></i><b>(2)</b>
    .expectNext(0L) <i class="conum" data-value="3"></i><b>(3)</b>
    .verifyComplete(); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>See the preceding <a href="#tip-expectNoEvent">tip</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Expect nothing to happen for a full day.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then expect a delay that emits <code>0</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Then expect completion (and trigger the verification).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>We could have used <code>thenAwait(Duration.ofDays(1))</code> above, but <code>expectNoEvent</code> has the
benefit of guaranteeing that nothing happened earlier than it should have.</p>
</div>
<div class="paragraph">
<p>Note that <code>verify()</code> returns a <code>Duration</code> value. This is the real-time duration of the
entire test.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Virtual time is not a silver bullet. All <code>Schedulers</code> are
replaced with the same <code>VirtualTimeScheduler</code>. In some cases, you can lock the
verification process because the virtual clock has not moved forward before an
expectation is expressed, resulting in the expectation waiting on data that can only be
produced by advancing time. In most cases, you need to advance the virtual clock for
sequences to emit. Virtual time also gets very limited with infinite sequences, which
might hog the thread on which both the sequence and its verification run.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_performing_post_execution_assertions_with_stepverifier"><a class="anchor" href="#_performing_post_execution_assertions_with_stepverifier"></a>6.3. Performing Post-execution Assertions with <code>StepVerifier</code></h3>
<div class="paragraph">
<p>After having described the final expectation of your scenario, you can switch to a
complementary assertion API instead of triggering <code>verify()</code>. To do so, use
<code>verifyThenAssertThat()</code> instead.</p>
</div>
<div class="paragraph">
<p><code>verifyThenAssertThat()</code> returns a <code>StepVerifier.Assertions</code> object, which you can use to
assert a few elements of state once the whole scenario has played out successfully
(because it also calls <code>verify()</code>). Typical (albeit advanced) usage is to capture
elements that have been dropped by some operator and assert them (see the section on
<a href="#hooks">Hooks</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_testing_the_context"><a class="anchor" href="#_testing_the_context"></a>6.4. Testing the <code>Context</code></h3>
<div class="paragraph">
<p>For more information about the <code>Context</code>, see <a href="#context">Adding a Context to a Reactive Sequence</a>.</p>
</div>
<div class="paragraph">
<p><code>StepVerifier</code> comes with a couple of expectations around the propagation of a <code>Context</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>expectAccessibleContext</code>: Returns a <code>ContextExpectations</code> object that you can use
to set up expectations on the propagated <code>Context</code>. Be sure to call <code>then()</code> to return
to the set of sequence expectations.</p>
</li>
<li>
<p><code>expectNoAccessibleContext</code>: Sets up an expectation that NO <code>Context</code> can be propagated
up the chain of operators under test. This most likely occurs when the <code>Publisher</code> under
test is not a Reactor one or does not have any operator that can propagate the <code>Context</code>
(for example, a generator source).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, you can associate a test-specific initial <code>Context</code> to a <code>StepVerifier</code> by
using <code>StepVerifierOptions</code> to create the verifier.</p>
</div>
<div class="paragraph">
<p>These features are demonstrated in the following snippet:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(Mono.just(1).map(i -&gt; i + 10),
				StepVerifierOptions.create().withInitialContext(Context.of("thing1", "thing2"))) <i class="conum" data-value="1"></i><b>(1)</b>
		            .expectAccessibleContext() <i class="conum" data-value="2"></i><b>(2)</b>
		            .contains("foo", "bar") <i class="conum" data-value="3"></i><b>(3)</b>
		            .then() <i class="conum" data-value="4"></i><b>(4)</b>
		            .expectNext(11)
		            .verifyComplete(); <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create the <code>StepVerifier</code> by using <code>StepVerifierOptions</code> and pass in an initial <code>Context</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Start setting up expectations about <code>Context</code> propagation. This alone ensures that a
<code>Context</code> was propagated.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>An example of a <code>Context</code>-specific expectation. It must contain value "thing2" for key "thing1".</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We <code>then()</code> switch back to setting up normal expectations on the data.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Let us not forget to <code>verify()</code> the whole set of expectations.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_manually_emitting_with_testpublisher"><a class="anchor" href="#_manually_emitting_with_testpublisher"></a>6.5. Manually Emitting with <code>TestPublisher</code></h3>
<div class="paragraph">
<p>For more advanced test cases, it might be useful to have complete mastery over the source
of data, to trigger finely chosen signals that closely match the particular
situation you want to test.</p>
</div>
<div class="paragraph">
<p>Another situation is when you have implemented your own operator and you want to verify
how it behaves with regards to the Reactive Streams specification, especially if its
source is not well behaved.</p>
</div>
<div class="paragraph">
<p>For both cases, <code>reactor-test</code> offers the <code>TestPublisher</code> class. This is a <code>Publisher&lt;T&gt;</code>
that lets you programmatically trigger various signals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>next(T)</code> and <code>next(T, T&#8230;&#8203;)</code> triggers 1-n <code>onNext</code> signals.</p>
</li>
<li>
<p><code>emit(T&#8230;&#8203;)</code> triggers 1-n <code>onNext</code> signals and does <code>complete()</code>.</p>
</li>
<li>
<p><code>complete()</code> terminates with an <code>onComplete</code> signal.</p>
</li>
<li>
<p><code>error(Throwable)</code> terminates with an <code>onError</code> signal.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can get a well behaved <code>TestPublisher</code> through the <code>create</code> factory method. Also,
you can create a misbehaving <code>TestPublisher</code> by using the <code>createNonCompliant</code> factory
method. The latter takes a value or multiple values from the <code>TestPublisher.Violation</code>
enum. The values define which parts of the specification the publisher can overlook.
These enum values include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>REQUEST_OVERFLOW</code>: Allows <code>next</code> calls to be made despite an insufficient request,
without triggering an <code>IllegalStateException</code>.</p>
</li>
<li>
<p><code>ALLOW_NULL</code>: Allows <code>next</code> calls to be made with a <code>null</code> value without triggering a
<code>NullPointerException</code>.</p>
</li>
<li>
<p><code>CLEANUP_ON_TERMINATE</code>: Allows termination signals to be sent several times in a row.
This includes <code>complete()</code>, <code>error()</code>, and <code>emit()</code>.</p>
</li>
<li>
<p><code>DEFER_CANCELLATION</code>: Allows the <code>TestPublisher</code> to ignore cancellation signals and continue
emitting signals as if the cancellation lost the race against said signals.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, the <code>TestPublisher</code> keeps track of internal state after subscription, which can
be asserted through its various <code>assert*</code> methods.</p>
</div>
<div class="paragraph">
<p>You can use it as a <code>Flux</code> or <code>Mono</code> by using the conversion methods, <code>flux()</code> and
<code>mono()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_checking_the_execution_path_with_publisherprobe"><a class="anchor" href="#_checking_the_execution_path_with_publisherprobe"></a>6.6. Checking the Execution Path with <code>PublisherProbe</code></h3>
<div class="paragraph">
<p>When building complex chains of operators, you could come across cases where
there are several possible execution paths, materialized by distinct sub-sequences.</p>
</div>
<div class="paragraph">
<p>Most of the time, these sub-sequences produce a specific-enough <code>onNext</code> signal
that you can assert that it was executed by looking at the end result.</p>
</div>
<div class="paragraph">
<p>For instance, consider the following method, which builds a chain of operators from a
source and uses a <code>switchIfEmpty</code> to fall back to a particular alternative if the source
is empty:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public Flux&lt;String&gt; processOrFallback(Mono&lt;String&gt; source, Publisher&lt;String&gt; fallback) {
    return source
            .flatMapMany(phrase -&gt; Flux.fromArray(phrase.split("\\s+")))
            .switchIfEmpty(fallback);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can test which logical branch of the switchIfEmpty was used, as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void testSplitPathIsUsed() {
    StepVerifier.create(processOrFallback(Mono.just("just a  phrase with    tabs!"),
            Mono.just("EMPTY_PHRASE")))
                .expectNext("just", "a", "phrase", "with", "tabs!")
                .verifyComplete();
}

@Test
public void testEmptyPathIsUsed() {
    StepVerifier.create(processOrFallback(Mono.empty(), Mono.just("EMPTY_PHRASE")))
                .expectNext("EMPTY_PHRASE")
                .verifyComplete();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>However, think about an example where the method produces a <code>Mono&lt;Void&gt;</code> instead. It waits
for the source to complete, performs an additional task, and completes. If the source
is empty, a fallback <code>Runnable</code>-like task must be performed instead. The following example
shows such a case:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private Mono&lt;String&gt; executeCommand(String command) {
    return Mono.just(command + " DONE");
}

public Mono&lt;Void&gt; processOrFallback(Mono&lt;String&gt; commandSource, Mono&lt;Void&gt; doWhenEmpty) {
    return commandSource
            .flatMap(command -&gt; executeCommand(command).then()) <i class="conum" data-value="1"></i><b>(1)</b>
            .switchIfEmpty(doWhenEmpty); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>then()</code> forgets about the command result. It cares only that it was completed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>How to distinguish between two cases that are both empty sequences?</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>To verify that your <code>processOrFallback</code> method does indeed go through the <code>doWhenEmpty</code> path,
you need to write a bit of boilerplate. Namely you need a <code>Mono&lt;Void&gt;</code> that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Captures the fact that it has been subscribed to.</p>
</li>
<li>
<p>Lets you assert that fact <em>after</em> the whole process has terminated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before version 3.1, you would need to manually maintain one <code>AtomicBoolean</code> per state you
wanted to assert and attach a corresponding <code>doOn*</code> callback to the publisher you wanted
to evaluate. This could be a lot of boilerplate when having to apply this pattern
regularly. Fortunately, 3.1.0 introduced an alternative with <code>PublisherProbe</code>. The
following example shows how to use it:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void testCommandEmptyPathIsUsed() {
    PublisherProbe&lt;Void&gt; probe = PublisherProbe.empty(); <i class="conum" data-value="1"></i><b>(1)</b>

    StepVerifier.create(processOrFallback(Mono.empty(), probe.mono())) <i class="conum" data-value="2"></i><b>(2)</b>
                .verifyComplete();

    probe.assertWasSubscribed(); <i class="conum" data-value="3"></i><b>(3)</b>
    probe.assertWasRequested(); <i class="conum" data-value="4"></i><b>(4)</b>
    probe.assertWasNotCancelled(); <i class="conum" data-value="5"></i><b>(5)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a probe that translates to an empty sequence.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use the probe in place of <code>Mono&lt;Void&gt;</code> by calling <code>probe.mono()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>After completion of the sequence, the probe lets you assert that it was used. You
can check that is was subscribed to&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>&#8230;&#8203;as well as actually requested data&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>&#8230;&#8203;and whether or not it was cancelled.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also use the probe in place of a <code>Flux&lt;T&gt;</code> by calling <code>.flux()</code> instead of
<code>.mono()</code>. For cases where you need to probe an execution path but also need the
probe to emit data, you can wrap any <code>Publisher&lt;T&gt;</code> by using <code>PublisherProbe.of(Publisher)</code>.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/testing.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#testing">Testing</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="debugging"><a class="anchor" href="#debugging"></a>7. Debugging Reactor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Switching from an imperative and synchronous programming paradigm to a reactive and
asynchronous one can sometimes be daunting. One of the steepest steps in the learning
curve is how to analyze and debug when something goes wrong.</p>
</div>
<div class="paragraph">
<p>从命令式和同步编程范例切换到被动和异步编程范例有时会令人生畏。
学习曲线中最陡峭的步骤之一是出现问题时如何进行分析和调试。</p>
</div>
<div class="paragraph">
<p>In the imperative world, debugging is usually pretty straightforward. You can read the
stacktrace and see where the problem originated. Was it entirely a failure
of your code? Did the failure occur in some library code? If so, what part of your code
called the library, potentially passing in improper parameters that ultimately caused the
failure?</p>
</div>
<div class="paragraph">
<p>在命令式世界中，调试通常非常简单。您可以阅读stacktrace并查看问题的根源。这完全是您的代码失败吗？
故障是否发生在某些库代码中？如果是这样，您的代码的哪一部分调用了库，可能会传入不正确的参数，最终导致失败？</p>
</div>
<div class="sect2">
<h3 id="_the_typical_reactor_stack_trace"><a class="anchor" href="#_the_typical_reactor_stack_trace"></a>7.1. The Typical Reactor Stack Trace</h3>
<div class="paragraph">
<p>When you shift to asynchronous code, things can get much more complicated.</p>
</div>
<div class="paragraph">
<p>当您转向异步代码时，事情会变得更加复杂。</p>
</div>
<div class="paragraph">
<p>Consider the following stack trace:</p>
</div>
<div class="paragraph">
<p>考虑以下堆栈跟踪：</p>
</div>
<div class="paragraph">
<div class="title">A typical Reactor stack trace</div>
<p>典型的Reactor堆栈跟踪</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">java.lang.IndexOutOfBoundsException: Source emitted more than one item
	at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:129)
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.tryEmitScalar(FluxFlatMap.java:445)
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onNext(FluxFlatMap.java:379)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)
	at reactor.core.publisher.FluxRange$RangeSubscription.slowPath(FluxRange.java:154)
	at reactor.core.publisher.FluxRange$RangeSubscription.request(FluxRange.java:109)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onSubscribe(FluxFlatMap.java:332)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)
	at reactor.core.publisher.FluxRange.subscribe(FluxRange.java:68)
	at reactor.core.publisher.FluxMapFuseable.subscribe(FluxMapFuseable.java:63)
	at reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:97)
	at reactor.core.publisher.MonoSingle.subscribe(MonoSingle.java:58)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3096)
	at reactor.core.publisher.Mono.subscribeWith(Mono.java:3204)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3090)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3057)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3029)
	at reactor.guide.GuideTests.debuggingCommonStacktrace(GuideTests.java:995)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>There is a lot going on there. We get an <code>IndexOutOfBoundsException</code>, which tells us that
a <code>source emitted more than one item</code>.</p>
</div>
<div class="paragraph">
<p>那里发生了很多事情。我们得到一个IndexOutOfBoundsException，告诉我们一个`source emitted more than one item`.</p>
</div>
<div class="paragraph">
<p>We can probably quickly come to assume that this source is a Flux or a Mono, as confirmed by
the next line, which mentions <code>MonoSingle</code>. So it appears to be some sort of complaint
from a <code>single</code> operator.</p>
</div>
<div class="paragraph">
<p>正如下一行提到的所示，我们可能很快就可以假定此源是Flux或Mono MonoSingle。因此，这似乎是single操作员的某种抱怨。</p>
</div>
<div class="paragraph">
<p>Referring to the Javadoc for the <code>Mono#single</code> operator, we see that <code>single</code> has a contract:
The source must emit exactly one element. It appears we had a source that emitted more
than one and thus violated that contract.</p>
</div>
<div class="paragraph">
<p>参考Mono#single操作符的Javadoc时，我们看到single有一个约定：源必须确切地发出一个元素。看来我们有一个排放源不止一个，因此违反了该合同。</p>
</div>
<div class="paragraph">
<p>Can we dig deeper and identify that source? The following rows are not very helpful. They
take us through the internals of what seems to be a reactive chain, through
multiple calls to <code>subscribe</code> and <code>request</code>.</p>
</div>
<div class="paragraph">
<p>我们可以更深入地挖掘并确定来源吗？以下几行不是很有帮助。
带我们进入似乎是一个reactive 链的内部。进过了多次调用subscribe和request，</p>
</div>
<div class="paragraph">
<p>By skimming over these rows, we can at least start to form a picture of the kind of chain
that went wrong: It seems to involve a <code>MonoSingle</code>, a <code>FluxFlatMap</code>, and a <code>FluxRange</code>
(each gets several rows in the trace, but overall these three classes are involved). So a
<code>range().flatMap().single()</code> chain maybe?</p>
</div>
<div class="paragraph">
<p>通过略读这些行，我们至少可以开始形成一条错误链的图：似乎涉及到MonoSingle，a FluxFlatMap和a FluxRange （每个都在跟踪中得到几行，但总体上涉及这三个类）。
那么range().flatMap().single()也许是一个调用链？</p>
</div>
<div class="paragraph">
<p>But what if we use that pattern a lot in our application? This still does not tell us
much, and simply searching for <code>single</code> is not going to find the problem. Then the last
line refers to some of our code. Finally, we are getting close.</p>
</div>
<div class="paragraph">
<p>但是，如果我们在应用程序中频繁使用该模式怎么办？这仍然不能告诉我们太多，仅搜索single是不会发现问题的。
然后，最后一行引用了我们的一些代码。最后，我们越来越近了。</p>
</div>
<div class="paragraph">
<p>Hold on, though. When we go to the source file, all we see is that a
pre-existing <code>Flux</code> is subscribed to, as follows:</p>
</div>
<div class="paragraph">
<p>等一下。转到源文件时，我们看到 之前的退出的Flux 是已被预订了，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">toDebug.subscribe(System.out::println, Throwable::printStackTrace);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>All of this happened at subscription time, but the <code>Flux</code> itself was not
declared there. Worse, when we go to where the variable is declared, we see the following:</p>
</div>
<div class="paragraph">
<p>所有这些都是在订阅时发生的，但Flux本身并未在此处声明。更糟糕的是，当我们转到声明变量的位置时，会看到以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public Mono&lt;String&gt; toDebug; //please overlook the public class attribute</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The variable is not instantiated where it is declared. We must assume a worst-case
scenario where we find out that there could be a few different code paths that set it in
the application. We remain unsure of which one caused the issue.</p>
</div>
<div class="paragraph">
<p>变量未在声明的地方实例化。
我们必须假设在最坏的情况下，我们发现可能在应用程序中设置了一些不同的代码路径。我们仍然不确定是哪一个引起了问题。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is kind of the Reactor equivalent of a runtime error, as opposed to a
compilation error.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What we want to find out more easily is where the operator was added into the chain -
that is,  where the <code>Flux</code> was declared. We usually refer to that as the &#8220;assembly&#8221; of
the <code>Flux</code>.</p>
</div>
<div class="paragraph">
<p>我们想要更容易发现的是将运算符添加到链中的位置-即Flux声明的位置。我们通常将其称为Flux的“assembly” 。</p>
</div>
</div>
<div class="sect2">
<h3 id="debug-activate"><a class="anchor" href="#debug-activate"></a>7.2. Activating Debug Mode - aka tracebacks</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
this section describes the easiest but also the slowest way to enable
the debugging capabitilies due to the fact that it captures the stacktrace on every operator.
See <a href="#checkpoint-alternative">The <code>checkpoint()</code> Alternative</a> for a more fine grained way of debugging,
and <a href="#reactor-tools-debug">Production-ready Global Debugging</a> for a more advanced and performant global option.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
本节介绍了启用调试功能的最简单但也是最慢的方法，因为它捕获了每个运算符上的stacktrace。
有关更细粒度的调试方法，请参见<a href="#checkpoint-alternative">The <code>checkpoint()</code> Alternative</a>；有关更高级和高性能的全局选项，请参见 <a href="#reactor-tools-debug">Production-ready Global Debugging</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Even though the stacktrace was still able to convey some information for someone with a
bit of experience, we can see that it is not ideal by itself in more advanced cases.</p>
</div>
<div class="paragraph">
<p>即使stacktrace仍然能够为有经验的人传达一些信息，但我们可以看到，在更高级的情况下，它本身并不理想。</p>
</div>
<div class="paragraph">
<p>Fortunately, Reactor comes with  assembly-time instrumentation that is designed for debugging.</p>
</div>
<div class="paragraph">
<p>幸运的是，Reactor带有专为调试而设计的组装时工具。</p>
</div>
<div class="paragraph">
<p>This is done by customizing the <code>Hooks.onOperator</code> hook at application start (or at
least before the incriminated <code>Flux</code> or <code>Mono</code> can be instantiated), as follows:</p>
</div>
<div class="paragraph">
<p>这是通过Hooks.onOperator在应用程序启动时（或至少在包含Flux或Mono可实例化之前）自定义钩子来完成的，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Hooks.onOperatorDebug();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This starts instrumenting the calls to the <code>Flux</code> (and <code>Mono</code>) operator  methods (where
they are assembled into the chain) by wrapping the construction of the operator and
capturing a stack trace there. Since this is done when the operator chain is declared, the
hook should be activated before that, so the safest way is to activate it right at the
start of your application.</p>
</div>
<div class="paragraph">
<p>通过包装操作符的结构并捕获其中的堆栈跟踪信息，开始对Flux（和Mono）操作符方法（将它们组装到链中）的调用进行检测。
由于此操作是在声明操作员链时完成的，因此应在此之前将钩子激活，因此最安全的方法是在应用程序开始时立即将其激活。</p>
</div>
<div class="paragraph">
<p>Later on, if an exception occurs, the failing operator is able to refer to that capture
and append it to the stack trace. We call this captured assembly information a <strong>traceback</strong>.</p>
</div>
<div class="paragraph">
<p>稍后，如果发生异常，则失败的运算符可以引用该捕获并将其附加到堆栈跟踪中。我们将此捕获的程序集信息称为回溯。</p>
</div>
<div class="paragraph">
<p>In the next section, we see how the stack trace differs and how to interpret
that new information.</p>
</div>
<div class="paragraph">
<p>在下一节中，我们将了解堆栈跟踪的不同之处以及如何解释该新信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_reading_a_stack_trace_in_debug_mode"><a class="anchor" href="#_reading_a_stack_trace_in_debug_mode"></a>7.3. Reading a Stack Trace in Debug Mode</h3>
<div class="paragraph">
<p>When we reuse our initial example but activate the <code>operatorStacktrace</code> debug feature,
the stack trace is as follows:</p>
</div>
<div class="paragraph">
<p>当我们重用最初的示例但激活operatorStacktrace调试功能时，堆栈跟踪如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">java.lang.IndexOutOfBoundsException: Source emitted more than one item
	at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:129)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:375) <i class="conum" data-value="1"></i><b>(1)</b>
...
<i class="conum" data-value="2"></i><b>(2)</b>
...
	at reactor.core.publisher.Mono.subscribeWith(Mono.java:3204)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3090)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3057)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3029)
	at reactor.guide.GuideTests.debuggingActivated(GuideTests.java:1000)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: <i class="conum" data-value="3"></i><b>(3)</b>
Assembly trace from producer [reactor.core.publisher.MonoSingle] : <i class="conum" data-value="4"></i><b>(4)</b>
	reactor.core.publisher.Flux.single(Flux.java:6676)
	reactor.guide.GuideTests.scatterAndGather(GuideTests.java:949)
	reactor.guide.GuideTests.populateDebug(GuideTests.java:962)
	org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	org.junit.rules.RunRules.evaluate(RunRules.java:20)
Error has been observed by the following operator(s): <i class="conum" data-value="5"></i><b>(5)</b>
	|_	Flux.single ⇢ reactor.guide.GuideTests.scatterAndGather(GuideTests.java:949) <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们看到包装操作符捕获堆栈。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>除此之外，堆栈跟踪的第一部分在大多数情况下仍然相同，显示了操作员内部的一些内容（因此我们在此处删除了一些代码段）.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>这是回溯开始出现的地方.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>首先，我们获得一些有关操作员组装位置的详细信息.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>当错误通过操作员链从头到尾（错误站点到订阅站点）传播时，我们还可以追溯到该错误.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>提及错误的每个操作符均会与用户类别和使用错误的行一起提及</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The captured stack trace is appended to the original error as a
suppressed <code>OnAssemblyException</code>. There are two parts to it, but the first section is the
most interesting. It shows the path of construction for the operator that triggered the
exception. Here, it shows that the <code>single</code> that caused our issue was created in the
<code>scatterAndGather</code> method, itself called from a <code>populateDebug</code> method that got executed
through JUnit.</p>
</div>
<div class="paragraph">
<p>捕获的堆栈跟踪将被抑制后附加到原始错误OnAssemblyException。它有两个部分，但是第一部分是最有趣的。它显示了触发异常的操作员的构造路径。
在这里，它表明single导致我们问题的是在scatterAndGather方法中创建的，该 方法本身是populateDebug通过JUnit执行的方法调用的。</p>
</div>
<div class="paragraph">
<p>Now that we are armed with enough information to find the culprit, we can have
a meaningful look at that <code>scatterAndGather</code> method:</p>
</div>
<div class="paragraph">
<p>既然我们已经掌握了足够的信息来找到罪魁祸首，我们就可以对该scatterAndGather方法进行有自信的排查：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private Mono&lt;String&gt; scatterAndGather(Flux&lt;String&gt; urls) {
    return urls.flatMap(url -&gt; doRequest(url))
           .single(); <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Sure enough, here is our <code>single</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Now we can see what the root cause of the error was a <code>flatMap</code> that performs
several HTTP calls to a few URLs but that is chained with <code>single</code>, which is too
restrictive. After a short <code>git blame</code> and a quick discussion with the author of
that line, we find out he meant to use the less restrictive <code>take(1)</code> instead.</p>
</div>
<div class="paragraph">
<p>现在，我们可以看到错误的根本原因是flatMap它对几个URL执行了几次HTTP调用，但是与链接在一起single，这太过严格了。
在git blame与该行的作者进行简短简短的讨论之后，我们发现他的意思是使用限制性较小的take(1)标签。</p>
</div>
<div class="paragraph">
<p>We have solved our problem.</p>
</div>
<div class="paragraph">
<p>我们已经解决了我们的问题。</p>
</div>
<div class="paragraph">
<p>Now consider the following line in the stack trace:</p>
</div>
<div class="paragraph">
<p>现在考虑堆栈跟踪中的以下行：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Error has been observed by the following operator(s):</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That second part of the debug stack trace was not necessarily interesting in
this particular example, because the error was actually happening in the last
operator in the chain (the one closest to <code>subscribe</code>). Considering another
example might make it more clear:</p>
</div>
<div class="paragraph">
<p>在此特定示例中，调试堆栈跟踪的第二部分不一定是有趣的，因为该错误实际上发生在链中的最后一个运算符中（最接近的那个subscribe）。
考虑另一个示例可能会更清楚：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">FakeRepository.findAllUserByName(Flux.just("pedro", "simon", "stephane"))
              .transform(FakeUtils1.applyFilters)
              .transform(FakeUtils2.enrichUser)
              .blockLast();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Now imagine that, inside <code>findAllUserByName</code>, there is a <code>map</code> that fails. Here,
we would see the following final traceback:</p>
</div>
<div class="paragraph">
<p>现在想象一下，在内部findAllUserByName，有一个map失败。在这里，我们将看到以下最终回溯：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Error has been observed by the following operator(s):
	|_	Flux.map ⇢ reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:27)
	|_	Flux.map ⇢ reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:28)
	|_	Flux.filter ⇢ reactor.guide.FakeUtils1.lambda$static$1(FakeUtils1.java:29)
	|_	Flux.transform ⇢ reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:40)
	|_	Flux.elapsed ⇢ reactor.guide.FakeUtils2.lambda$static$0(FakeUtils2.java:30)
	|_	Flux.transform ⇢ reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:41)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This corresponds to the section of the chain of operators that gets notified of the error:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The exception originates in the first <code>map</code>.</p>
</li>
<li>
<p>It is seen by a second <code>map</code> (both in fact correspond to the <code>findAllUserByName</code>
method).</p>
</li>
<li>
<p>It is then seen by a <code>filter</code> and a <code>transform</code>, which indicate that part of the chain
is constructed by a reusable transformation function (here, the <code>applyFilters</code> utility
method).</p>
</li>
<li>
<p>Finally, it is seen by an <code>elapsed</code> and a <code>transform</code>. Once again, <code>elapsed</code> is applied
by the transformation function of that second transform.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这对应于操作员链中获得该错误通知的部分：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>异常起源于第一个map。</p>
</li>
<li>
<p>一秒钟就可以看到它map（两者实际上都对应于该findAllUserByName 方法）。</p>
</li>
<li>
<p>然后通过a filter和a 看到transform，这表明链的一部分是由可重用的转换函数（此处为applyFiltersUtility方法）构造的。</p>
</li>
<li>
<p>最后，由elapsed和看到transform。再次elapsed由第二个转换的转换函数应用。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
As tracebacks are appended to original errors as suppressed exceptions, this can somewhat
interfere with another type of exception that uses this mechanism: composite exceptions.
Such exceptions can be created directly via <code>Exceptions.multiple(Throwable&#8230;&#8203;)</code>, or by some
operators that might join multiple erroring sources (like <code>Flux#flatMapDelayError</code>). They
can be unwrapped into a <code>List</code> via <code>Exceptions.unwrapMultiple(Throwable)</code>, in which case the traceback
would be considered a component of the composite and be part of the returned <code>List</code>.
If that is somehow not desirable, tracebacks can be identified thanks to <code>Exceptions.isTraceback(Throwable)</code>
check, and excluded from such an unwrap by using <code>Exceptions.unwrapMultipleExcludingTracebacks(Throwable)</code>
instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We deal with a form of instrumentation here, and creating a stack trace is costly. That
is why this debugging feature should only be activated in a controlled manner, as a last
resort.</p>
</div>
<div class="paragraph">
<p>我们在这里处理一种形式的检测，并且创建堆栈跟踪非常昂贵。这就是为什么只能以可控制的方式激活此调试功能的原因。</p>
</div>
<div class="sect3">
<h4 id="checkpoint-alternative"><a class="anchor" href="#checkpoint-alternative"></a>7.3.1. The <code>checkpoint()</code> Alternative</h4>
<div class="paragraph">
<p>The debug mode is global and affects every single operator assembled into a <code>Flux</code> or a
<code>Mono</code> inside the application. This has the benefit of allowing after-the-fact
debugging: Whatever the error, we can obtain additional information to debug it.</p>
</div>
<div class="paragraph">
<p>调试模式是全局的，会影响组装到应用程序内部Flux或 Mono内部的每个操作员。
这样做的好处是可以进行事后调试：无论发生什么错误，我们都可以获取其他信息来对其进行调试。</p>
</div>
<div class="paragraph">
<p>As we saw earlier, this global knowledge comes at the cost of an impact on performance
(due to the number of populated stack traces). That cost can be reduced if we have an
idea of likely problematic operators. However, we usually do not know which operators are
likely to be problematic unless we observed an error in the wild, saw we were missing
assembly information, and then modified the code to activate assembly tracking, hoping to
observe the same error again.</p>
</div>
<div class="paragraph">
<p>正如我们前面所看到的，这种全局性知识是以影响性能为代价的（由于填充的堆栈跟踪的数量）。如果我们知道有问题的操作符，有可能降低消耗成本。
但是，通常我们不知道哪个运算符可能有问题，除非我们在野外观察到错误，看到我们缺少程序集信息，然后修改代码以激活程序集跟踪，希望再次观察到相同的错误。</p>
</div>
<div class="paragraph">
<p>In that scenario, we have to switch into debugging mode and make preparations in order to
better observe a second occurrence of the error, this time capturing all the additional
information.</p>
</div>
<div class="paragraph">
<p>在这种情况下，我们必须切换到调试模式并进行准备，以便更好地观察第二次出现错误，这次捕获了所有其他信息。</p>
</div>
<div class="paragraph">
<p>If you can identify reactive chains that you assemble in your application for which
serviceability is critical, you can achieve a mix of both techniques with the
<code>checkpoint()</code> operator.</p>
</div>
<div class="paragraph">
<p>如果您可以确定在应用程序中组装的对可维护性至关重要的反应式链，则可以与checkpoint()操作员一起实现这两种技术的混合 。</p>
</div>
<div class="paragraph">
<p>You can chain this operator into a method chain. The <code>checkpoint</code> operator works like the
hook version but only for its link of that particular chain.</p>
</div>
<div class="paragraph">
<p>您可以将此运算符链接到方法链中。该checkpoint运算符的工作方式类似于钩版本，但仅针对其特定链的链接</p>
</div>
<div class="paragraph">
<p>There is also a <code>checkpoint(String)</code> variant that lets you add a unique <code>String</code> identifier
to the assembly traceback. This way, the stack trace is omitted and you rely on the
description to identify the assembly site. <code>checkpoint(String)</code> imposes less processing
cost than a regular <code>checkpoint</code>.</p>
</div>
<div class="paragraph">
<p>还有一个checkpoint(String)变体，可让您String向程序集追溯添加唯一标识符。
这样，将忽略堆栈跟踪，而您依靠描述来标识组装位置。checkpoint(String)比普通的checkpoint处理成本更低。</p>
</div>
<div class="paragraph">
<p><code>checkpoint(String)</code> includes &#8220;light&#8221; in its output (which can be handy when
searching), as shown in the following example:</p>
</div>
<div class="paragraph">
<p>checkpoint(String) 在其输出中包括“light”（在搜索时可以方便使用），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>...
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:
Assembly site of producer [reactor.core.publisher.ParallelSource] is identified by light checkpoint [light checkpoint identifier].</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Last but not least, if you want to add a more generic description to the checkpoint but
still rely on the stack trace mechanism to identify the assembly site, you can force that
behavior by using the <code>checkpoint("description", true)</code> version. We are now back to the
initial message for the traceback, augmented with a <code>description</code>, as shown in the
following example:</p>
</div>
<div class="paragraph">
<p>最后但并非最不重要的一点是，如果您想向检查点添加更通用的描述，但仍依靠堆栈跟踪机制来标识组装站点，则可以通过使用checkpoint("description", true)版本来强制执行该行为。
现在，我们返回到用于追溯的初始消息，并以进行了扩展description，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] : <i class="conum" data-value="1"></i><b>(1)</b>
	reactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:215)
	reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)
Error has been observed by the following operator(s):
	|_	ParallelFlux.checkpoint ⇢ reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>descriptionCorrelation1234</code> is the description provided in the <code>checkpoint</code>. 	descriptionCorrelation1234是中提供的说明checkpoint。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The description could be a static identifier or user-readable description or a wider
correlation ID (for instance, coming from a header in the case of an HTTP request).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When both global debugging and local <code>checkpoint()</code> are enabled, checkpointed
snapshot stacks are appended as suppressed error output after the observing operator
graph and following the same declarative order.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactor-tools-debug"><a class="anchor" href="#reactor-tools-debug"></a>7.4. Production-ready Global Debugging</h3>
<div class="paragraph">
<p>Project Reactor comes with a separate Java Agent that instruments your code and adds
debugging info without paying the cost of capturing the stacktrace on every operator call.
The behaviour is very similar to <a href="#debug-activate">Activating Debug Mode - aka tracebacks</a>, but without the runtime performance overhead.</p>
</div>
<div class="paragraph">
<p>Project Reactor带有一个单独的Java代理，可对您的代码进行检测并添加调试信息，而无需话费每次操作调用时捕获stacktrace的消耗。
该行为与 <a href="#debug-activate">Activating Debug Mode - aka tracebacks</a>（也称为回溯）非常相似，但没有运行时性能开销。</p>
</div>
<div class="paragraph">
<p>To use it in your app, you must add it as a dependency.</p>
</div>
<div class="paragraph">
<p>要在您的应用程序中使用它，必须将其添加为依赖项。</p>
</div>
<div class="paragraph">
<p>The following example shows how to add <code>reactor-tools</code> as a dependency in Maven:</p>
</div>
<div class="paragraph">
<p>下面的示例显示如何reactor-tools在Maven中添加为依赖项：</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. reactor-tools in Maven, in <code>&lt;dependencies&gt;</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-tools&lt;/artifactId&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If you use the <a href="#getting">BOM</a>, you do not need to specify a <code>&lt;version&gt;</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to add <code>reactor-tools</code> as a dependency in Gradle:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. reactor-tools in Gradle, amend the <code>dependencies</code> block</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
   compile 'io.projectreactor:reactor-tools'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It also needs to be explicitly initialized with:</p>
</div>
<div class="paragraph">
<p>还需要使用以下命令显式初始化它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ReactorDebugAgent.init();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Since the implementation will instrument your classes when they are loaded,
the best place to put it is before everything else in your main(String[]) methood:
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
由于该实现将在加载类时对它们进行检测，因此放置它的最佳位置是在main（String []）方法中的所有其他内容之前：
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    ReactorDebugAgent.init();
    SpringApplication.run(Application.class, args);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You may also re-process existing classes if you cannot run the init eagerly (e.g. in the tests):</p>
</div>
<div class="paragraph">
<p>如果您不能急于运行init（例如在测试中），也可以重新处理现有的类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ReactorDebugAgent.init();
ReactorDebugAgent.processExistingClasses();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Be aware that the re-processing takes a couple of seconds due to the need to iterate over
all loaded classes and apply the transformation.
Use it only if you see that some call-sites are not instrumented.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
请注意，由于需要遍历所有已加载的类并应用转换，因此重新处理需要花费几秒钟的时间。仅当看到某些呼叫站点没有检测到时，才使用它。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_limitations"><a class="anchor" href="#_limitations"></a>7.4.1. Limitations</h4>
<div class="paragraph">
<p><code>ReactorDebugAgent</code> is implemented as a Java Agent and uses <a href="https://bytebuddy.net/#/">ByteBuddy</a>
to perform the self-attach.
Self-attach may not work on some JVMs, please refer to ByteBuddy&#8217;s documentation for more details.</p>
</div>
<div class="paragraph">
<p>ReactorDebugAgent作为Java代理实现，并使用ByteBuddy 进行自我附加。自连接可能不适用于某些JVM，请参阅ByteBuddy的文档以获取更多详细信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_logging_a_sequence"><a class="anchor" href="#_logging_a_sequence"></a>7.5. Logging a Sequence</h3>
<div class="paragraph">
<p>In addition to stack trace debugging and analysis, another powerful tool to have in your
toolkit is the ability to trace and log events in an asynchronous sequence.</p>
</div>
<div class="paragraph">
<p>除了堆栈跟踪调试和分析之外，工具包中另一个强大的工具是能够以异步顺序跟踪和记录事件。</p>
</div>
<div class="paragraph">
<p>The <code>log()</code> operator can do just that. Chained inside a sequence, it peeks at every
event of the <code>Flux</code> or <code>Mono</code> upstream of it (including <code>onNext</code>, <code>onError</code>, and
<code>onComplete</code> as well as subscriptions, cancellations, and requests).</p>
</div>
<div class="literalblock">
<div class="content">
<pre>log()操作符可以做到这一点。序列内部链的，它在偷窥的每个在Flux或Mono事件上游的事件（包括onNext，onError，和 onComplete以及订阅，取消和请求）。</pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A note on logging implementation</div>
<div class="paragraph">
<p>The <code>log</code> operator uses the <code>Loggers</code> utility class, which picks up common logging
frameworks such as Log4J and Logback through <code>SLF4J</code> and defaults to logging to the
console if SLF4J is unavailable.</p>
</div>
<div class="paragraph">
<p>这个log操作者使用Loggers工具类，其拾取通过共同日志框架如Log4J的和的logback SLF4J，缺省值为登录到控制台如果SLF4J不可用。</p>
</div>
<div class="paragraph">
<p>The console fallback uses <code>System.err</code> for the <code>WARN</code> and <code>ERROR</code> log levels and
<code>System.out</code> for everything else.</p>
</div>
<div class="paragraph">
<p>控制台回调System.err用于WARN和ERROR日志级别以及 System.out其他所有情况。</p>
</div>
<div class="paragraph">
<p>If you prefer a JDK <code>java.util.logging</code> fallback, as in 3.0.x, you can get it by setting
the <code>reactor.logging.fallback</code> system property to <code>JDK</code>.</p>
</div>
<div class="paragraph">
<p>如果您喜欢java.util.logging在JDK3.0.x中使用，则可以通过将reactor.logging.fallbacksy JDK stem属性设置为来获得它。</p>
</div>
<div class="paragraph">
<p>In all cases, when logging in production <strong>you should take care to configure the
underlying logging framework to use its most asynchronous and non-blocking approach</strong>&#8201;&#8212;&#8201;for instance, an <code>AsyncAppender</code> in Logback or <code>AsyncLogger</code> in Log4j 2.</p>
</div>
<div class="paragraph">
<p>在所有情况下，在生产环境中登录时，都应谨慎配置底层日志记录框架，以使用其最异步和非阻塞的方法  ，
例如，AsyncAppender在Logback 或 AsyncLogger 在 Log4j2中。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>For instance, suppose we have Logback activated and configured and a chain like
<code>range(1,10).take(3)</code>. By placing a <code>log()</code> before the <code>take</code>, we can get some
insight into how it works and what kind of events it propagates upstream to the range,
as the following example shows:</p>
</div>
<div class="paragraph">
<p>例如，假设我们已激活并配置了Logback以及类似的链 range(1,10).take(3)。
通过在take之前放置log()，我们可以深入了解其工作原理以及它将向上游传播到范围的事件的种类，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; flux = Flux.range(1, 10)
                         .log()
                         .take(3);
flux.subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This prints out the following (through the logger&#8217;s console appender):</p>
</div>
<div class="paragraph">
<p>这将打印出以下内容（通过记录器的控制台附加）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>10:45:20.200 [main] INFO  reactor.Flux.Range.1 - | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription) <i class="conum" data-value="1"></i><b>(1)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | request(unbounded) <i class="conum" data-value="2"></i><b>(2)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(1) <i class="conum" data-value="3"></i><b>(3)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(2)
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(3)
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | cancel() <i class="conum" data-value="4"></i><b>(4)</b></pre>
</div>
</div>
<div class="paragraph">
<p>Here, in addition to the logger&#8217;s own formatter (time, thread, level, message), the
<code>log()</code> operator outputs a few things in its own format:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>reactor.Flux.Range.1</code> is an automatic category for the log, in case you use the
operator several times in a chain. It lets you distinguish which operator&#8217;s events
are logged (in this case, the <code>range</code>). You can overwrite the identifier with your own
custom category by using the <code>log(String)</code> method signature. After a few separating
characters, the actual event gets printed. Here, we get an <code>onSubscribe</code> call, a
<code>request</code> call, three <code>onNext</code> calls, and a <code>cancel</code> call. For the first line,
<code>onSubscribe</code>, we get the implementation of the <code>Subscriber</code>, which usually corresponds
to the operator-specific implementation. Between square brackets, we get additional
information, including whether the operator can be automatically optimized through
synchronous or asynchronous fusion.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>On the second line, we can see that an unbounded request was propagated up from
downstream.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Then the range sends three values in a row.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>On the last line, we see <code>cancel()</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The last line, (4), is the most interesting. We can see the <code>take</code> in action there. It
operates by cutting the sequence short after it has seen enough elements emitted. In
short, <code>take()</code> causes the source to <code>cancel()</code> once it has emitted the user-requested
amount.</p>
</div>
<div class="paragraph">
<p>最后一行（4）是最有趣的。我们可以take在那里看到实际的效果。
在看到足够多的元素发射之后，它会通过缩短序列来进行操作。简而言之，take()使源转变为cancel()的原因是让源发送完一次用户请求的数量。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/debugging.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#debugging">Debugging Reactor</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="metrics"><a class="anchor" href="#metrics"></a>8. Exposing Reactor metrics</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Project Reactor is a library designed for performance and better utilization of resources.
But to truly understand the performance of a system, it is best to be able to monitor its various components.</p>
</div>
<div class="paragraph">
<p>This is why Reactor provides a built-in integration with <a href="https://micrometer.io">Micrometer</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If Micrometer is not on the classpath, metrics will be a no-op.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_scheduler_metrics"><a class="anchor" href="#_scheduler_metrics"></a>8.1. Scheduler metrics</h3>
<div class="paragraph">
<p>Every async operation in Reactor is done via the Scheduler abstraction described in <a href="#schedulers">Threading and Schedulers</a>.
This is why it is important to monitor your schedulers, watch out for key metrics that start to look suspicious and react accordingly.</p>
</div>
<div class="paragraph">
<p>To enable scheduler metrics, you will need to use the following method:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Schedulers.enableMetrics();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The instrumentation is performed when a scheduler is created. It is recommended to call this method as early as possible.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you&#8217;re using Spring Boot, it is a good idea to place the invocation before <code>SpringApplication.run(Application.class, args)</code> call.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once scheduler metrics are enabled and provided it is on the classpath, Reactor will use Micrometer&#8217;s support for instrumenting the executors that back most schedulers.</p>
</div>
<div class="paragraph">
<p>Please refer to <a href="http://micrometer.io/docs/ref/jvm">Micrometer&#8217;s documentation</a> for the exposed metrics, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>executor_active_threads</p>
</li>
<li>
<p>executor_completed_tasks_total</p>
</li>
<li>
<p>executor_pool_size_threads</p>
</li>
<li>
<p>executor_queued_tasks</p>
</li>
<li>
<p>executor_secounds_{count, max, sum}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since one scheduler may have multiple executors, every executor metric has a <code>reactor_scheduler_id</code> tag.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Grafana + Prometheus users can use <a href="https://raw.githubusercontent.com/reactor/reactor-monitoring-demo/master/dashboards/schedulers.json">a pre-built dashboard</a> which includes panels for threads, completed tasks, task queues and other handy metrics.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_publisher_metrics"><a class="anchor" href="#_publisher_metrics"></a>8.2. Publisher metrics</h3>
<div class="paragraph">
<p>Sometimes it is useful to be able to record metrics at some stage in your reactive pipeline.</p>
</div>
<div class="paragraph">
<p>One way to do it would be to manually push the values to your metrics backend of choice.
Another option would be to use Reactor&#8217;s built-in metrics integration for <code>Flux</code>/<code>Mono</code> and interpret them.</p>
</div>
<div class="paragraph">
<p>Consider the following pipeline:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">listenToEvents()
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To enable the metrics for this source <code>Flux</code> (returned from <code>listenToEvents()</code>), we need to give it a name and turn on the metrics collecting:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">listenToEvents()
    .name("events") <i class="conum" data-value="1"></i><b>(1)</b>
    .metrics() <i class="conum" data-value="2"></i><b>(2)</b>
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Every metric at this stage will be identified as "events".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Flux#metrics</code> operator enables the reporting of metrics and uses the last known name up in the pipeline.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Just adding these two operators will expose a whole bunch of useful metrics!</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">metric name</th>
<th class="tableblock halign-left valign-top">type</th>
<th class="tableblock halign-left valign-top">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor.subscribed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counts how many Reactor sequences have been subscribed to</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor.malformed.source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counts the number of events received from a malformed source (ie an onNext after an onComplete)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor.requested</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DistributionSummary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counts the amount requested to a named Flux by all subscribers, until at least one requests an unbounded amount</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor.onNext.delay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Measures delays between onNext signals (or between onSubscribe and first onNext)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor.flow.duration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Times the duration elapsed between a subscription and the termination or cancellation of the sequence. A status tag is added to specify what event caused the timer to end (<code>onComplete</code>, <code>onError</code>, <code>cancel</code>).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Want to know how many times your event processing has restarted due to some error? Read <code>reactor.subscribed</code>, because <code>retry()</code> operator will re-subscribe to the source publisher on error.</p>
</div>
<div class="paragraph">
<p>Interested in "events per second" metric? Measure the rate of <code>reactor.onNext.delay</code> 's count.</p>
</div>
<div class="paragraph">
<p>Want to be alerted when the listener throws an error? <code>reactor.flow.duration</code> with <code>status=error</code> tag is your friend.</p>
</div>
<div class="sect3">
<h4 id="_common_tags"><a class="anchor" href="#_common_tags"></a>8.2.1. Common tags</h4>
<div class="paragraph">
<p>Every metric will have the following tags in common:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">tag name</th>
<th class="tableblock halign-left valign-top">description</th>
<th class="tableblock halign-left valign-top">example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Publisher&#8217;s type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"Mono"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">flow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">current flow&#8217;s name, set by <code>.name()</code> operator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"events"</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_custom_tags"><a class="anchor" href="#_custom_tags"></a>8.2.2. Custom tags</h4>
<div class="paragraph">
<p>Users are allowed to add custom tags to their reactive chains:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">listenToEvents()
    .tag("source", "kafka") <i class="conum" data-value="1"></i><b>(1)</b>
    .name("events")
    .metrics() <i class="conum" data-value="2"></i><b>(2)</b>
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set a custom tag "source" to value "kafka".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>All reported metrics will have <code>source=kafka</code> tag assigned in addition to the common tags described above.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/metrics.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#metrics">Exposing Reactor metrics</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced"><a class="anchor" href="#advanced"></a>9. Advanced Features and Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers advanced features and concepts of Reactor, including the following:</p>
</div>
<div class="paragraph">
<p>本章介绍了Reactor的高级功能和概念，其中包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#advanced-mutualizing-operator-usage">Mutualizing Operator Usage</a></p>
</li>
<li>
<p><a href="#reactor.hotCold">Hot Versus Cold</a></p>
</li>
<li>
<p><a href="#advanced-broadcast-multiple-subscribers-connectableflux">Broadcasting to Multiple Subscribers with <code>ConnectableFlux</code></a></p>
</li>
<li>
<p><a href="#advanced-three-sorts-batching">Three Sorts of Batching</a></p>
</li>
<li>
<p><a href="#advanced-parallelizing-parralelflux">Parallelizing Work with <code>ParallelFlux</code></a></p>
</li>
<li>
<p><a href="#scheduler-factory">Replacing Default <code>Schedulers</code></a></p>
</li>
<li>
<p><a href="#hooks">Using Global Hooks</a></p>
</li>
<li>
<p><a href="#context">Adding a Context to a Reactive Sequence</a></p>
</li>
<li>
<p><a href="#null-safety">Null Safety</a></p>
</li>
<li>
<p><a href="#cleanup">Dealing with Objects that Need Cleanup</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="advanced-mutualizing-operator-usage"><a class="anchor" href="#advanced-mutualizing-operator-usage"></a>9.1. Mutualizing Operator Usage</h3>
<div class="paragraph">
<p>From a clean-code perspective, code reuse is generally a good thing. Reactor offers a few
patterns that can help you reuse and mutualize code, notably for operators or combinations
of operators that you might want to apply regularly in your codebase. If you think of a
chain of operators as a recipe, you can create a &#8220;cookbook&#8221; of operator recipes.</p>
</div>
<div class="paragraph">
<p>从干净代码的角度来看，代码重用通常是一件好事。Reactor提供了一些模式，可以帮助您重用和互用代码，特别是对于您可能希望在代码库中定期应用的运算符或运算符组合。
如果您将一连串的操作符视为配方，则可以创建一个“菜谱”操作符配方。</p>
</div>
<div class="sect3">
<h4 id="_using_the_transform_operator"><a class="anchor" href="#_using_the_transform_operator"></a>9.1.1. Using the <code>transform</code> Operator</h4>
<div class="paragraph">
<p>The <code>transform</code> operator lets you encapsulate a piece of an operator chain into a
function. That function is applied to an original operator chain at assembly time to
augment it with the encapsulated operators. Doing so applies the same operations to all
the subscribers of a sequence and is basically equivalent to chaining the operators
directly. The following code shows an example:</p>
</div>
<div class="paragraph">
<p>这个transform操作可让您封装了一块操作链成一个函数。该功能在组装时应用于原始运算符链，以使用封装的运算符进行扩充。这样做会将相同的操作应用于序列的所有订户，并且基本上等效于直接链接运算符。以下代码显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; filterAndMap =
f -&gt; f.filter(color -&gt; !color.equals("orange"))
      .map(String::toUpperCase);

Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
	.doOnNext(System.out::println)
	.transform(filterAndMap)
	.subscribe(d -&gt; System.out.println("Subscriber to Transformed MapAndFilter: "+d));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following image shows how the <code>transform</code> operator encapsulates flows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/gs-transform.png" alt="Transform Operator : encapsulate flows">
</div>
</div>
<div class="paragraph">
<p>The preceding example produces the following output:</p>
</div>
<div class="paragraph">
<p>前面的示例产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>blue
Subscriber to Transformed MapAndFilter: BLUE
green
Subscriber to Transformed MapAndFilter: GREEN
orange
purple
Subscriber to Transformed MapAndFilter: PURPLE</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_transformdeferred_operator"><a class="anchor" href="#_using_the_transformdeferred_operator"></a>9.1.2. Using the <code>transformDeferred</code> Operator</h4>
<div class="paragraph">
<p>The <code>transformDeferred</code> operator is similar to <code>transform</code> and also lets you encapsulate operators
in a function. The major difference is that this function is applied to the original
sequence <em>on a per-subscriber basis</em>. It means that the function can actually produce a
different operator chain for each subscription (by maintaining some state). The
following code shows an example:</p>
</div>
<div class="paragraph">
<p>transformDeferred运算符与transform类似，而且也可以让你在一个函数内封装运算符。主要区别在于，此功能按每个订阅者应用于原始序列。
这意味着该函数实际上可以为每个订阅者生成一个不同的运算符链（通过维护某种状态）。以下代码显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AtomicInteger ai = new AtomicInteger();
Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; filterAndMap = f -&gt; {
	if (ai.incrementAndGet() == 1) {
return f.filter(color -&gt; !color.equals("orange"))
        .map(String::toUpperCase);
	}
	return f.filter(color -&gt; !color.equals("purple"))
	        .map(String::toUpperCase);
};

Flux&lt;String&gt; composedFlux =
Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
    .doOnNext(System.out::println)
    .transformDeferred(filterAndMap);

composedFlux.subscribe(d -&gt; System.out.println("Subscriber 1 to Composed MapAndFilter :"+d));
composedFlux.subscribe(d -&gt; System.out.println("Subscriber 2 to Composed MapAndFilter: "+d));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following image shows how the <code>transformDeferred</code> operator works with per-subscriber transformations:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/gs-compose.png" alt="Compose Operator : Per Subscriber transformation">
</div>
</div>
<div class="paragraph">
<p>The preceding example produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>blue
Subscriber 1 to Composed MapAndFilter :BLUE
green
Subscriber 1 to Composed MapAndFilter :GREEN
orange
purple
Subscriber 1 to Composed MapAndFilter :PURPLE
blue
Subscriber 2 to Composed MapAndFilter: BLUE
green
Subscriber 2 to Composed MapAndFilter: GREEN
orange
Subscriber 2 to Composed MapAndFilter: ORANGE
purple</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactor.hotCold"><a class="anchor" href="#reactor.hotCold"></a>9.2. Hot Versus Cold</h3>
<div class="paragraph">
<p>So far, we have considered that all <code>Flux</code> (and <code>Mono</code>) are the same: They all represent
an asynchronous sequence of data, and nothing happens before you subscribe.</p>
</div>
<div class="paragraph">
<p>到目前为止，我们已经考虑到所有Flux（和Mono）都是相同的：它们都代表异步的数据序列，在您订阅之前什么也没有发生。</p>
</div>
<div class="paragraph">
<p>Really, though, there are two broad families of publishers: hot and cold.</p>
</div>
<div class="paragraph">
<p>不过，实际上，有两个广泛的发布者家族：热门和冷门。</p>
</div>
<div class="paragraph">
<p>The earlier description applies to the cold family of publishers. They generate data anew
for each subscription. If no subscription is created, data never gets generated.</p>
</div>
<div class="paragraph">
<p>较早的描述适用于冷门的发布者系列。它们为每个订阅重新生成数据。如果没有创建订阅，则永远不会生成数据。</p>
</div>
<div class="paragraph">
<p>Think of an HTTP request: Each new subscriber triggers an HTTP call, but no call is
made if no one is interested in the result.</p>
</div>
<div class="paragraph">
<p>考虑一下HTTP请求：每个新订户都会触发HTTP调用，但是如果没有人对结果感兴趣，则不会进行任何调用。</p>
</div>
<div class="paragraph">
<p>Hot publishers, on the other hand, do not depend on any number of subscribers. They
might start publishing data right away and would continue doing so whenever a new
<code>Subscriber</code> comes in (in which case, the subscriber would see only new elements emitted
<em>after</em> it subscribed). For hot publishers, <em>something</em> does indeed happen before you
subscribe.</p>
</div>
<div class="paragraph">
<p>另一方面，热门发布者不依赖任何数量的订阅者。他们可能会开始发布数据的时候了，并会继续这样做，每当有新 Subscriber进来（在这种情况下，用户会看到其预约后发射的新元素）。
对于热门发布者，在您订阅之前确实发生了某些事情。</p>
</div>
<div class="paragraph">
<p>One example of the few hot operators in Reactor is <code>just</code>: It directly captures the value
at assembly time and replays it to anybody subscribing to it later. To re-use the HTTP
call analogy, if the captured data is the result of an HTTP call, then only one network
call is made, when instantiating <code>just</code>.</p>
</div>
<div class="paragraph">
<p>在Reactor中为数不多的热门运算符的一个示例是just：它直接在汇编时捕获值，然后将其重播给以后订阅该值的任何人。
为了重用HTTP调用类比，如果捕获的数据是HTTP调用的结果，则在实例化时仅进行一个网络调用just。</p>
</div>
<div class="paragraph">
<p>To transform <code>just</code> into a cold publisher, you can use <code>defer</code>. It defers the HTTP
request in our example to subscription time (and would result in a separate network call
for each new subscription).</p>
</div>
<div class="paragraph">
<p>要转化just为冷发行商，您可以使用defer。它在我们的示例中将HTTP请求延迟了订阅时间（并会为每个新订阅导致单独的网络调用）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Most other hot publishers in Reactor extend <code>Processor</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Reactor中的大多数其他热门发行商都在扩展Processor。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider two other examples. The following code shows the first example:</p>
</div>
<div class="paragraph">
<p>考虑另外两个例子。以下代码显示了第一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; source = Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
                          .map(String::toUpperCase);

source.subscribe(d -&gt; System.out.println("Subscriber 1: "+d));
source.subscribe(d -&gt; System.out.println("Subscriber 2: "+d));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This first example produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Subscriber 1: BLUE
Subscriber 1: GREEN
Subscriber 1: ORANGE
Subscriber 1: PURPLE
Subscriber 2: BLUE
Subscriber 2: GREEN
Subscriber 2: ORANGE
Subscriber 2: PURPLE</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following image shows the replay behavior:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/gs-cold.png" alt="Replaying behavior">
</div>
</div>
<div class="paragraph">
<p>Both subscribers catch all four colors, because each subscriber causes the
process defined by the operators on the <code>Flux</code> to run.</p>
</div>
<div class="paragraph">
<p>两个订户都捕获全部四种颜色，因为每个订户都会导致Flux运行由操作符定义的过程。</p>
</div>
<div class="paragraph">
<p>Compare the first example to the second example, shown in the following code:</p>
</div>
<div class="paragraph">
<p>将第一个示例与第二个示例进行比较，如以下代码所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">DirectProcessor&lt;String&gt; hotSource = DirectProcessor.create();

Flux&lt;String&gt; hotFlux = hotSource.map(String::toUpperCase);


hotFlux.subscribe(d -&gt; System.out.println("Subscriber 1 to Hot Source: "+d));

hotSource.onNext("blue");
hotSource.onNext("green");

hotFlux.subscribe(d -&gt; System.out.println("Subscriber 2 to Hot Source: "+d));

hotSource.onNext("orange");
hotSource.onNext("purple");
hotSource.onComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The second example produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Subscriber 1 to Hot Source: BLUE
Subscriber 1 to Hot Source: GREEN
Subscriber 1 to Hot Source: ORANGE
Subscriber 2 to Hot Source: ORANGE
Subscriber 1 to Hot Source: PURPLE
Subscriber 2 to Hot Source: PURPLE</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following image shows how a subscription is broadcast:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/gs-hot.png" alt="Broadcasting a subscription">
</div>
</div>
<div class="paragraph">
<p>Subscriber 1 catches all four colors. Subscriber 2, having been created after the first
two colors were produced, catches only the last two colors. This difference accounts for
the doubling of <code>ORANGE</code> and <code>PURPLE</code> in the output. The process described by the
operators on this Flux runs regardless of when subscriptions have been attached.</p>
</div>
<div class="paragraph">
<p>订户1捕获所有四种颜色。在生成前两种颜色之后创建的订户2，仅捕获后两种颜色。
这种差异导致输出ORANGE和的加倍PURPLE。无论何时附加订阅，运营商在此Flux上描述的过程都将运行。</p>
</div>
</div>
<div class="sect2">
<h3 id="advanced-broadcast-multiple-subscribers-connectableflux"><a class="anchor" href="#advanced-broadcast-multiple-subscribers-connectableflux"></a>9.3. Broadcasting to Multiple Subscribers with <code>ConnectableFlux</code></h3>
<div class="paragraph">
<p>Sometimes, you may want to not defer only some processing to the subscription time of one
subscriber, but you might actually want for several of them to rendezvous and then
trigger the subscription and data generation.</p>
</div>
<div class="paragraph">
<p>有时，您可能不希望仅将某些处理推迟到一个订户的订阅时间，但实际上您可能希望其中的几个会合，然后触发订阅和数据生成。</p>
</div>
<div class="paragraph">
<p>This is what <code>ConnectableFlux</code> is made for. Two main patterns are covered in the <code>Flux</code>
API that return a <code>ConnectableFlux</code>: <code>publish</code> and <code>replay</code>.</p>
</div>
<div class="paragraph">
<p>这是ConnectableFlux能做的。Flux API 中涵盖了两个主要模式，这些模式返回ConnectableFlux：publish和replay。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>publish</code> dynamically tries to respect the demand from its various subscribers, in
terms of backpressure, by forwarding these requests to the source. Most notably, if any
subscriber has a pending demand of <code>0</code>, publish pauses its requesting to the source.</p>
</li>
<li>
<p><code>replay</code> buffers data seen through the first subscription, up to configurable limits
(in time and buffer size). It replays the data to subsequent subscribers.</p>
</li>
<li>
<p>publish通过将这些请求转发到源，动态地尝试在背压方面尊重其各个订户的需求。最值得注意的是，如果任何订阅者的需求待定0，发布会暂停其对源的请求</p>
</li>
<li>
<p>replay缓冲通过第一个订阅者看到的数据，直至可配置的限制（时间和缓冲区大小）。它将数据重放给后续的订户。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>ConnectableFlux</code> offers additional methods to manage subscriptions downstream
versus subscriptions to the original source. These additional methods include the
following:</p>
</div>
<div class="paragraph">
<p>ConnectableFlux提供了其他方法来管理下游订阅，而不是原始来源的订阅。这些其他方法包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>connect()</code> can be called manually once you reach enough subscriptions to the <code>Flux</code>. That
triggers the subscription to the upstream source.</p>
</li>
<li>
<p><code>autoConnect(n)</code> can do the same job automatically once <code>n</code> subscriptions have been
made.</p>
</li>
<li>
<p><code>refCount(n)</code> not only automatically tracks incoming subscriptions but also detects
when these subscriptions are cancelled. If not enough subscribers are tracked, the source
is &#8220;disconnected&#8221;, causing a new subscription to the source later if additional
subscribers appear.</p>
</li>
<li>
<p><code>refCount(int, Duration)</code> adds a &#8220;grace period.&#8221; Once the number of tracked subscribers
becomes too low, it waits for the <code>Duration</code> before disconnecting the source, potentially
allowing for enough new subscribers to come in and cross the connection threshold again.</p>
</li>
<li>
<p>connect() 只要您订阅了足够的订阅，便可以手动调用Flux。这将触发对上游源的订阅。</p>
</li>
<li>
<p>autoConnect(n) 进行n次订阅后，可以自动执行相同的工作。</p>
</li>
<li>
<p>refCount(n)不仅会自动跟踪传入的订阅，还会检测何时取消这些订阅。如果跟踪的订户不足，则源将“断开连接”，如果出现其他订户，则会在以后导致对该源的新订阅。</p>
</li>
<li>
<p>refCount(int, Duration)添加了“宽限期”。一旦被跟踪的订户数量变得太少，它将Duration在断开源连接之前等待，可能允许足够的新订户进入并再次超过连接阈值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; source = Flux.range(1, 3)
                           .doOnSubscribe(s -&gt; System.out.println("subscribed to source"));

ConnectableFlux&lt;Integer&gt; co = source.publish();

co.subscribe(System.out::println, e -&gt; {}, () -&gt; {});
co.subscribe(System.out::println, e -&gt; {}, () -&gt; {});

System.out.println("done subscribing");
Thread.sleep(500);
System.out.println("will now connect");

co.connect();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>done subscribing
will now connect
subscribed to source
1
1
2
2
3
3</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following code uses <code>autoConnect</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; source = Flux.range(1, 3)
                           .doOnSubscribe(s -&gt; System.out.println("subscribed to source"));

Flux&lt;Integer&gt; autoCo = source.publish().autoConnect(2);

autoCo.subscribe(System.out::println, e -&gt; {}, () -&gt; {});
System.out.println("subscribed first");
Thread.sleep(500);
System.out.println("subscribing second");
autoCo.subscribe(System.out::println, e -&gt; {}, () -&gt; {});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The preceding code produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>subscribed first
subscribing second
subscribed to source
1
1
2
2
3
3</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-three-sorts-batching"><a class="anchor" href="#advanced-three-sorts-batching"></a>9.4. Three Sorts of Batching</h3>
<div class="paragraph">
<p>When you have lots of elements and you want to separate them into batches, you have three
broad solutions in Reactor: grouping, windowing, and buffering. These three are
conceptually close, because they redistribute a <code>Flux&lt;T&gt;</code> into an aggregate. Grouping and
windowing create a <code>Flux&lt;Flux&lt;T&gt;&gt;</code>, while buffering aggregates into a <code>Collection&lt;T&gt;</code>.</p>
</div>
<div class="paragraph">
<p>当您有很多元素并且想要将它们分成批处理时，Reactor中提供了三种广泛的解决方案：分组，窗口化和缓冲。这三个在概念上很接近，因为它们将重新分配Flux&lt;T&gt;为一个集合。
分组和开窗创建一个Flux&lt;Flux&lt;T&gt;&gt;，同时将聚合缓冲到一个Collection&lt;T&gt;。</p>
</div>
<div class="sect3">
<h4 id="_grouping_with_fluxgroupedfluxt"><a class="anchor" href="#_grouping_with_fluxgroupedfluxt"></a>9.4.1. Grouping with <code>Flux&lt;GroupedFlux&lt;T&gt;&gt;</code></h4>
<div class="paragraph">
<p>Grouping is the act of splitting the source <code>Flux&lt;T&gt;</code> into multiple batches, each of which
matches a key.</p>
</div>
<div class="paragraph">
<p>分组是将源Flux&lt;T&gt;分成多个批次的操作，每个批次与一个密钥匹配。</p>
</div>
<div class="paragraph">
<p>The associated operator is <code>groupBy</code>.</p>
</div>
<div class="paragraph">
<p>关联的运算符为groupBy。</p>
</div>
<div class="paragraph">
<p>Each group is represented as a <code>GroupedFlux&lt;T&gt;</code>, which lets you retrieve the key by calling its
<code>key()</code> method.</p>
</div>
<div class="paragraph">
<p>每个组均以表示GroupedFlux&lt;T&gt;，您可以通过调用其key()方法来检索密钥 。</p>
</div>
<div class="paragraph">
<p>There is no necessary continuity in the content of the groups. Once a source element
produces a new key, the group for this key is opened and elements that match the key end
up in the group (several groups could be open at the same time).</p>
</div>
<div class="paragraph">
<p>组的内容没有必要的连续性。一旦源元素生成新密钥，就会打开该密钥的组，并且与该密钥匹配的元素最终出现在该组中（可以同时打开几个组）。</p>
</div>
<div class="paragraph">
<p>This means that groups:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Are always disjoint (a source element belongs to one and only one group).终不相交（源元素属于一个且仅属于一组）。</p>
</li>
<li>
<p>Can contain elements from different places in the original sequence.可以包含原始序列中不同位置的元素。</p>
</li>
<li>
<p>Are never empty.永远不会空着。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following example groups values by whether they are even or odd:</p>
</div>
<div class="paragraph">
<p>下面的示例按值是偶数还是奇数对值进行分组：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.groupBy(i -&gt; i % 2 == 0 ? "even" : "odd")
		.concatMap(g -&gt; g.defaultIfEmpty(-1) //if empty groups, show them
				.map(String::valueOf) //map to string
				.startWith(g.key())) //start with the group's key
	)
	.expectNext("odd", "1", "3", "5", "11", "13")
	.expectNext("even", "2", "4", "6", "12")
	.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Grouping is best suited for when you have a medium to low number of groups. The
groups must also imperatively be consumed (such as by a <code>flatMap</code>) so that <code>groupBy</code>
continues fetching data from upstream and feeding more groups. Sometimes, these two
constraints multiply and lead to hangs, such as when you have a high cardinality and the
concurrency of the <code>flatMap</code> consuming the groups is too low.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
分组最适合中小数量的组。还必须强制使用组（例如通过flatMap），以便groupBy 继续从上游获取数据并提供更多组。
有时，这两个约束会倍增并导致挂起，例如，当您具有高基数并且flatMap使用组的并发性太低时。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_windowing_with_fluxfluxt"><a class="anchor" href="#_windowing_with_fluxfluxt"></a>9.4.2. Windowing with <code>Flux&lt;Flux&lt;T&gt;&gt;</code></h4>
<div class="paragraph">
<p>Windowing is the act of splitting the source <code>Flux&lt;T&gt;</code> into <em>windows</em>, by criteria of
size, time, boundary-defining predicates, or boundary-defining <code>Publisher</code>.</p>
</div>
<div class="paragraph">
<p>窗口化是根据大小，时间，边界定义或边界定义的标准将源分割Flux&lt;T&gt;为窗口的行为的Publisher。</p>
</div>
<div class="paragraph">
<p>The associated operators are <code>window</code>, <code>windowTimeout</code>, <code>windowUntil</code>, <code>windowWhile</code>, and
<code>windowWhen</code>.</p>
</div>
<div class="paragraph">
<p>相关的操作符是 window，windowTimeout，windowUntil，windowWhile，和 windowWhen。</p>
</div>
<div class="paragraph">
<p>Contrary to <code>groupBy</code>, which randomly overlaps according to incoming keys,
windows are (most of the time) opened sequentially.</p>
</div>
<div class="paragraph">
<p>与相对groupBy，根据输入键随机重叠。窗口（大部分时间）是按顺序打开的。</p>
</div>
<div class="paragraph">
<p>Some variants can still overlap, though. For instance, in <code>window(int maxSize, int skip)</code>
the <code>maxSize</code> parameter is the number of elements after which a window
closes, and the <code>skip</code> parameter is the number of elements in the source after which a
new window is opened. So if <code>maxSize &gt; skip</code>, a new window opens before the previous one
closes and the two windows overlap.</p>
</div>
<div class="paragraph">
<p>但是，某些变体仍然可以重叠。例如，在window(int maxSize, int skip) 该maxSize参数是窗口达到元件的数量之后关闭，并且所述skip参数是源元件的数量达到后在打开一个新的窗口。
因此，如果maxSize &gt; skip打开一个新窗口，则在前一个窗口关闭之前，这两个窗口会重叠。</p>
</div>
<div class="paragraph">
<p>The following example shows overlapping windows:</p>
</div>
<div class="paragraph">
<p>以下示例显示了重叠的窗口：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(
	Flux.range(1, 10)
		.window(5, 3) //overlapping windows
		.concatMap(g -&gt; g.defaultIfEmpty(-1)) //show empty windows as -1
	)
		.expectNext(1, 2, 3, 4, 5)
		.expectNext(4, 5, 6, 7, 8)
		.expectNext(7, 8, 9, 10)
		.expectNext(10)
		.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
With the reverse configuration (<code>maxSize</code> &lt; <code>skip</code>), some elements from
the source are dropped and are not part of any window.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用相反的配置（maxSize&lt; skip），则会删除源中的某些元素，它们不属于任何窗口。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the case of predicate-based windowing through <code>windowUntil</code> and <code>windowWhile</code>,
having subsequent source elements that do not match the predicate can also lead
to empty windows, as demonstrated in the following example:</p>
</div>
<div class="paragraph">
<p>在通过“ windowUntil”和“ windowWhile”进行基于谓词的窗口化的情况下，
后续源元素与断言不匹配也可能导致
如以下示例所示，关闭空窗口：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.windowWhile(i -&gt; i % 2 == 0)
		.concatMap(g -&gt; g.defaultIfEmpty(-1))
	)
		.expectNext(-1, -1, -1) //respectively triggered by odd 1 3 5
		.expectNext(2, 4, 6) // triggered by 11
		.expectNext(12) // triggered by 13
		// however, no empty completion window is emitted (would contain extra matching elements)
		.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buffering_with_fluxlistt"><a class="anchor" href="#_buffering_with_fluxlistt"></a>9.4.3. Buffering with <code>Flux&lt;List&lt;T&gt;&gt;</code></h4>
<div class="paragraph">
<p>Buffering is similar to windowing, with the following twist: Instead of emitting
<em>windows</em> (each of which is each a <code>Flux&lt;T&gt;</code>), it emits <em>buffers</em> (which are <code>Collection&lt;T&gt;</code>&#8201;&#8212;&#8201;by default, <code>List&lt;T&gt;</code>).</p>
</div>
<div class="paragraph">
<p>缓冲类似于加窗，但有以下不同：而不是发出 窗口（每个窗口都是 Flux&lt;T&gt;），而是发出缓冲区（Collection&lt;T&gt; 默认为List&lt;T&gt;）。</p>
</div>
<div class="paragraph">
<p>The operators for buffering mirror those for windowing: <code>buffer</code>, <code>bufferTimeout</code>,
<code>bufferUntil</code>, <code>bufferWhile</code>, and <code>bufferWhen</code>.</p>
</div>
<div class="paragraph">
<p>用于缓冲的操作符反映出像窗口的性质，比如：buffer，bufferTimeout， bufferUntil，bufferWhile，和bufferWhen。</p>
</div>
<div class="paragraph">
<p>Where the corresponding windowing operator opens a window, a buffering operator creates a
new collection and starts adding elements to it. Where a window closes, the buffering
operator emits the collection.</p>
</div>
<div class="paragraph">
<p>在相应的窗口运算符打开一个窗口的地方，一个缓冲运算符创建一个新的集合并开始向其中添加元素。
在窗口关闭的地方，缓冲运算符发出集合。</p>
</div>
<div class="paragraph">
<p>Buffering can also lead to dropping source elements or having overlapping buffers, as
the following example shows:</p>
</div>
<div class="paragraph">
<p>缓冲还会导致源元素丢失或缓冲区重叠，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(
	Flux.range(1, 10)
		.buffer(5, 3) //overlapping buffers
	)
		.expectNext(Arrays.asList(1, 2, 3, 4, 5))
		.expectNext(Arrays.asList(4, 5, 6, 7, 8))
		.expectNext(Arrays.asList(7, 8, 9, 10))
		.expectNext(Collections.singletonList(10))
		.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Unlike in windowing, <code>bufferUntil</code> and <code>bufferWhile</code> do not emit an empty buffer, as
the following example shows:</p>
</div>
<div class="paragraph">
<p>不同于在窗口中，bufferUntil并且bufferWhile不发出空缓冲区，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.bufferWhile(i -&gt; i % 2 == 0)
	)
	.expectNext(Arrays.asList(2, 4, 6)) // triggered by 11
	.expectNext(Collections.singletonList(12)) // triggered by 13
	.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-parallelizing-parralelflux"><a class="anchor" href="#advanced-parallelizing-parralelflux"></a>9.5. Parallelizing Work with <code>ParallelFlux</code></h3>
<div class="paragraph">
<p>With multi-core architectures being a commodity nowadays, being able to easily
parallelize work is important. Reactor helps with that by providing a special type,
<code>ParallelFlux</code>, that exposes operators that are optimized for parallelized work.</p>
</div>
<div class="paragraph">
<p>如今，随着多核体系结构成为一种商品，能够轻松并行化工作非常重要。
Reactor通过提供一种特殊类型来帮助实现这一点，该类型 ParallelFlux公开了针对并行工作进行了优化的运算符。</p>
</div>
<div class="paragraph">
<p>To obtain a <code>ParallelFlux</code>, you can use the <code>parallel()</code> operator on any <code>Flux</code>.
By itself, this method does not parallelize the work. Rather, it divides
the workload into &#8220;rails&#8221; (by default, as many rails as there are CPU cores).</p>
</div>
<div class="paragraph">
<p>要获取 ParallelFlux，您可以parallel()在任意位置使用运算符Flux。就其本身而言，此方法不会使工作并行化。
相反，它将工作负载划分为“ rails”（默认情况下，与CPU内核一样多的rails）。</p>
</div>
<div class="paragraph">
<p>In order to tell the resulting <code>ParallelFlux</code> where to run each rail (and, by
extension, to run rails in parallel) you have to use <code>runOn(Scheduler)</code>. Note that
there is a recommended dedicated <code>Scheduler</code> for parallel work: <code>Schedulers.parallel()</code>.</p>
</div>
<div class="paragraph">
<p>为了告诉最终结果ParallelFlux，每个导轨都在哪里运行（并扩展为并行运行导轨），您必须使用runOn(Scheduler)。
需要注意的是有一个推荐的专用Scheduler并行工作：Schedulers.parallel()。</p>
</div>
<div class="paragraph">
<p>Compare the next two examples:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.range(1, 10)
    .parallel(2) <i class="conum" data-value="1"></i><b>(1)</b>
    .subscribe(i -&gt; System.out.println(Thread.currentThread().getName() + " -&gt; " + i));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We force a number of rails instead of relying on the number of CPU cores. 我们强制使用多个导轨，而不是依赖于CPU内核的数量。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.range(1, 10)
    .parallel(2)
    .runOn(Schedulers.parallel())
    .subscribe(i -&gt; System.out.println(Thread.currentThread().getName() + " -&gt; " + i));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The first example produces the following output:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>main -&gt; 1
main -&gt; 2
main -&gt; 3
main -&gt; 4
main -&gt; 5
main -&gt; 6
main -&gt; 7
main -&gt; 8
main -&gt; 9
main -&gt; 10</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The second correctly parallelizes on two threads, as shown in the following output:</p>
</div>
<div class="paragraph">
<p>第二个在两个线程上正确并行化，如以下输出所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>parallel-1 -&gt; 1
parallel-2 -&gt; 2
parallel-1 -&gt; 3
parallel-2 -&gt; 4
parallel-1 -&gt; 5
parallel-2 -&gt; 6
parallel-1 -&gt; 7
parallel-1 -&gt; 9
parallel-2 -&gt; 8
parallel-2 -&gt; 10</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If, once you process your sequence in parallel, you want to revert back to a &#8220;normal&#8221;
<code>Flux</code> and apply the rest of the operator chain in a sequential manner, you can use the
<code>sequential()</code> method on <code>ParallelFlux</code>.</p>
</div>
<div class="paragraph">
<p>如果在并行处理序列后想要恢复为“正常” Flux并以顺序方式应用其余运算符链，则可以在ParallelFlux上使用sequential()方法。</p>
</div>
<div class="paragraph">
<p>Note that <code>sequential()</code> is implicitly applied if you <code>subscribe</code> to the <code>ParallelFlux</code>
with a <code>Subscriber</code> but not when using the lambda-based variants of <code>subscribe</code>.</p>
</div>
<div class="paragraph">
<p>请注意，sequential()是隐式应用，如果你subscribe到ParallelFlux 了Subscriber使用基于lambda时，但不是subscribe。</p>
</div>
<div class="paragraph">
<p>Note also that <code>subscribe(Subscriber&lt;T&gt;)</code> merges all the rails, while
<code>subscribe(Consumer&lt;T&gt;)</code> runs all the rails. If the <code>subscribe()</code> method has a lambda,
each lambda is executed as many times as there are rails.</p>
</div>
<div class="paragraph">
<p>还要注意，subscribe(Subscriber&lt;T&gt;)合并所有导轨，同时 subscribe(Consumer&lt;T&gt;)运行所有导轨。
如果该subscribe()方法具有lambda，则每个lambda的执行次数将与rails一样多。</p>
</div>
<div class="paragraph">
<p>You can also access individual rails or &#8220;groups&#8221; as a <code>Flux&lt;GroupedFlux&lt;T&gt;&gt;</code> through the
<code>groups()</code> method and apply additional operators to them through the <code>composeGroup()</code>
method.</p>
</div>
<div class="paragraph">
<p>您也可以Flux&lt;GroupedFlux&lt;T&gt;&gt;通过groups()方法访问单个导轨或“组”，并通过该 方法向它们应用其他运算符composeGroup() 。</p>
</div>
</div>
<div class="sect2">
<h3 id="scheduler-factory"><a class="anchor" href="#scheduler-factory"></a>9.6. Replacing Default <code>Schedulers</code></h3>
<div class="paragraph">
<p>As we described in the <a href="#schedulers">Threading and Schedulers</a> section, Reactor Core comes with several
<code>Scheduler</code> implementations. While you can always create new instances through the <code>new*</code>
factory methods, each <code>Scheduler</code> flavor also has a default singleton instance that is
accessible through the direct factory method (such as <code>Schedulers.boundedElastic()</code> versus
<code>Schedulers.newBoundedElastic(&#8230;&#8203;)</code>).</p>
</div>
<div class="paragraph">
<p>如我们在“ 线程和调度程序”部分所述，Reactor Core附带了几种 Scheduler实现。
尽管您始终可以通过new* 工厂方法创建新实例，但是每个Scheduler风味还具有默认的单例实例，可通过直接工厂方法（例如Schedulers.boundedElastic()vs Schedulers.newBoundedElastic(…​)）进行访问。</p>
</div>
<div class="paragraph">
<p>These default instances are the ones used by operators that need a <code>Scheduler</code> to work
when you do not explicitly specify one. For example, <code>Flux#delayElements(Duration)</code> uses
the <code>Schedulers.parallel()</code> instance.</p>
</div>
<div class="paragraph">
<p>这些默认实例是Scheduler未明确指定实例时需要工作的运算符所使用的实例。
例如，Flux#delayElements(Duration)使用Schedulers.parallel()实例。</p>
</div>
<div class="paragraph">
<p>In some cases, however, you might need to change these default instances with something
else in a cross-cutting way, without having to make sure every single operator you call
has your specific <code>Scheduler</code> as a parameter. An example is measuring the time every
single scheduled task takes by wrapping the real schedulers, for instrumentation
purposes. In other words, you might want to change the default <code>Schedulers</code>.</p>
</div>
<div class="paragraph">
<p>但是，在某些情况下，您可能需要以交叉方式使用其他默认值来更改这些默认实例，而不必确保调用的每个运算符都将自己的特定Scheduler参数作为参数。
一个示例是通过包装实际的计划程序来测量每个计划的任务所花费的时间，以进行检测。换句话说，您可能想要更改默认的Schedulers。</p>
</div>
<div class="paragraph">
<p>Changing the default schedulers is possible through the <code>Schedulers.Factory</code> class. By
default, a <code>Factory</code> creates all the standard <code>Scheduler</code> through similarly named
methods. You can override each of these with your custom implementation.</p>
</div>
<div class="paragraph">
<p>通过Schedulers.Factory该类可以更改默认调度程序。
默认情况下，<code>Factory</code> 通过相似命名的方法创建所有标准Scheduler。您可以使用自定义实现覆盖其中的每一个。</p>
</div>
<div class="paragraph">
<p>Additionally, the factory exposes one additional customization method:
<code>decorateExecutorService</code>. It is invoked during the creation of every Reactor Core
<code>Scheduler</code> that is backed by a <code>ScheduledExecutorService</code> (even non-default instances,
such as those created by calls to <code>Schedulers.newParallel()</code>).</p>
</div>
<div class="paragraph">
<p>此外，工厂还公开了另一种自定义方法： decorateExecutorService。
在创建每个Scheduler由ScheduledExecutorService（作为非默认实例，例如通过调用创建的实例）支持的Reactor Core的过程中调用它 Schedulers.newParallel()。</p>
</div>
<div class="paragraph">
<p>This lets you tune the <code>ScheduledExecutorService</code> to be used: The default one is exposed
as a <code>Supplier</code> and, depending on the type of <code>Scheduler</code> being configured, you can choose
to entirely bypass that supplier and return your own instance or you can <code>get()</code> the
default instance and wrap it.</p>
</div>
<div class="paragraph">
<p>这使您可以调整ScheduledExecutorService要使用的：默认实例显示为一个Supplier并且根据Scheduler配置的类型，
您可以选择完全绕过该提供并返回自己的实例，也可以为get()将选择的默认实例包装并将其返回。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Once you create a <code>Factory</code> that fits your needs, you must install it by calling
<code>Schedulers.setFactory(Factory)</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
创建Factory适合您需求的软件后，您必须通过调用进行安装 Schedulers.setFactory(Factory)。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, there is a last customizable hook in <code>Schedulers</code>: <code>onHandleError</code>. This hook is
invoked whenever a <code>Runnable</code> task submitted to a <code>Scheduler</code> throws an <code>Exception</code> (note
that if there is an <code>UncaughtExceptionHandler</code> set for the <code>Thread</code> that ran the task,
both the handler and the hook are invoked).</p>
</div>
<div class="paragraph">
<p>最后，还有最后一个可定制的钩子Schedulers：onHandleError。
每当Runnable提交给Scheduler引发任务的任务抛出异常时，都会调用此挂钩Exception（请注意，如果有运行该任务的UncaughtExceptionHandler集合，则将Thread同时调用处理程序和挂钩）。</p>
</div>
</div>
<div class="sect2">
<h3 id="hooks"><a class="anchor" href="#hooks"></a>9.7. Using Global Hooks</h3>
<div class="paragraph">
<p>Reactor has another category of configurable callbacks that are invoked by Reactor
operators in various situations. They are all set in the <code>Hooks</code> class, and they fall into
three categories:</p>
</div>
<div class="paragraph">
<p>Reactor具有另一类可配置的回调，可在各种情况下由Reactor运算符调用。它们全都设置在Hooks 类中，分为三类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#hooks-dropping">Dropping Hooks</a></p>
</li>
<li>
<p><a href="#hooks-internal">Internal Error Hook</a></p>
</li>
<li>
<p><a href="#hooks-assembly">Assembly Hooks</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="hooks-dropping"><a class="anchor" href="#hooks-dropping"></a>9.7.1. Dropping Hooks</h4>
<div class="paragraph">
<p>Dropping hooks are invoked when the source of an operator does not comply with the
Reactive Streams specification. These kind of errors are outside of the normal execution
path (that is, they cannot be propagated through <code>onError</code>).</p>
</div>
<div class="paragraph">
<p>当操作员的来源不符合Reactive Streams规范时，将调用吊钩。这些类型的错误不在正常的执行路径之内（也就是说，它们不能通过传播onError）。</p>
</div>
<div class="paragraph">
<p>Typically, a <code>Publisher</code> calls <code>onNext</code> on the operator despite having already called
<code>onCompleted</code> on it previously. In that case, the <code>onNext</code> value is dropped. The same
is true for an extraneous <code>onError</code> signal.</p>
</div>
<div class="paragraph">
<p>通常，尽管先前已经在运算符上进行了Publisher调用onNext，但仍在对运算符进行调用 onCompleted。
在这种情况下，该onNext值将被删除。外部onError信号也是如此。</p>
</div>
<div class="paragraph">
<p>The corresponding hooks, <code>onNextDropped</code> and <code>onErrorDropped</code>, let you provide a global
<code>Consumer</code> for these drops. For example, you can use it to log the drop and clean up
resources associated with a value if needed (as it never makes it to the rest of the
reactive chain).</p>
</div>
<div class="paragraph">
<p>相应的钩子onNextDropped和onErrorDropped允许您Consumer为这些放置提供全局 变量。
例如，您可以使用它来记录删除操作，并在需要时清理与某个值关联的资源（因为它永远不会到达响应链的其余部分）。</p>
</div>
<div class="paragraph">
<p>Setting the hooks twice in a row is additive: every consumer you provide is invoked. The
hooks can be fully reset to their defaults by using the <code>Hooks.resetOn*Dropped()</code> methods.</p>
</div>
<div class="paragraph">
<p>连续两次设置钩子是附加的：您提供的每个使用者都将被调用。
可以使用这些Hooks.resetOn*Dropped()方法将挂钩完全重置为默认值。</p>
</div>
</div>
<div class="sect3">
<h4 id="hooks-internal"><a class="anchor" href="#hooks-internal"></a>9.7.2. Internal Error Hook</h4>
<div class="paragraph">
<p>One hook, <code>onOperatorError</code>, is invoked by operators when an unexpected <code>Exception</code> is
thrown during the execution of their <code>onNext</code>, <code>onError</code>, and <code>onComplete</code> methods.</p>
</div>
<div class="paragraph">
<p>一个钩，onOperatorError是由操作员当一意外的调用Exception其执行期间被抛出onNext，onError和onComplete方法。</p>
</div>
<div class="paragraph">
<p>Unlike the previous category, this is still within the normal execution path. A typical
example is the <code>map</code> operator with a map function that throws an <code>Exception</code> (such as
division by zero). It is still possible at this point to go through the usual channel of
<code>onError</code>, and that is what the operator does.</p>
</div>
<div class="paragraph">
<p>与之前的类别不同，这仍然在常规执行路径之内。一个典型的例子是map带有一个映射函数的运算符，该运算符抛出一个Exception（例如被零除）。
在这一点上，仍然有可能通过的常规渠道在 onError，而这正是操作员所要做的。</p>
</div>
<div class="paragraph">
<p>First, it passes the <code>Exception</code> through <code>onOperatorError</code>. The hook lets you inspect the
error (and the incriminating value, if relevant) and change the <code>Exception</code>. Of course,
you can also do something on the side, such as log and return the original <code>Exception</code>.</p>
</div>
<div class="paragraph">
<p>首先，它准许Exception通过onOperatorError。该挂钩可让您检查错误（以及相关值），并更改Exception。
当然，您也可以在侧面执行一些操作，例如log并返回original Exception。</p>
</div>
<div class="paragraph">
<p>Note that you can set the <code>onOperatorError</code> hook multiple times. You can provide a
<code>String</code> identifier for a particular <code>BiFunction</code> and subsequent calls with different
keys concatenates the functions, which are all executed. On the other hand, reusing the
same key twice lets you replace a function you previously set.</p>
</div>
<div class="paragraph">
<p>请注意，您可以onOperatorError多次设置挂钩。您可以String为一个特定的标识符提供 标识符BiFunction，随后的调用将使用不同的键将这些函数串联起来，这些函数将全部执行。
另一方面，重复使用同一键两次可让您替换以前设置的功能。</p>
</div>
<div class="paragraph">
<p>As a consequence, the default hook behavior can be both fully reset (by using
<code>Hooks.resetOnOperatorError()</code>) or partially reset for a specific <code>key</code> only (by using
<code>Hooks.resetOnOperatorError(String)</code>).</p>
</div>
<div class="paragraph">
<p>因此，默认挂钩行为既可以完全重置（通过使用Hooks.resetOnOperatorError()），也可以 key仅针对特定的部分重置（通过使用 Hooks.resetOnOperatorError(String)）。</p>
</div>
</div>
<div class="sect3">
<h4 id="hooks-assembly"><a class="anchor" href="#hooks-assembly"></a>9.7.3. Assembly Hooks</h4>
<div class="paragraph">
<p>These hooks tie in the lifecycle of operators. They are invoked when a chain of operators
is assembled (that is, instantiated). <code>onEachOperator</code> lets you dynamically change each
operator as it is assembled in the chain, by returning a different <code>Publisher</code>.
<code>onLastOperator</code> is similar, except that it is invoked only on the last operator in the
chain before the <code>subscribe</code> call.</p>
</div>
<div class="paragraph">
<p>这些挂钩关系到操作符的生命周期。在组装（即实例化）一系列操作符时调用它们。onEachOperator通过返回不同的，可以动态更改链中组装的每个运算符Publisher。
 onLastOperator与之类似，除了它仅在调用subscribe之前在链中的最后一个运算符上才执行。</p>
</div>
<div class="paragraph">
<p>If you want to decorate all operators with a cross-cutting <code>Subscriber</code> implementation,
you can look into the <code>Operators#lift*</code> methods to help you deal with the various
types of Reactor <code>Publishers</code> out there (<code>Flux</code>, <code>Mono</code>, <code>ParallelFlux</code>, <code>GroupedFlux</code>, and <code>ConnectableFlux</code>),
as well as their <code>Fuseable</code> versions.</p>
</div>
<div class="paragraph">
<p>如果您想使用跨领域的Subscriber实现来装饰所有运算符，您可以查看“ Operators＃lift *”方法来帮助您处理各种
那里的反应堆“Publishers”的类型（“Flux”，“Mono”，“ParallelFlux”，“GroupedFlux”和“ConnectableFlux”），
以及它们的“Fuseable”版本。</p>
</div>
<div class="paragraph">
<p>Like <code>onOperatorError</code>, these hooks are cumulative and can be identified with a key. They
can also be reset partially or totally.</p>
</div>
<div class="paragraph">
<p>像一样onOperatorError，这些钩子是累积的，可以用一个密钥标识。它们也可以部分或全部重置。</p>
</div>
</div>
<div class="sect3">
<h4 id="_hook_presets"><a class="anchor" href="#_hook_presets"></a>9.7.4. Hook Presets</h4>
<div class="paragraph">
<p>The <code>Hooks</code> utility class provides two preset hooks. These are alternatives to
the default behaviors that you can use by calling their corresponding method, rather than
coming up with the hook yourself:</p>
</div>
<div class="paragraph">
<p>这 Hooks工具类提供两个预置钩。这些是默认行为的替代方法，您可以通过调用它们的相应方法来使用这些默认行为，而不用亲自实现该钩子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>onNextDroppedFail()</code>: <code>onNextDropped</code> used to throw a <code>Exceptions.failWithCancel()</code>
exception. It now defaults to logging the dropped value at the DEBUG level. To go back to
the old default behavior of throwing, use <code>onNextDroppedFail()</code>.</p>
</li>
<li>
<p><code>onOperatorDebug()</code>: This method activates <a href="#debug-activate">debug mode</a>. It ties into
the <code>onOperatorError</code> hook, so calling <code>resetOnOperatorError()</code> also resets it. You can
independently reset it by using  <code>resetOnOperatorDebug()</code>, as it uses a specific key internally.</p>
</li>
<li>
<p>onNextDroppedFail()：onNextDropped用于引发Exceptions.failWithCancel() 异常。现在，它默认在DEBUG级别记录下降的值。要返回原来的默认抛出行为，请使用onNextDroppedFail()。</p>
</li>
<li>
<p>onOperatorDebug()：此方法激活调试模式。它与onOperatorError挂钩相关，因此调用resetOnOperatorError()也将其重置。您可以使用来独立重置它 resetOnOperatorDebug()，因为它在内部使用了特定的密钥。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context"><a class="anchor" href="#context"></a>9.8. Adding a Context to a Reactive Sequence</h3>
<div class="paragraph">
<p>One of the big technical challenges encountered when switching from an imperative
programming perspective to a reactive programming mindset lies in how you deal with
threading.</p>
</div>
<div class="paragraph">
<p>从命令式编程视角转换为反应式编程思维方式时遇到的重大技术挑战之一是如何处理线程。</p>
</div>
<div class="paragraph">
<p>Contrary to what you might be used to, in reactive programming, you can use a <code>Thread</code>
to process several asynchronous sequences that run at roughly the same time (actually, in
non-blocking locksteps). The execution can also easily and often jump from one thread to
another.</p>
</div>
<div class="paragraph">
<p>与您习惯的反应式编程相反，您可以使用`Thread`处理几个大致同时运行的异步序列（实际上，非阻塞的锁步）。
执行也可以轻松且经常从一个线程跳转到另一个。</p>
</div>
<div class="paragraph">
<p>This arrangement is especially hard for developers that use features dependent on the
threading model being more &#8220;stable,&#8221; such as <code>ThreadLocal</code>. As it lets you associate
data with a thread, it becomes tricky to use in a reactive context. As a result,
libraries that rely on <code>ThreadLocal</code> at least introduce new challenges when used with
Reactor. At worst, they work badly or even fail. Using the MDC of Logback to store and
log correlation IDs is a prime example of such a situation.</p>
</div>
<div class="paragraph">
<p>对于使用依赖于线程模型上开发更“稳定”的功能这种安排尤其困难。比如ThreadLocal。因为它使您可以将数据与线程相关联，所以在反应式上下文中使用它变得棘手。
ThreadLocal与Reactor一起使用时，至少依赖的库会带来新的挑战。在最坏的情况下，它们会表现不佳甚至失败。
使用Logback的MDC存储和记录相关ID是这种情况的主要示例。</p>
</div>
<div class="paragraph">
<p>The usual workaround for <code>ThreadLocal</code> usage is to move the contextual data, <code>C</code>, along
your business data, <code>T</code>, in the sequence, by using (for instance) <code>Tuple2&lt;T, C&gt;</code>. This does
not look good and leaks an orthogonal concern (the contextual data) into your method and
<code>Flux</code> signatures.</p>
</div>
<div class="paragraph">
<p>使用的通常解决方法ThreadLocal是使用（例如）按顺序移动上下文数据C和业务数据。这看起来不好，并且将正交关注点（上下文数据）泄漏到您的方法和 签名中。TTuple2&lt;T, C&gt;Flux</p>
</div>
<div class="paragraph">
<p>Since version <code>3.1.0</code>, Reactor comes with an advanced feature that is somewhat comparable
to <code>ThreadLocal</code> but can be applied to a <code>Flux</code> or a <code>Mono</code> instead of a <code>Thread</code>.
This feature is called <code>Context</code>.</p>
</div>
<div class="paragraph">
<p>从版本开始3.1.0，Reactor带有一项先进的功能，在某种程度上可以与ThreadLocal媲美，但可以应用于Flux或Mono代替Thread。此功能称为Context。</p>
</div>
<div class="paragraph">
<p>As an illustration of what it looks like, the following example both writes from and
writes to <code>Context</code>:</p>
</div>
<div class="paragraph">
<p>为了说明其外观，以下示例同时写入和写入Context：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                .flatMap( s -&gt; Mono.subscriberContext()
                                   .map( ctx -&gt; s + " " + ctx.get(key)))
                .subscriberContext(ctx -&gt; ctx.put(key, "World"));

StepVerifier.create(r)
            .expectNext("Hello World")
            .verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the following sections, we cover <code>Context</code> and how to use it, so that you
can eventually understand the preceding example.</p>
</div>
<div class="paragraph">
<p>在以下各节中，我们介绍Context了它以及如何使用它，以便您最终可以理解前面的示例。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This is an advanced feature that is more targeted at library developers. It
requires good understanding of the lifecycle of a <code>Subscription</code> and is intended for
libraries that are responsible for the subscriptions.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
这是一项高级功能，更面向库开发人员。它需要对Subscription的生命周期有很好的了解，并且适用于负责订阅的库。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="context.api"><a class="anchor" href="#context.api"></a>9.8.1. The <code>Context</code> API</h4>
<div class="paragraph">
<p><code>Context</code> is an interface reminiscent of <code>Map</code>.It stores key-value pairs and lets you
fetch a value you stored by its key. More specifically:</p>
</div>
<div class="paragraph">
<p>Context是一个让人想起的接口。Map它存储键值对，并允许您获取通过其键存储的值。进一步来说：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Both key and values are of type <code>Object</code>, so a <code>Context</code> instance can contain any number of
highly divergent values from different libraries and sources.</p>
</li>
<li>
<p>A <code>Context</code> is immutable.</p>
</li>
<li>
<p>Use <code>put(Object key, Object value)</code> to store a key-value pair, returning a new
<code>Context</code> instance. You can also merge two contexts into a new one by using
<code>putAll(Context)</code>.</p>
</li>
<li>
<p>You can check whether the key is present with <code>hasKey(Object key)</code>.</p>
</li>
<li>
<p>Use <code>getOrDefault(Object key, T defaultValue)</code> to retrieve a value (cast to a <code>T</code>) or
fall back to a default one if the <code>Context</code> instance does not have that key.</p>
</li>
<li>
<p>Use <code>getOrEmpty(Object key)</code> to get an <code>Optional&lt;T&gt;</code> (the <code>Context</code> instance attempts to cast the
stored value to <code>T</code>).</p>
</li>
<li>
<p>Use <code>delete(Object key)</code> to remove the value associated to a key, returning a new
<code>Context</code>.</p>
</li>
<li>
<p>键和值都是类型Object，因此Context实例可以包含来自不同库和源的任意数量的高度不同的值。</p>
</li>
<li>
<p>Context是不可变的。</p>
</li>
<li>
<p>使用put(Object key, Object value)存储一个键值对，返回一个新的 Context实例。您还可以使用将两个上下文合并到一个新的上下文中 putAll(Context)。</p>
</li>
<li>
<p>您可以检查密钥是否存在hasKey(Object key)。</p>
</li>
<li>
<p>使用getOrDefault(Object key, T defaultValue)检索值（强制转换为T），或退回到一个默认的，如果Context实例没有这把钥匙。</p>
</li>
<li>
<p>使用getOrEmpty(Object key)得到的Optional&lt;T&gt;（该Context实例尝试投的存储值T）。</p>
</li>
<li>
<p>使用delete(Object key)删除关联到一个键的值，返回一个新的 Context。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When you create a <code>Context</code>, you can create pre-valued <code>Context</code> instances with up to five
key-value pairs by using the static <code>Context.of</code> methods. They take 2, 4, 6, 8 or 10
<code>Object</code> instances, each couple of <code>Object</code> instances being a key-value pair to add to
the <code>Context</code>.</p>
</div>
<div class="paragraph">
<p>创建时Context，您可以Context使用静态Context.of方法创建最多包含五个键值对的预值实例。
它们需要2、4、6、8或10个 Object实例，每对Object实例都是要添加到的键值对Context。</p>
</div>
<div class="paragraph">
<p>Alternatively you can also create an empty <code>Context</code> by using <code>Context.empty()</code>.</p>
</div>
<div class="paragraph">
<p>或者，您也可以Context使用创建空白Context.empty()。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context.write"><a class="anchor" href="#context.write"></a>9.8.2. Tying a <code>Context</code> to a <code>Flux</code> and Writing</h4>
<div class="paragraph">
<p>To make a <code>Context</code> be useful, it must be tied to a specific sequence and be accessible by
each operator in a chain. Note that the operator must be a Reactor-native operator, as
<code>Context</code> is specific to Reactor.</p>
</div>
<div class="paragraph">
<p>为了使它Context有用，它必须绑定到特定的序列，并且链中的每个操作员都可以访问。
请注意，运算符必须是Reactor本机运算符，这 Context是特定于Reactor的。</p>
</div>
<div class="paragraph">
<p>Actually, a <code>Context</code> is tied to each <code>Subscriber</code> in a chain. It uses the <code>Subscription</code>
propagation mechanism to make itself available to each operator, starting with the final
<code>subscribe</code> and moving up the chain.</p>
</div>
<div class="paragraph">
<p>实际上，Context是绑定在链中的每一个Subscriber。它使用Subscription 传播机制使每个操作员都可以使用，从最终操作开始， subscribe然后向上移动。</p>
</div>
<div class="paragraph">
<p>In order to populate the <code>Context</code>, which can only be done at subscription time, you need
to use the <code>subscriberContext</code> operator.</p>
</div>
<div class="paragraph">
<p>为了填充Context只能在订阅进行时去完成，您需要使用subscriberContext运算符。</p>
</div>
<div class="paragraph">
<p><code>subscriberContext(Context)</code> merges the <code>Context</code> you provide and the
<code>Context</code> from downstream (remember, the <code>Context</code> is propagated from the bottom of the
chain towards the top). This is done through a call to <code>putAll</code>, resulting in a new
<code>Context</code> for upstream.</p>
</div>
<div class="paragraph">
<p>subscriberContext(Context)合并Context您提供的内容和 Context来自下游的内容（请记住，Context是从链的底部向顶部传播的）。
这是通过调用来完成的putAll，从而为上游创建了一个新的 Context。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can also use the more advanced <code>subscriberContext(Function&lt;Context, Context&gt;)</code>.
It receives the state of the <code>Context</code> from downstream, lets you put or delete values
as you see fit, and returns the new <code>Context</code> to use. You can even decide to return a
completely different instance, although it is really not recommended (doing so might
impact third-party libraries that depend on the <code>Context</code>).
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
您也可以使用更高级的subscriberContext(Function&lt;Context, Context&gt;)。
它Context从下游接收的状态，让您根据需要放置或删除值，并返回Context要使用的新值。您甚至可以决定返回一个完全不同的实例，尽管实际上不建议这样做（这样做可能会影响依赖的第三方库Context）。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context.read"><a class="anchor" href="#context.read"></a>9.8.3. Reading a <code>Context</code></h4>
<div class="paragraph">
<p>Once you haved populated a <code>Context</code>, you can retrieve that data.
Most of the time, the responsibility of putting information into the <code>Context</code>
is on the end user&#8217;s side, while exploiting that information is on the third-party library&#8217;s side,
as such libraries are usually upstream of the client code.</p>
</div>
<div class="paragraph">
<p>填充后Context，您可以检索该数据。在大多数情况下，将信息放入的责任Context 在最终用户一方，而利用信息的责任在第三方库的一方，因为此类库通常位于客户端代码的上游。</p>
</div>
<div class="paragraph">
<p>The tool for reading data from the context is the static <code>Mono.subscriberContext()</code>
method.</p>
</div>
<div class="paragraph">
<p>从上下文读取数据的工具的静态方法是 Mono.subscriberContext() 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_simple_context_examples"><a class="anchor" href="#_simple_context_examples"></a>9.8.4. Simple <code>Context</code> Examples</h4>
<div class="paragraph">
<p>The examples in this section are meant as ways to better understand some of the caveats of
using a <code>Context</code>.</p>
</div>
<div class="paragraph">
<p>本节中的示例旨在更好地理解使用Context。</p>
</div>
<div class="paragraph">
<p>We first look back at our simple example from the introduction in a bit more detail, as
the following example shows:</p>
</div>
<div class="paragraph">
<p>首先，我们将更详细地回顾一下引言中的简单示例，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                .flatMap( s -&gt; Mono.subscriberContext() <i class="conum" data-value="2"></i><b>(2)</b>
                                   .map( ctx -&gt; s + " " + ctx.get(key))) <i class="conum" data-value="3"></i><b>(3)</b>
                .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="1"></i><b>(1)</b>

StepVerifier.create(r)
            .expectNext("Hello World") <i class="conum" data-value="4"></i><b>(4)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The chain of operators ends with a call to <code>subscriberContext(Function)</code> that puts
<code>"World"</code> into the <code>Context</code> under a key of <code>"message"</code>. 	运算符链的结尾是对的调用，subscriberContext(Function)该 调用"World"放入的Context密钥下"message"。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We <code>flatMap</code> on the source element, materializing the <code>Context</code> with <code>Mono.subscriberContext()</code>. 我们flatMap在源元素上，Context用 Mono.subscriberContext()实现。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We then use <code>map</code> to extract the data associated to <code>"message"</code> and concatenate that with
the original word. 然后map，我们用于提取"message"与原始单词相关联的数据并将其与原始单词连接。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The resulting <code>Mono&lt;String&gt;</code> emits <code>"Hello World"</code>. 结果Mono&lt;String&gt;发出"Hello World"。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The numbering above versus the actual line order is not a mistake. It represents
the execution order. Even though <code>subscriberContext</code> is the last piece of the chain, it is
the one that gets executed first (due to its subscription-time nature and the fact that
the subscription signal flows from bottom to top).
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
上面的编号与实际的行顺序没有关系。它代表执行顺序。即使subscriberContext是链的最后一部分，它也是第一个被执行的（由于其订阅时间的性质以及订阅信号从下到上流动的事实）。
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In your chain of operators, the relative positions of where you write to the
<code>Context</code> and where you read from it matters. The <code>Context</code>
is immutable and its content can only be seen by operators above it, as demonstrated in
the following example:
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
在您的链中，您向链中写入位置的Context和从中读取的位置的相对位置很重要。因为Context 是不可变的，它的内容只能由上面运算符看出，如在下面的例子所示：
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                     .subscriberContext(ctx -&gt; ctx.put(key, "World")) <i class="conum" data-value="1"></i><b>(1)</b>
                     .flatMap( s -&gt; Mono.subscriberContext()
                                        .map( ctx -&gt; s + " " + ctx.getOrDefault(key, "Stranger")));  <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello Stranger") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Context</code> is written to too high in the chain. 	在Context被写入链太高。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As a result, in the <code>flatMap</code>, there is no value associated with our key. A default value
is used instead. 结果，在中flatMap，没有与我们的密钥关联的值。而是使用默认值。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The resulting <code>Mono&lt;String&gt;</code> thus emits <code>"Hello Stranger"</code>. 结果Mono&lt;String&gt;由此发出"Hello Stranger"。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The following example also demonstrates the immutable nature of the <code>Context</code>, and how
<code>Mono.subscriberContext()</code> always returns the <code>Context</code> set by <code>subscriberContext</code> calls:</p>
</div>
<div class="paragraph">
<p>以下示例还演示了的不变性质Context，以及 Mono.subscriberContext()如何始终通过subscriberContext调用返回Context集合：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";

Mono&lt;String&gt; r = Mono.subscriberContext() <i class="conum" data-value="1"></i><b>(1)</b>
	.map( ctx -&gt; ctx.put(key, "Hello")) <i class="conum" data-value="2"></i><b>(2)</b>
	.flatMap( ctx -&gt; Mono.subscriberContext()) <i class="conum" data-value="3"></i><b>(3)</b>
	.map( ctx -&gt; ctx.getOrDefault(key,"Default")); <i class="conum" data-value="4"></i><b>(4)</b>

StepVerifier.create(r)
	.expectNext("Default") <i class="conum" data-value="5"></i><b>(5)</b>
	.verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We materialize the <code>Context</code> 我们实现 Context</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In a <code>map</code> we attempt to mutate it 在map我们尝试更新它</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We re-materialize the <code>Context</code> in a <code>flatMap</code> 	我们重新实现Context了flatMap</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>We read the attempted key in the <code>Context</code> 我们读取Context中的值</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The key was never set to <code>"Hello"</code>. 密钥从未设置为"Hello"。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Similarly, in the case of several attempts to write the same key to the <code>Context</code>, the
relative order of the writes matters, too. Operators that read the <code>Context</code> see
the value that was set closest to being under them, as demonstrated in the following example:</p>
</div>
<div class="paragraph">
<p>同样，在多次尝试向写入相同密钥的情况下，写入Context的相对顺序也很重要。
读取Contextsee的运算符将看到设置为最接近其值的值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                .flatMap( s -&gt; Mono.subscriberContext()
                                   .map( ctx -&gt; s + " " + ctx.get(key)))
                .subscriberContext(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="1"></i><b>(1)</b>
                .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello Reactor") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A write attempt on key <code>"message"</code>. 对key的写尝试"message"。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Another write attempt on key <code>"message"</code>. 对key的另一次写尝试"message"。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>map</code> only saw the value set closest to it (and below it): <code>"Reactor"</code>. 该map只看见值最接近的设置为它（和它下面）"Reactor"。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the <code>Context</code> is populated with <code>"World"</code> during subscription.
Then the subscription signal moves upstream and another write happens. This produces a
second immutable <code>Context</code> with a value of <code>"Reactor"</code>. After that, data starts flowing.
The <code>flatMap</code> sees the <code>Context</code> closest to it, which is our second <code>Context</code> with the
<code>"Reactor"</code> value.</p>
</div>
<div class="paragraph">
<p>在前面的示例中，在订阅期间Context填充"World"。然后，订阅信号向上游移动，并发生另一次写操作。这将产生第二个不可变Context值"Reactor"。
之后，数据开始流动。在flatMap看到Context最接近于它，这是我们第二次Context与 "Reactor"价值。</p>
</div>
<div class="paragraph">
<p>You might wonder if the <code>Context</code> is propagated along with the data signal. If that was
the case, putting another <code>flatMap</code> between these two writes would use the value from
the top <code>Context</code>. But this is not the case, as demonstrated by the following example:</p>
</div>
<div class="paragraph">
<p>您可能想知道Context是否随数据信号一起传播。如果是这种情况，flatMap在这两次写入之间放置另一个将使用最顶上的Context值。
但这不是事实，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                     .flatMap( s -&gt; Mono.subscriberContext()
                                        .map( ctx -&gt; s + " " + ctx.get(key))) <i class="conum" data-value="3"></i><b>(3)</b>
                     .subscriberContext(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="2"></i><b>(2)</b>
                     .flatMap( s -&gt; Mono.subscriberContext()
                                        .map( ctx -&gt; s + " " + ctx.get(key))) <i class="conum" data-value="4"></i><b>(4)</b>
                     .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="1"></i><b>(1)</b>

StepVerifier.create(r)
            .expectNext("Hello Reactor World") <i class="conum" data-value="5"></i><b>(5)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the first write to happen. 这是第一次写入。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is the second write to happen. 这是第二次写入。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The first <code>flatMap</code> sees second write. 	第一个flatMap看到第二个写</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The second <code>flatMap</code> concatenates the result from first one with the value from the first write. 第二个flatMap将第一个结果与第一次写入的值连接在一起。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>Mono</code> emits <code>"Hello Reactor World"</code>. 该Mono发射"Hello Reactor World"。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The reason is that the <code>Context</code> is associated to the <code>Subscriber</code> and each operator
accesses the <code>Context</code> by requesting it from its downstream <code>Subscriber</code>.</p>
</div>
<div class="paragraph">
<p>原因是“Context”与“Subscriber”和每个运算符相关联，通过从其下游的“Subscriber”中请求来访问“Context”。</p>
</div>
<div class="paragraph">
<p>One last interesting propagation case is the one where the <code>Context</code> is also written to
inside a <code>flatMap</code>, as in the following example:</p>
</div>
<div class="paragraph">
<p>最后一种有趣的传播情况是将“Context”也写入其中的情况在“ flatMap”中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r =
        Mono.just("Hello")
            .flatMap( s -&gt; Mono.subscriberContext()
                               .map( ctx -&gt; s + " " + ctx.get(key))
            )
            .flatMap( s -&gt; Mono.subscriberContext()
                               .map( ctx -&gt; s + " " + ctx.get(key))
                               .subscriberContext(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="1"></i><b>(1)</b>
            )
            .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello World Reactor")
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This <code>subscriberContext</code> does not impact anything outside of its <code>flatMap</code>. 这个“ subscriberContext”不会影响其“ flatMap”之外的任何内容。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This <code>subscriberContext</code> impacts the main sequence&#8217;s <code>Context</code>. 这个“ subscriberContext”会影响主序列的“ Context”。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the final emitted value is <code>"Hello World Reactor"</code> and not "Hello
Reactor World", because the <code>subscriberContext</code> that writes <code>"Reactor"</code> does so as part of
the inner sequence of the second <code>flatMap</code>. As a consequence, it is not visible or propagated
through the main sequence and the first <code>flatMap</code> does not see it. Propagation and immutability
isolate the <code>Context</code> in operators that create intermediate inner sequences such as <code>flatMap</code>.</p>
</div>
<div class="paragraph">
<p>在前面的示例中，最终发出的值为“Hello World Reactor“，而不是” Hello Reactor World”，因为写有“ Reactor”的“ subscriberContext”是作为第二个“flatMap”的内部序列的一部分。
结果，它不可见或传播通过主序列，第一个`flatMap`看不到它。 传播和不变性将“Context”隔离在创建中间内部序列（例如“ flatMap”）的运算符中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_full_example"><a class="anchor" href="#_full_example"></a>9.8.5. Full Example</h4>
<div class="paragraph">
<p>Now we can consider a more real life example of a library reading information from the <code>Context</code>:
a reactive HTTP client that takes a <code>Mono&lt;String&gt;</code> as the source of data for a <code>PUT</code> but
also looks for a particular Context key to add a correlation ID to the request&#8217;s headers.</p>
</div>
<div class="paragraph">
<p>现在，我们可以考虑一个更现实的例子，该图书馆从中读取信息Context：
一个反应性HTTP客户端，该客户端将 Mono&lt;String&gt;作为的数据源，PUT同时还寻找一个特定的Context键，以将相关ID添加到请求的标头中。</p>
</div>
<div class="paragraph">
<p>From the user perspective, it is called as follows:</p>
</div>
<div class="paragraph">
<p>从用户的角度来看，它称为：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">doPut("www.example.com", Mono.just("Walter"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In order to propagate a correlation ID, it would be called as follows:</p>
</div>
<div class="paragraph">
<p>为了传播相关性ID，将其称为如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">doPut("www.example.com", Mono.just("Walter"))
	.subscriberContext(Context.of(HTTP_CORRELATION_ID, "2-j3r9afaf92j-afkaf"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As the preceding snippets show, the user code uses <code>subscriberContext</code> to populate
a <code>Context</code> with an <code>HTTP_CORRELATION_ID</code> key-value pair. The upstream of the operator is
a <code>Mono&lt;Tuple2&lt;Integer, String&gt;&gt;</code> (a simplistic representation of an HTTP response)
returned by the HTTP client library. So it effectively passes information from the
user code to the library code.</p>
</div>
<div class="paragraph">
<p>如前面的片段所示，用户代码使用`subscriberContext`进行填充具有“ HTTP_CORRELATION_ID”键值对的“Context”。 操作员的上游是
一个Mono &lt;Tuple2 &lt;Integer，String &gt;&gt;`（HTTP响应的简单表示）
由HTTP客户端库返回。 因此它有效地传递了来自用户代码到库代码。</p>
</div>
<div class="paragraph">
<p>The following example shows mock code from the library&#8217;s perspective that reads the
context and &#8220;augments the request&#8221; if it can find the correlation ID:</p>
</div>
<div class="paragraph">
<p>以下示例从库的角度显示了模拟代码，该代码读取了context和“<code>augments the request</code>”（如果可以找到相关ID）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">static final String HTTP_CORRELATION_ID = "reactive.http.library.correlationId";

Mono&lt;Tuple2&lt;Integer, String&gt;&gt; doPut(String url, Mono&lt;String&gt; data) {
	Mono&lt;Tuple2&lt;String, Optional&lt;Object&gt;&gt;&gt; dataAndContext =
			data.zipWith(Mono.subscriberContext() <i class="conum" data-value="1"></i><b>(1)</b>
			                 .map(c -&gt; c.getOrEmpty(HTTP_CORRELATION_ID))); <i class="conum" data-value="2"></i><b>(2)</b>

	return dataAndContext
			.&lt;String&gt;handle((dac, sink) -&gt; {
				if (dac.getT2().isPresent()) { <i class="conum" data-value="3"></i><b>(3)</b>
					sink.next("PUT &lt;" + dac.getT1() + "&gt; sent to " + url + " with header X-Correlation-ID = " + dac.getT2().get());
				}
				else {
					sink.next("PUT &lt;" + dac.getT1() + "&gt; sent to " + url);
				}
				sink.complete();
			})
			.map(msg -&gt; Tuples.of(200, msg));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Materialize the <code>Context</code> through <code>Mono.subscriberContext()</code>. 通过 Mono.subscriberContext() 实现Context</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Extract a value for a the correlation ID key, as an <code>Optional</code>. 提取相关性ID密钥的值，作为Optional。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the key was present in the context, use the correlation ID as a header. 	如果密钥存在于context中，则将相关性ID用作标题。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>The library snippet zips the data <code>Mono</code> with
<code>Mono.subscriberContext()</code>. This gives the library a <code>Tuple2&lt;String, Context&gt;</code>, and that
context contains the <code>HTTP_CORRELATION_ID</code> entry from downstream (as it is on the direct
path to the subscriber).</p>
</div>
<div class="paragraph">
<p>库片段将数据`Mono`压缩为`Mono.subscriberContext（）<code>。 这给库一个`Tuple2 &lt;String，Context&gt;</code>，并且
上下文包含来自下游的HTTP_CORRELATION_ID条目（因为它位于直接订户的路径）。</p>
</div>
<div class="paragraph">
<p>The library code then uses <code>map</code> to extract an <code>Optional&lt;String&gt;</code> for that key, and, if
the entry is present, it uses the passed correlation ID as a <code>X-Correlation-ID</code> header.
That last part is simulated by the <code>handle</code>.</p>
</div>
<div class="paragraph">
<p>然后，库代码map用于提取Optional&lt;String&gt;该密钥的，并且，如果存在该条目，它将使用传递的相关ID作为X-Correlation-ID标头。最后一部分由进行模拟handle。</p>
</div>
<div class="paragraph">
<p>The whole test that validates the library code used the correlation ID can be written as
follows:</p>
</div>
<div class="paragraph">
<p>验证使用相关ID的库代码的整个测试可以编写如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void contextForLibraryReactivePut() {
	Mono&lt;String&gt; put = doPut("www.example.com", Mono.just("Walter"))
			.subscriberContext(Context.of(HTTP_CORRELATION_ID, "2-j3r9afaf92j-afkaf"))
			.filter(t -&gt; t.getT1() &lt; 300)
			.map(Tuple2::getT2);

	StepVerifier.create(put)
	            .expectNext("PUT &lt;Walter&gt; sent to www.example.com with header X-Correlation-ID = 2-j3r9afaf92j-afkaf")
	            .verifyComplete();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cleanup"><a class="anchor" href="#cleanup"></a>9.9. Dealing with Objects that Need Cleanup</h3>
<div class="paragraph">
<p>In very specific cases, your application may deal with types that necessitate some form of cleanup once they are no longer in use.
This is an advanced scenario&#8201;&#8212;&#8201;for, example when you have reference-counted objects or when you deal with off-heap objects.
Netty&#8217;s <code>ByteBuf</code> is a prime example of both.</p>
</div>
<div class="paragraph">
<p>在非常特定的情况下，您的应用程序可能会处理不再需要使用某种形式的清理的类型。这是一种高级方案，例如，当您有引用计数的对象或处理堆外对象时。Netty ByteBuf是这两者的典型例子。</p>
</div>
<div class="paragraph">
<p>In order to ensure proper cleanup of such objects, you need to account for it on a <code>Flux</code>-by-<code>Flux</code> basis, as well as in several of the global hooks (see <a href="#hooks">Using Global Hooks</a>):</p>
</div>
<div class="paragraph">
<p>为了确保正确清理此类对象，您需要基于“ Flux”（逐个）“ Flux”以及多个全局挂钩（see <a href="#hooks">Using Global Hooks</a>）进行考虑：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>doOnDiscard</code> <code>Flux</code>/<code>Mono</code> operator</p>
</li>
<li>
<p>The <code>onOperatorError</code> hook</p>
</li>
<li>
<p>The <code>onNextDropped</code> hook</p>
</li>
<li>
<p>Operator-specific handlers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is needed because each hook is made with a specific subset of cleanup in mind, and users might want (for example) to implement specific error-handling logic in addition to cleanup logic within <code>onOperatorError</code>.</p>
</div>
<div class="paragraph">
<p>之所以需要这样做，是因为每个挂钩都是根据特定的清理子集来进行的，并且用户可能希望（例如）除中的清理逻辑之外还实现特定的错误处理逻辑onOperatorError。</p>
</div>
<div class="paragraph">
<p>Note that some operators are less adapted to dealing with objects that need cleanup.
For example, <code>bufferWhen</code> can introduce overlapping buffers, and that means that the discard &#8220;local hook&#8221; we used earlier might see a first buffer as being discarded and cleanup an element in it that is in a second buffer, where it is still valid.</p>
</div>
<div class="paragraph">
<p>请注意，某些运算符不太适合处理需要清除的对象。
例如，“ bufferWhen”可以引入重叠的缓冲区，这意味着我们前面使用的丢弃“ local hook”可能会看到第一个缓冲区被丢弃，并清理其中第二个缓冲区中的元素。 仍然有效。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
For the purpose of cleaning up, <strong>all these hooks MUST be IDEMPOTENT</strong>.
They might on some occasions get applied several times to the same object.
Unlike the <code>doOnDiscard</code> operator, which performs a class-level <code>instanceOf</code> check, the global hooks are also dealing with instances that can be any <code>Object</code>. It is up to the user&#8217;s implementation to distinguish between which instances need cleanup and which do not.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
为了清理起见，<strong>所有这些钩子必须是确定的</strong>。
在某些情况下，它们可能会多次应用于同一对象。
与执行类级别的instanceOf检查的doOnDiscard运算符不同，全局挂钩也处理可以是任何Object的实例。 由用户的实现来区分哪些实例需要清除，哪些不需要。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_the_doondiscard_operator_or_local_hook"><a class="anchor" href="#_the_doondiscard_operator_or_local_hook"></a>9.9.1. The <code>doOnDiscard</code> Operator or Local Hook</h4>
<div class="paragraph">
<p>This hook has been specifically put in place for cleanup of objects that would otherwise never be exposed to user code.
It is intended as a cleanup hook for flows that operate under normal circumstances (not malformed sources that push too many items, which is covered by <code>onNextDropped</code>).</p>
</div>
<div class="paragraph">
<p>该挂钩专门用于清理对象，否则这些对象将永远不会暴露给用户代码。
它旨在用作在正常情况下运行的流的清理钩子（不是格式错误的源，用于推送过多的项目，这由`onNextDropped`覆盖）。</p>
</div>
<div class="paragraph">
<p>It is local, in the sense that it is activated through an operator and applies only to a given <code>Flux</code> or <code>Mono</code>.</p>
</div>
<div class="paragraph">
<p>它是本地的，从某种意义上说，它是通过激活操作符，并且仅适用于给定的Flux或Mono。</p>
</div>
<div class="paragraph">
<p>Obvious cases include operators that filter elements from upstream.
These elements never reach the next operator (or final subscriber), but this is part of the normal path of execution.
As such, they are passed to the <code>doOnDiscard</code> hook.
Examples of when you might use the <code>doOnDiscard</code> hook include the following:</p>
</div>
<div class="paragraph">
<p>明显的情况包括从上游过滤元素的运算符。这些元素永远不会到达下一个运算符（或最终订户），但这是正常执行路径的一部分。
这样，它们就传递给了doOnDiscard钩子。何时使用doOnDiscard挂钩的示例包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>filter</code>: Items that do not match the filter are considered to be &#8220;discarded.&#8221; 与过滤器不匹配的项目被视为“已丢弃”。</p>
</li>
<li>
<p><code>skip</code>: Skipped items are discarded. 跳过的项目将被丢弃</p>
</li>
<li>
<p><code>buffer(maxSize, skip)</code> with <code>maxSize &lt; skip</code>: A &#8220;dropping buffer&#8221;&#8201;&#8212;&#8201;items in between buffers are discarded. 一个“丢弃缓冲区” —缓冲区之间的项目被丢弃。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>But <code>doOnDiscard</code> is not limited to filtering operators, and is also used by operators that internally queue data for backpressure purposes.
More specifically, most of the time, this is important during cancellation. An operator that prefetches data from its source and later drains to its subscriber upon demand could have un-emitted data when it gets cancelled.
Such operators use the <code>doOnDiscard</code> hook during cancellation to clear up their internal backpressure <code>Queue</code>.</p>
</div>
<div class="paragraph">
<p>但是`doOnDiscard`不仅限于过滤运算符，还被内部排队数据以用于反压目的的运算符使用。
更具体地说，在大多数情况下，这在取消期间很重要。 从其源中预取数据，然后根据需要排到其订阅者上的操作符在取消数据时可能会收到未发射的数据。
这样的操作员在取消操作期间使用`doOnDiscard`挂钩来清除其内部背压`Queue'。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Each call to <code>doOnDiscard(Class, Consumer)</code> is additive with the others, to the extent that it is visible and used by only operators upstream of it.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
每次对doOnDiscard（Class，Consumer）的调用都会与其他调用相加，以使其只能被其上游的操作员看到并使用。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_the_onoperatorerror_hook"><a class="anchor" href="#_the_onoperatorerror_hook"></a>9.9.2. The <code>onOperatorError</code> hook</h4>
<div class="paragraph">
<p>The <code>onOperatorError</code> hook is intended to modify errors in a transverse manner (similar to an AOP catch-and-rethrow).</p>
</div>
<div class="paragraph">
<p>onOperatorError钩子旨在以横向方式修改错误（类似于AOP的捕捉和抛出）。</p>
</div>
<div class="paragraph">
<p>When the error happens during the processing of an <code>onNext</code> signal, the element that was being emitted is passed to <code>onOperatorError</code>.</p>
</div>
<div class="paragraph">
<p>当在处理onNext信号期间发生错误时，将要发出的元素传递给onOperatorError。</p>
</div>
<div class="paragraph">
<p>If that type of element needs cleanup, you need to implement it in the <code>onOperatorError</code> hook, possibly on top of error-rewriting code.</p>
</div>
<div class="paragraph">
<p>如果需要清除该类型的元素，则需要在onOperatorError钩子中实现它，可能在错误重写代码的顶部。</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_onnextdropped_hook"><a class="anchor" href="#_the_onnextdropped_hook"></a>9.9.3. The <code>onNextDropped</code> Hook</h4>
<div class="paragraph">
<p>With malformed <code>Publishers</code>, there could be cases where an operator receives an element when it expected none (typically, after having received the <code>onError</code> or <code>onComplete</code> signals).
In such cases, the unexpected element is &#8220;dropped&#8221;&#8201;&#8212;&#8201;that is, passed to the <code>onNextDropped</code> hook.
If you have types that need cleanup, you must detect these in the <code>onNextDropped</code> hook and implement cleanup code there as well.</p>
</div>
<div class="paragraph">
<p>对于格式错误的发布者，在某些情况下，操作员可能会在元素预期没有元素时收到该元素（通常是在收到onError或onComplete信号之后）。
在这种情况下，意外元素将被“丢弃”，即传递给onNextDropped挂钩。 如果您有需要清除的类型，则必须在onNextDropped挂钩中检测到它们，并在其中也执行清除代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="_operator_specific_handlers"><a class="anchor" href="#_operator_specific_handlers"></a>9.9.4. Operator-specific Handlers</h4>
<div class="paragraph">
<p>Some operators that deal with buffers or collect values as part of their operations have specific handlers for cases where collected data is not propagated downstream.
If you use such operators with the type(s) that need cleanup, you need to perform cleanup in these handlers.</p>
</div>
<div class="paragraph">
<p>一些处理缓冲区或在其操作过程中收集值的运算符具有特定的处理程序，用于收集的数据不向下游传播的情况。
如果将此类运算符与需要清除的类型一起使用，则需要在这些处理程序中执行清除。</p>
</div>
<div class="paragraph">
<p>For example, <code>distinct</code> has such a callback that is invoked when the operator terminates (or is cancelled) in order to clear the collection it uses to judge whether an element is distinct or not.
By default, the collection is a <code>HashSet</code>, and the cleanup callback is a <code>HashSet::clear</code>.
However, if you deal with reference-counted objects, you might want to change that to a more involved handler that would <code>release</code> each element in the set before calling <code>clear()</code> on it.</p>
</div>
<div class="paragraph">
<p>例如，distinct具有这样的回调，当操作员终止（或取消）时，将调用该回调，以清除其用于判断元素是否与众不同的集合。
默认情况下，集合是HashSet，清理回调是HashSet :: clear。
但是，如果处理引用计数的对象，则可能需要将其更改为涉及更多的处理程序，该处理程序在调用clear（）之前会释放集合中的每个元素。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="null-safety"><a class="anchor" href="#null-safety"></a>9.10. Null Safety</h3>
<div class="paragraph">
<p>Although Java does not allow expressing null-safety with its type system, Reactor
now provides annotations to declare nullability of APIs, similar to those provided by
Spring Framework 5.</p>
</div>
<div class="paragraph">
<p>尽管Java不允许使用其类型系统表示空安全性，但是Reactor现在提供了注释来声明API的空性，类似于Spring Framework 5提供的注释。</p>
</div>
<div class="paragraph">
<p>Reactor uses these annotations, but they can also be used in any Reactor-based
Java project to declare null-safe APIs. Nullability of the types used inside method bodies
is outside of the scope of this feature.</p>
</div>
<div class="paragraph">
<p>Reactor使用这些注释，但也可以在任何基于Reactor的Java项目中使用它们来声明空安全的API。
方法主体内使用的类型的可空性超出了此功能的范围。</p>
</div>
<div class="paragraph">
<p>These annotations are meta-annotated with <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>
annotations (a dormant JSR that is supported by tools such as IntelliJ IDEA) to provide
useful warnings to Java developers related to null-safety in order to avoid
<code>NullPointerException</code> at runtime. JSR 305 meta-annotations let tooling vendors
provide null safety support in a generic way, without having to hard-code support for Reactor annotations.</p>
</div>
<div class="paragraph">
<p>这些注释用JSR 305注释（由IntelliJ IDEA之类的工具支持的休眠JSR）进行元注释，以向Java开发人员提供有关空安全性的有用警告，以避免在运行时出现NullPointerException。
JSR 305元注释使工具供应商能够以通用方式提供空安全支持，而不必对Reactor注释进行硬编码支持。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is not necessary nor recommended with Kotlin 1.1.5+ to have a dependency on JSR 305 in
your project classpath.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>They are also used by Kotlin, which natively supports
<a href="https://kotlinlang.org/docs/reference/null-safety.html">null safety</a>. See
<a href="#kotlin-null-safety">this dedicated section</a> for more details.</p>
</div>
<div class="paragraph">
<p>The following annotations are provided in the <code>reactor.util.annotation</code> package:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/NonNull.html"><code>@NonNull</code></a>:
Indicates that a specific parameter, return value, or field cannot be <code>null</code>.
(It is not needed on parameters and return values where <code>@NonNullApi</code> applies) .</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/Nullable.html"><code>@Nullable</code></a>:
Indicates that a parameter, return value, or field can be <code>null</code>.</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/NonNullApi.html"><code>@NonNullApi</code></a>:
Package-level annotation that indicates non-null is the default behavior for
parameters and return values.</p>
</li>
<li>
<p>指示特定的参数，返回值或字段不能为null。 （在@NonNullApi适用的参数和返回值上不需要）。</p>
</li>
<li>
<p>表示参数，返回值或字段可以为null。</p>
</li>
<li>
<p>指示非空的程序包级注释是参数和返回值的默认行为。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Nullability for generic type arguments, variable arguments, and array elements is not yet supported.
See <a href="https://github.com/reactor/reactor-core/issues/878">issue #878</a> for up-to-date
information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/advancedFeatures.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#advanced">Advanced Features and Concepts</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="which-operator"><a class="anchor" href="#which-operator"></a>Appendix A: Which operator do I need?</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In this section, if an operator is specific to <code>Flux</code> or <code>Mono</code>, it is
prefixed accordingly. Common operators have no prefix. When a specific use case
is covered by a combination of operators, it is presented as a method call, with
leading dot and parameters in parentheses, as follows: <code>.methodCall(parameter)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>I want to deal with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#which.create">Creating a New Sequence&#8230;&#8203;</a></p>
</li>
<li>
<p><a href="#which.values">Transforming an Existing Sequence</a></p>
</li>
<li>
<p><a href="#which.filtering">Filtering a Sequence</a></p>
</li>
<li>
<p><a href="#which.peeking">Peeking into a Sequence</a></p>
</li>
<li>
<p><a href="#which.errors">Handling Errors</a></p>
</li>
<li>
<p><a href="#which.time">Working with Time</a></p>
</li>
<li>
<p><a href="#which.window">Splitting a <code>Flux</code></a></p>
</li>
<li>
<p><a href="#which.blocking">Going Back to the Synchronous World</a></p>
</li>
<li>
<p><a href="#which.multicasting">Multicasting a <code>Flux</code> to several <code>Subscribers</code></a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="which.create"><a class="anchor" href="#which.create"></a>A.1. Creating a New Sequence&#8230;&#8203;</h3>
<div class="ulist">
<ul>
<li>
<p>that emits a <code>T</code>, and I already have: <code>just</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;from an <code>Optional&lt;T&gt;</code>: <code>Mono#justOrEmpty(Optional&lt;T&gt;)</code></p>
</li>
<li>
<p>&#8230;&#8203;from a potentially <code>null</code> T: <code>Mono#justOrEmpty(T)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>that emits a <code>T</code> returned by a method: <code>just</code> as well</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but lazily captured: use <code>Mono#fromSupplier</code> or wrap <code>just</code> inside <code>defer</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>that emits several <code>T</code> I can explicitly enumerate: <code>Flux#just(T&#8230;&#8203;)</code></p>
</li>
<li>
<p>that iterates over:</p>
<div class="ulist">
<ul>
<li>
<p>an array: <code>Flux#fromArray</code></p>
</li>
<li>
<p>a collection or iterable: <code>Flux#fromIterable</code></p>
</li>
<li>
<p>a range of integers: <code>Flux#range</code></p>
</li>
<li>
<p>a <code>Stream</code> supplied for each Subscription: <code>Flux#fromStream(Supplier&lt;Stream&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>that emits from various single-valued sources such as:</p>
<div class="ulist">
<ul>
<li>
<p>a <code>Supplier&lt;T&gt;</code>: <code>Mono#fromSupplier</code></p>
</li>
<li>
<p>a task: <code>Mono#fromCallable</code>, <code>Mono#fromRunnable</code></p>
</li>
<li>
<p>a <code>CompletableFuture&lt;T&gt;</code>: <code>Mono#fromFuture</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>that completes: <code>empty</code></p>
</li>
<li>
<p>that errors immediately: <code>error</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but lazily build the <code>Throwable</code>: <code>error(Supplier&lt;Throwable&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>that never does anything: <code>never</code></p>
</li>
<li>
<p>that is decided at subscription: <code>defer</code></p>
</li>
<li>
<p>that depends on a disposable resource: <code>using</code></p>
</li>
<li>
<p>that generates events programmatically (can use state):</p>
<div class="ulist">
<ul>
<li>
<p>synchronously and one-by-one: <code>Flux#generate</code></p>
</li>
<li>
<p>asynchronously (can also be sync), multiple emissions possible in one pass: <code>Flux#create</code>
(<code>Mono#create</code> as well, without the multiple emission aspect)</p>
</li>
</ul>
</div>
</li>
<li>
<p>发射 <code>T</code>, 已经有了: <code>just</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;获取一个 <code>Optional&lt;T&gt;</code>: <code>Mono#justOrEmpty(Optional&lt;T&gt;)</code></p>
</li>
<li>
<p>&#8230;&#8203;获取一个可能为 <code>null</code> 的T值: <code>Mono#justOrEmpty(T)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过方法返回一个`T`并进行发射`T`: <code>just</code> as well</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;为了延迟加载: 使用 <code>Mono#fromSupplier</code> or 在定义的内部返回一个包装的just</p>
</li>
</ul>
</div>
</li>
<li>
<p>发射几个可以明确列举的 <code>T</code> : <code>Flux#just(T&#8230;&#8203;)</code></p>
</li>
<li>
<p>遍历:</p>
<div class="ulist">
<ul>
<li>
<p>一个数组: <code>Flux#fromArray</code></p>
</li>
<li>
<p>一个 collection 或者 iterable: <code>Flux#fromIterable</code></p>
</li>
<li>
<p>一个整数范围: <code>Flux#range</code></p>
</li>
<li>
<p>为每个订阅提供了一个“Stream”: <code>Flux#fromStream(Supplier&lt;Stream&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>从各种单值来源发出，例如:</p>
<div class="ulist">
<ul>
<li>
<p>一个 <code>Supplier&lt;T&gt;</code>: <code>Mono#fromSupplier</code></p>
</li>
<li>
<p>一个任务: <code>Mono#fromCallable</code>, <code>Mono#fromRunnable</code></p>
</li>
<li>
<p>一个 <code>CompletableFuture&lt;T&gt;</code>: <code>Mono#fromFuture</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>完成一个空值: <code>empty</code></p>
</li>
<li>
<p>立即错误: <code>error</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;也可以延迟构建 <code>Throwable</code>: <code>error(Supplier&lt;Throwable&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>不做如何事情: <code>never</code></p>
</li>
<li>
<p>在订阅时定义: <code>defer</code></p>
</li>
<li>
<p>取决于可用资源: <code>using</code></p>
</li>
<li>
<p>以编程方式生成事件 (可使用状态):</p>
<div class="ulist">
<ul>
<li>
<p>同步的: <code>Flux#generate</code></p>
</li>
<li>
<p>异步地 (也可以同步), 一次通过可能产生多种发射: <code>Flux#create</code>
(<code>Mono#create</code> as well, without the multiple emission aspect)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.values"><a class="anchor" href="#which.values"></a>A.2. Transforming an Existing Sequence</h3>
<div class="ulist">
<ul>
<li>
<p>I want to transform existing data:</p>
<div class="ulist">
<ul>
<li>
<p>on a 1-to-1 basis (eg. strings to their length): <code>map</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;by just casting it: <code>cast</code></p>
</li>
<li>
<p>&#8230;&#8203;in order to materialize each source value&#8217;s index: <code>Flux#index</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>on a 1-to-n basis (eg. strings to their characters): <code>flatMap</code> + use a factory method</p>
</li>
<li>
<p>on a 1-to-n basis with programmatic behavior for each source element and/or state: <code>handle</code></p>
</li>
<li>
<p>running an asynchronous task for each source item (eg. urls to http request): <code>flatMap</code> + an async <code>Publisher</code>-returning method</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;ignoring some data: conditionally return a <code>Mono.empty()</code> in the flatMap lambda</p>
</li>
<li>
<p>&#8230;&#8203;retaining the original sequence order: <code>Flux#flatMapSequential</code> (this triggers the async processes immediately but reorders the results)</p>
</li>
<li>
<p>&#8230;&#8203;where the async task can return multiple values, from a <code>Mono</code> source: <code>Mono#flatMapMany</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want to add pre-set elements to an existing sequence:</p>
<div class="ulist">
<ul>
<li>
<p>at the start: <code>Flux#startWith(T&#8230;&#8203;)</code></p>
</li>
<li>
<p>at the end: <code>Flux#concatWith(T&#8230;&#8203;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>I want to aggregate a <code>Flux</code>: (the <code>Flux#</code> prefix is assumed below)</p>
<div class="ulist">
<ul>
<li>
<p>into a List: <code>collectList</code>, <code>collectSortedList</code></p>
</li>
<li>
<p>into a Map: <code>collectMap</code>, <code>collectMultiMap</code></p>
</li>
<li>
<p>into an arbitrary container: <code>collect</code></p>
</li>
<li>
<p>into the size of the sequence: <code>count</code></p>
</li>
<li>
<p>by applying a function between each element (eg. running sum): <code>reduce</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;but emitting each intermediary value: <code>scan</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>into a boolean value from a predicate:</p>
<div class="ulist">
<ul>
<li>
<p>applied to all values (AND): <code>all</code></p>
</li>
<li>
<p>applied to at least one value (OR): <code>any</code></p>
</li>
<li>
<p>testing the presence of any value: <code>hasElements</code></p>
</li>
<li>
<p>testing the presence of a specific value: <code>hasElement</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想转换现有数据</p>
<div class="ulist">
<ul>
<li>
<p>基于一对一 (例如. 字符串长度): <code>map</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;只需投射它: <code>cast</code></p>
</li>
<li>
<p>&#8230;&#8203;为了实现每个源值的索引: <code>Flux#index</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>在1-n的基础上（例如，将字符串转换为字符）: <code>flatMap</code> + 使用工厂方法</p>
</li>
<li>
<p>在一对一的基础上，针对每个源元素和/或状态进行编程行为: <code>handle</code></p>
</li>
<li>
<p>为每个源项目运行异步任务（例如，http请求的网址）: <code>flatMap</code> + 异步 <code>Publisher</code> 返回方法</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;忽略一些数据：在flatMap lambda中有条件地返回`Mono.empty（）`</p>
</li>
<li>
<p>&#8230;&#8203;保留原始顺序：<code>Flux＃flatMapSequential</code>（这会立即触发异步过程，但会对结果重新排序）</p>
</li>
<li>
<p>&#8230;&#8203;异步任务可以从“ Mono”源返回多个值：“ Mono＃flatMapMany”</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想将预设元素添加到现有序列中：</p>
<div class="ulist">
<ul>
<li>
<p>在开头: <code>Flux#startWith(T&#8230;&#8203;)</code></p>
</li>
<li>
<p>在结尾: <code>Flux#concatWith(T&#8230;&#8203;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想要聚合一个 <code>Flux</code>: (the <code>Flux#</code> prefix is assumed below)</p>
<div class="ulist">
<ul>
<li>
<p>转换一个 List: <code>collectList</code>, <code>collectSortedList</code></p>
</li>
<li>
<p>转换一个 Map: <code>collectMap</code>, <code>collectMultiMap</code></p>
</li>
<li>
<p>放入任意容器中: <code>collect</code></p>
</li>
<li>
<p>转换为序列的大小: <code>count</code></p>
</li>
<li>
<p>通过在每个元素之间应用函数（例如，运行总和）: <code>reduce</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;散发出每个中介价值: <code>scan</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>断言转换成布尔值:</p>
<div class="ulist">
<ul>
<li>
<p>应用于所有值（AND）： all</p>
</li>
<li>
<p>应用于至少一个值（OR）： any</p>
</li>
<li>
<p>测试是否存在任何值： hasElements</p>
</li>
<li>
<p>测试特定值的存在： hasElement</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我要合并发布者&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>按顺序：Flux#concat或.concatWith(other)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;会延迟任何错误，直到发出剩余的发布者为止：<code>Flux＃concatDelayError</code></p>
</li>
<li>
<p>&#8230;&#8203;热切地订阅后续的发布者：<code>Flux＃mergeSequential</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>按排放顺序（合并的项目随其发射而来）：<code>Flux＃merge</code> /<code>.mergeWith（other）</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;具有不同类型的。（转换合并）：<code>Flux＃zip</code> /<code>Flux＃zipWith</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过配对值:</p>
<div class="ulist">
<ul>
<li>
<p>从2个Monos变成一个`Tuple2`：<code>Mono＃zipWith</code></p>
</li>
<li>
<p>全部完成时从n个Monos中获取：<code>Mono＃zip</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过协调其终止：</p>
<div class="ulist">
<ul>
<li>
<p>从1个Mono和任何源到一个Mono &lt;Void&gt;`：<code>Mono＃and</code></p>
</li>
<li>
<p>当它们全部完成时，从n个来源中获取：<code>Mono＃when</code></p>
</li>
<li>
<p>转换为任意容器类型：</p>
<div class="ulist">
<ul>
<li>
<p>每次发射出所有信号时：<code>Flux＃zip</code>（直至最小基数）</p>
</li>
<li>
<p>每当有新值到达任一侧时：<code>Flux＃combineLatest</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>只考虑先发出的序列：<code>Flux＃first</code>，<code>Mono＃first</code>，<code>mono.or
（otherMono）.or（thirdMono）</code>，<code>flux.or（otherFlux）.or（thirdFlux）</code></p>
</li>
<li>
<p>由源序列中的元素触发：<code>switchMap</code>（每个源元素都映射到发布者）</p>
</li>
<li>
<p>由发布者序列中的下一个发布者的开始触发：<code>switchOnNext</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想重复一个现有的序列： repeat</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;每隔一段时间: <code>Flux.interval(duration).flatMap(tick &#8594; myExistingPublisher)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个空序列，但是&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>我想要一个值: <code>defaultIfEmpty</code></p>
</li>
<li>
<p>我想要另一个序列: <code>switchIfEmpty</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个序列，但对值不感兴趣: <code>ignoreElements</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;我希望将完成表示为 <code>Mono</code>: <code>then</code></p>
</li>
<li>
<p>&#8230;&#8203;我想等到最后一个任务完成: <code>thenEmpty</code></p>
</li>
<li>
<p>&#8230;&#8203;最后我想切换到另一个`Mono`: <code>Mono#then(mono)</code></p>
</li>
<li>
<p>&#8230;&#8203;我最后想发出一个值: <code>Mono#thenReturn(T)</code></p>
</li>
<li>
<p>&#8230;&#8203;最后我想切换到 Flux: <code>thenMany</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个Mono，我想推迟完成&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;直到从该值派生的另一个发布者完成为止: <code>Mono#delayUntil(Function)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想要递归地将元素展开成序列图，并发出组合…&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;首先扩展图的宽度: <code>expand(Function)</code></p>
</li>
<li>
<p>&#8230;&#8203;首先扩展图形深度: <code>expandDeep(Function)</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.peeking"><a class="anchor" href="#which.peeking"></a>A.3. Peeking into a Sequence</h3>
<div class="ulist">
<ul>
<li>
<p>在不修改最终顺序的情况下，我想:</p>
<div class="ulist">
<ul>
<li>
<p>得到通知/执行附加行为(有时称为“副作用”):</p>
<div class="ulist">
<ul>
<li>
<p>发射: <code>doOnNext</code></p>
</li>
<li>
<p>完成: <code>Flux#doOnComplete</code>, <code>Mono#doOnSuccess</code> (包含结果，如果有的话)</p>
</li>
<li>
<p>错误终止: <code>doOnError</code></p>
</li>
<li>
<p>消除: <code>doOnCancel</code></p>
</li>
<li>
<p>序列的“开始”: <code>doFirst</code></p>
<div class="ulist">
<ul>
<li>
<p>对应 <code>Publisher#subscribe(Subscriber)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>订阅后 : <code>doOnSubscribe</code></p>
<div class="ulist">
<ul>
<li>
<p>就像在 <code>Subscription</code> <code>subscribe</code> 确认之后</p>
</li>
<li>
<p>对应`Subscriber#onSubscribe(Subscription)`</p>
</li>
</ul>
</div>
</li>
<li>
<p>请求: <code>doOnRequest</code></p>
</li>
<li>
<p>完成或错误: <code>doOnTerminate</code> (Mono 版本包含结果)</p>
<div class="ulist">
<ul>
<li>
<p>但是 <strong>after</strong> 会被传播到下游: <code>doAfterTerminate</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>任何类型的信号，表示为 <code>Signal</code>: <code>Flux#doOnEach</code></p>
</li>
<li>
<p>任何终止条件 (complete, error, cancel): <code>doFinally</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>记录内部发生的情况: <code>log</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想知道所有事件:</p>
<div class="ulist">
<ul>
<li>
<p>每个表示为Signal对象:</p>
<div class="ulist">
<ul>
<li>
<p>在序列外的回调中: <code>doOnEach</code></p>
</li>
<li>
<p>而不是原始的onNext发射: <code>materialize</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;回到onNexts: <code>dematerialize</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>作为日志中的一行: <code>log</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.filtering"><a class="anchor" href="#which.filtering"></a>A.4. Filtering a Sequence</h3>
<div class="ulist">
<ul>
<li>
<p>我想过滤一个序列:</p>
<div class="ulist">
<ul>
<li>
<p>基于任意标准: <code>filter</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;是异步计算的: <code>filterWhen</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>限制发射对象的类型: <code>ofType</code></p>
</li>
<li>
<p>通过完全忽略这些值: <code>ignoreElements</code></p>
</li>
<li>
<p>通过忽略重复项:</p>
<div class="ulist">
<ul>
<li>
<p>在整个序列（逻辑集合）中: <code>Flux#distinct</code></p>
</li>
<li>
<p>在后续发射的项目之间（重复数据删除）: <code>Flux#distinctUntilChanged</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我只想保留序列的一个子集:</p>
<div class="ulist">
<ul>
<li>
<p>通过取N个元素:</p>
<div class="ulist">
<ul>
<li>
<p>在序列的开头: <code>Flux#take(long)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;基于持续时间: <code>Flux#take(Duration)</code></p>
</li>
<li>
<p>&#8230;&#8203;仅第一个元素, 如 <code>Mono</code>: <code>Flux#next()</code></p>
</li>
<li>
<p>&#8230;&#8203;使用request(N)而不是取消: <code>Flux#limitRequest(long)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>在序列的末尾: <code>Flux#takeLast</code></p>
</li>
<li>
<p>u直到满足标准（包括）为止: <code>Flux#takeUntil</code> (predicate-based), <code>Flux#takeUntilOther</code> (companion publisher-based)</p>
</li>
<li>
<p>符合条件（不包括）时: <code>Flux#takeWhile</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>最多采用1个元素:</p>
<div class="ulist">
<ul>
<li>
<p>在特定位置: <code>Flux#elementAt</code></p>
</li>
<li>
<p>在末尾: <code>.takeLast(1)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;并且如果为空则发出错误: <code>Flux#last()</code></p>
</li>
<li>
<p>&#8230;&#8203;并发出默认值（如果为空: <code>Flux#last(T)</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>通过跳过元素:</p>
<div class="ulist">
<ul>
<li>
<p>在序列的开头: <code>Flux#skip(long)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;基于持续时间: <code>Flux#skip(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>在序列的末尾: <code>Flux#skipLast</code></p>
</li>
<li>
<p>直到满足标准（包括）为止: <code>Flux#skipUntil</code> (predicate-based), <code>Flux#skipUntilOther</code> (companion publisher-based)</p>
</li>
<li>
<p>符合条件（不包括）时: <code>Flux#skipWhile</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过抽样项目:</p>
<div class="ulist">
<ul>
<li>
<p>按持续时间: <code>Flux#sample(Duration)</code></p>
<div class="ulist">
<ul>
<li>
<p>但是将第一个元素而不是最后一个元素保留在采样窗口中: <code>sampleFirst</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过基于发布者的窗口: <code>Flux#sample(Publisher)</code></p>
</li>
<li>
<p>基于发布者的“定时” : <code>Flux#sampleTimeout</code> (每个元素触发一个发布者，如果该发布者与下一个不重叠则发出)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我期望最多1个元素（如果超过一个元素则会出错）&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>如果序列为空，我想要一个错误: <code>Flux#single()</code></p>
</li>
<li>
<p>如果序列为空，我想要一个默认值: <code>Flux#single(T)</code></p>
</li>
<li>
<p>我也接受一个空序列: <code>Flux#singleOrEmpty</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.errors"><a class="anchor" href="#which.errors"></a>A.5. Handling Errors</h3>
<div class="ulist">
<ul>
<li>
<p>我想创建一个错误的序列: <code>error</code>&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;代替成功的完成 <code>Flux</code>: <code>.concat(Flux.error(e))</code></p>
</li>
<li>
<p>&#8230;&#8203;代替成功发射的 <code>Mono</code>: <code>.then(Mono.error(e))</code></p>
</li>
<li>
<p>&#8230;&#8203;如果两次onNexts之间的时间过长: <code>timeout</code></p>
</li>
<li>
<p>&#8230;&#8203;异步: <code>error(Supplier&lt;Throwable&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想要等效的try / catch:</p>
<div class="ulist">
<ul>
<li>
<p>throwing: <code>error</code></p>
</li>
<li>
<p>捕获异常:</p>
<div class="ulist">
<ul>
<li>
<p>并退回到默认值: <code>onErrorReturn</code></p>
</li>
<li>
<p>然后掉落到另一个Flux或Mono: <code>onErrorResume</code></p>
</li>
<li>
<p>并包装并重新抛出: <code>.onErrorMap(t &#8594; new RuntimeException(t))</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>the finally block: <code>doFinally</code></p>
</li>
<li>
<p>Java 7中的使用模式: <code>using</code> factory method</p>
</li>
</ul>
</div>
</li>
<li>
<p>我想从错误中恢复&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>通过后退:</p>
<div class="ulist">
<ul>
<li>
<p>值: <code>onErrorReturn</code></p>
</li>
<li>
<p>转换到 <code>Publisher</code> or <code>Mono</code>, 可能是不同的，这取决于不同错误: <code>Flux#onErrorResume</code> and <code>Mono#onErrorResume</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>重试: <code>retry</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;从简单的策略（尝试的最大数量: retry(), retry(long)</p>
</li>
<li>
<p>&#8230;&#8203;由同伴控件Flux触发: <code>retryWhen</code></p>
</li>
<li>
<p>&#8230;&#8203; 使用标准的回退策略(带抖动的指数回退):retryWhen(Retry.backoff(…))(请参阅重试中的其他工厂方法)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想处理背压``错误''（来自上游的最大请求数，并在下游没有产生足够的请求时应用该策略）&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>通过抛出一个特殊的 <code>IllegalStateException</code>: <code>Flux#onBackpressureError</code></p>
</li>
<li>
<p>通过删除多余的值: <code>Flux#onBackpressureDrop</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;除了最后看到的一个: <code>Flux#onBackpressureLatest</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过缓冲多余的值（有界或无界: <code>Flux#onBackpressureBuffer</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;在有界缓冲区也溢出时应用策略: <code>Flux#onBackpressureBuffer</code> with a <code>BufferOverflowStrategy</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.time"><a class="anchor" href="#which.time"></a>A.6. Working with Time</h3>
<div class="ulist">
<ul>
<li>
<p>我想将发射与时间相联系起来 (<code>Tuple2&lt;Long, T&gt;</code>) 测量&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>自订阅以来: <code>elapsed</code></p>
</li>
<li>
<p>从时间的开端 (well, 计算机的时间): <code>timestamp</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>如果发射之间的延迟太长，我希望中断我的序列: <code>timeout</code></p>
</li>
<li>
<p>我想从一个时钟上得到滴答声，有规律的时间间隔: <code>Flux#interval</code></p>
</li>
<li>
<p>我想在初始延迟后发出一个0 : static <code>Mono.delay</code>.</p>
</li>
<li>
<p>我想引进一个延迟:
**每个onNext信号之间: <code>Mono#delayElement</code>, <code>Flux#delayElements</code></p>
<div class="ulist">
<ul>
<li>
<p>订阅发生之前: <code>delaySubscription</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.window"><a class="anchor" href="#which.window"></a>A.7. Splitting a <code>Flux</code></h3>
<div class="ulist">
<ul>
<li>
<p>我想通过边界条件将 Flux&lt;T&gt;划分为Flux&lt;Flux&lt;T&gt;&gt;：</p>
<div class="ulist">
<ul>
<li>
<p>大小: <code>window(int)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;窗口重叠或掉落: <code>window(int, int)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>时间的 <code>window(持续)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;重叠或掉落的窗户: <code>window(Duration, Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>大小或者时间 (达到计数或超时后窗口关闭): <code>windowTimeout(int, Duration)</code></p>
</li>
<li>
<p>基于元素的发射: <code>windowUntil</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;…在下一个窗口中发出触发边界的元素 (<code>cutBefore</code> variant): <code>.windowUntil(predicate, true)</code></p>
</li>
<li>
<p>&#8230;&#8203;元素与断言匹配时保持窗口打开: <code>windowWhile</code> (没有匹配的元素不发射)</p>
</li>
</ul>
</div>
</li>
<li>
<p>由控件发布器中的ONEXTS可以驱动任意边界: <code>window(Publisher)</code>, <code>windowWhen</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想将一个 Flux&lt;T&gt;元素 和缓冲区中的元素分割在一起</p>
<div class="ulist">
<ul>
<li>
<p>转换到 <code>List</code>:</p>
<div class="ulist">
<ul>
<li>
<p>通过大小边界: <code>buffer(int)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;缓冲区重叠或丢弃: <code>buffer(int, int)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过持续时间边界: <code>buffer(Duration)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;缓冲区重叠或丢弃: <code>buffer(Duration, Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过大小或持续时间边界: <code>bufferTimeout(int, Duration)</code></p>
</li>
<li>
<p>通过任意标准边界: <code>bufferUntil(Predicate)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;将触发边界的元素放入下一个缓冲区: <code>.bufferUntil(predicate, true)</code></p>
</li>
<li>
<p>&#8230;&#8203;在断言匹配时缓冲并丢弃触发边界的元素 <code>bufferWhile(Predicate)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>由控件发布器中的ONEXTS可以驱动任意边界: <code>buffer(Publisher)</code>, <code>bufferWhen</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>变成任意的“集合”类型C：使用变体，如 <code>buffer(int, Supplier&lt;C&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想分裂一个`Flux&lt;T&gt;` 这样一个具有相同特性的元素就会在同一个子flux中结束: <code>groupBy(Function&lt;T,K&gt;)</code>
提示：请注意，这将返回一个 Flux&lt;GroupedFlux&lt;K, T&gt;&gt;，每个内部GroupedFlux共享K可通过访问的相同的方法key().</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.blocking"><a class="anchor" href="#which.blocking"></a>A.8. Going Back to the Synchronous World</h3>
<div class="paragraph">
<p>注意：在一个"非堵塞"的`Scheduler` (by default <code>parallel()</code> and <code>single()</code>) 上调用所有这些方法，
除了 `Mono#toFuture`都会抛出一个`UnsupportedOperatorException`的异常，</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我有一个 <code>Flux&lt;T&gt;</code> 我想要:</p>
<div class="ulist">
<ul>
<li>
<p>阻塞，直到我得到第一个元素: <code>Flux#blockFirst</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;超时: <code>Flux#blockFirst(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>阻塞，直到我可以获取最后一个元素（如果为空，则返回null）: <code>Flux#blockLast</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;超时: <code>Flux#blockLast(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>同步切换到 <code>Iterable&lt;T&gt;</code>: <code>Flux#toIterable</code></p>
</li>
<li>
<p>同步切换到Java 8 <code>Stream&lt;T&gt;</code>: <code>Flux#toStream</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个 <code>Mono&lt;T&gt;</code> and 我想要:</p>
<div class="ulist">
<ul>
<li>
<p>阻塞直到我可以得到值: <code>Mono#block</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;超时: <code>Mono#block(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>a <code>CompletableFuture&lt;T&gt;</code>: <code>Mono#toFuture</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.multicasting"><a class="anchor" href="#which.multicasting"></a>A.9. Multicasting a <code>Flux</code> to several <code>Subscribers</code></h3>
<div class="ulist">
<ul>
<li>
<p>我想将多个 <code>Subscriber</code> 链接到 <code>Flux</code>:</p>
<div class="ulist">
<ul>
<li>
<p>决定何时触发源，使用`connect()<code>: `publish()</code> (returns a <code>ConnectableFlux</code>)</p>
</li>
<li>
<p>并立即触发源（后期订阅者可以查看以后的数据）: <code>share()</code></p>
</li>
<li>
<p>当有足够的用户注册时，永久连接源: <code>.publish().autoConnect(n)</code></p>
</li>
<li>
<p>当组织者超过/低于阈值时，自动连接和取消源: <code>.publish().refCount(n)</code></p>
<div class="ulist">
<ul>
<li>
<p>..​让新的注册者有机会在取消前进来： <code>.publish().refCountGrace(n, Duration)</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想从发布服务器缓存数据并将其重放给以后的订阅者:</p>
<div class="ulist">
<ul>
<li>
<p>取决于n元素: <code>cache(int)</code></p>
</li>
<li>
<p>缓存Duration（生存时间）中看到的最新元素 (Time-To-Live): <code>cache(Duration)</code></p>
<div class="ulist">
<ul>
<li>
<p>..只保留以下n元素: <code>cache(int, Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>但不立即触发来源: <code>Flux#replay</code> (returns a <code>ConnectableFlux</code>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/apdx-operatorChoice.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#which-operator">Which operator do I need?</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="faq"><a class="anchor" href="#faq"></a>Appendix B: FAQ, Best Practices, and "How do I&#8230;&#8203;?"</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section covers the following content:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#faq.wrap-blocking">How Do I Wrap a Synchronous, Blocking Call? 如何包装同步阻塞呼叫?</a></p>
</li>
<li>
<p><a href="#faq.chain">I Used an Operator on my <code>Flux</code> but it Doesn&#8217;t Seem to Apply. What Gives?</a></p>
</li>
<li>
<p><a href="#faq.monoThen">[faq.monoThen]</a></p>
</li>
<li>
<p><a href="#faq.retryWhen">How to Use <code>retryWhen</code> to Emulate <code>retry(3)</code>?</a></p>
</li>
<li>
<p><a href="#faq.exponentialBackoff">How can I use <code>retryWhen</code> for Exponential Backoff?</a></p>
</li>
<li>
<p><a href="#faq.thread-affinity-publishon">How Do I Ensure Thread Affinity when I Use <code>publishOn()</code>?</a></p>
</li>
<li>
<p><a href="#faq.mdc">What Is a Good Pattern for Contextual Logging? (MDC)</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="faq.wrap-blocking"><a class="anchor" href="#faq.wrap-blocking"></a>B.1. How Do I Wrap a Synchronous, Blocking Call? 如何包装同步阻塞呼叫?</h3>
<div class="paragraph">
<p>通常情况下，信息源是同步和阻塞的。 若要处理反应堆应用程序中的此类源，请应用以下模式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Mono blockingWrapper = Mono.fromCallable(() -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    return /* make a remote synchronous call */ <i class="conum" data-value="2"></i><b>(2)</b>
});
blockingWrapper = blockingWrapper.subscribeOn(Schedulers.boundedElastic()); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用fromCallable创建一个新Mono的。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>返回异步的阻塞资源.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>确保每个订阅都发生在来自`Schedulers.boundedElastic()`的专用单线程上运行</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>You should use a <code>Mono</code>, because the source returns one value. You should use
<code>Schedulers.boundedElastic</code>, because it creates a dedicated thread to wait for the
blocking resource without impacting other non-blocking processing, while also ensuring
that there is a limit to the amount of threads that can be created, and blocking tasks
that can be enqueued and deferred during a spike.</p>
</div>
<div class="paragraph">
<p>您应该使用 Mono，因为源返回一个值。 您应该使用`Schedulers.boundedElastic`，因为它创建了一个专用线程来等待阻塞资源，而不会影响其他非阻塞处理，
同时还确保可以创建的线程数量有限制，以及可以在尖峰期间排队和延迟的阻塞任务。</p>
</div>
<div class="paragraph">
<p>Note that <code>subscribeOn</code> does not subscribe to the <code>Mono</code>. It specifies what
kind of <code>Scheduler</code> to use when a subscribe call happens.</p>
</div>
<div class="paragraph">
<p>请注意，<code>subscribeOn</code> 不订阅Mono。 它指定在发生订阅调用时使用哪种调度器。</p>
</div>
</div>
<div class="sect2">
<h3 id="faq.chain"><a class="anchor" href="#faq.chain"></a>B.2. I Used an Operator on my <code>Flux</code> but it Doesn&#8217;t Seem to Apply. What Gives?</h3>
<div class="paragraph">
<p>Make sure that the variable you <code>.subscribe()</code> to has been affected by the
operators you think should have been applied to it.</p>
</div>
<div class="paragraph">
<p>确保你`subscribe()`的变量已经受到您认为应该应用于它的运算符的影响。</p>
</div>
<div class="paragraph">
<p>Reactor operators are decorators. They return a different instance that wraps
the source sequence and add behavior. That is why the preferred way of using
operators is to <em>chain</em> the calls.</p>
</div>
<div class="paragraph">
<p>Reactor操作符是装饰。 它们返回一个不同的实例，该实例包裹源序列并添加行为。
这就是为什么使用运算符的首选方法是将通过调用链接起来。</p>
</div>
<div class="paragraph">
<p>Compare the following two examples:</p>
</div>
<div class="paragraph">
<p>比较以下两个示例：</p>
</div>
<div class="exampleblock">
<div class="content">

</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux.just("something", "chain");
flux.map(secret -&gt; secret.replaceAll(".", "*")); <i class="conum" data-value="1"></i><b>(1)</b>
flux.subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The mistake is here. The result is not attached to the <code>flux</code> variable. 错误就在这里。结果未附加到flux变量。</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">

</div>
</div>
<div class="exampleblock">
<div class="title">Example 21. without chaining (correct) 没有链接（正确）</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux.just("something", "chain");
flux = flux.map(secret -&gt; secret.replaceAll(".", "*"));
flux.subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The following sample is even better (because it is simpler):
以下示例甚至更好（因为它更简单）：</p>
</div>
<div class="exampleblock">
<div class="content">

</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; secrets = Flux
  .just("something", "chain")
  .map(secret -&gt; secret.replaceAll(".", "*"))
  .subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>The first version outputs the following:
第一个版本输出以下内容：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Received: something
Received: chain</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>The two other versions output the expected values, as follows:
其他两个版本输出期望值，如下所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Received: *********
Received: *****</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="faq.monoThen" class="paragraph">
<p>== My <code>Mono</code> <code>zipWith</code> or <code>zipWhen</code> is never called</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">myMethod.process("a") // this method returns Mono&lt;Void&gt;
        .zipWith(myMethod.process("b"), combinator) //this is never called
        .subscribe();</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>If the source <code>Mono</code> is either <code>empty</code> or a <code>Mono&lt;Void&gt;</code> (a <code>Mono&lt;Void&gt;</code> is
empty for all intents and purposes), some combinations are never called.</p>
</div>
<div class="paragraph">
<p>This is the typical case for any transformer such as the <code>zip</code> static method or
the <code>zipWith</code> <code>zipWhen</code> operators, which (by definition) need an element from each
source to produce their output.</p>
</div>
<div class="paragraph">
<p>Using data-suppressing operators on sources of <code>zip</code> is thus problematic.
Examples of data-suppressing operators include <code>then()</code>, <code>thenEmpty(Publisher&lt;Void&gt;)</code>,
<code>ignoreElements()</code> and <code>ignoreElement()</code>, and <code>when(Publisher&#8230;&#8203;)</code>.</p>
</div>
<div class="paragraph">
<p>Similarly, operators that use a <code>Function&lt;T,?&gt;</code> to tune their behavior, such as <code>flatMap</code>,
need at least one element to be emitted for the <code>Function</code> to have a chance
to apply. Applying these on an empty (or <code>&lt;Void&gt;</code>) sequence nevers produce an element.</p>
</div>
<div class="paragraph">
<p>You can use <code>.defaultIfEmpty(T)</code> and <code>.switchIfEmpty(Publisher&lt;T&gt;)</code> to
replace an empty sequence of <code>T</code> with a default value or a fallback <code>Publisher&lt;T&gt;</code> (respectively),
which could help avoid some of these situations. Note that this does not apply to
<code>Flux&lt;Void&gt;</code>/<code>Mono&lt;Void&gt;</code> sources, as you can only switch to another <code>Publisher&lt;Void&gt;</code>,
which is still guaranteed to be empty. The following example uses <code>defaultIfEmpty</code>:</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 22. use <code>defaultIfEmpty</code> before <code>zipWhen</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">myMethod.emptySequenceForKey("a") // this method returns empty Mono&lt;String&gt;
        .defaultIfEmpty("") // this converts empty sequence to just the empty String
        .zipWhen(aString -&gt; myMethod.process("b")) //this is called with the empty String
        .subscribe();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.retryWhen"><a class="anchor" href="#faq.retryWhen"></a>B.3. How to Use <code>retryWhen</code> to Emulate <code>retry(3)</code>?</h3>
<div class="paragraph">
<p>The <code>retryWhen</code> operator can be quite complex. Hopefully the following snippet of code
can help you understand how it works by attempting to emulate a simpler
<code>retry(3)</code>:</p>
</div>
<div class="paragraph">
<p>retryWhen运算符可能会相当复杂。希望以下代码片段可以通过尝试模拟更简单的代码来帮助您了解其工作原理 retry(3)：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux =
Flux.&lt;String&gt;error(new IllegalArgumentException())
    .retryWhen(companion -&gt; companion
    .zipWith(Flux.range(1, 4), <i class="conum" data-value="1"></i><b>(1)</b>
          (error, index) -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
            if (index &lt; 4) return index; <i class="conum" data-value="3"></i><b>(3)</b>
            else throw Exceptions.propagate(error); <i class="conum" data-value="4"></i><b>(4)</b>
          })
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Trick one: use <code>zip</code> and a <code>range</code> of "number of acceptable retries + 1".	技巧一：使用zip和range“可接受的重试次数+ 1”</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>zip</code> function lets you count the retries while keeping track of the original
error.	该zip功能可让您计算重试次数，同时跟踪原始错误</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>To allow for three retries, indexes before 4 return a value to emit.为了允许进行三次重试，4之前的索引将返回一个要发出的值</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In order to terminate the sequence in error, we throw the original exception after
these three retries. 为了终止错误的序列，我们在这三个重试之后抛出了原始异常</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.exponentialBackoff"><a class="anchor" href="#faq.exponentialBackoff"></a>B.4. How can I use <code>retryWhen</code> for Exponential Backoff?</h3>
<div class="paragraph">
<p>指数补偿产生重试尝试，每次尝试之间的延迟越来越大，以避免使源系统过载，并冒全面崩溃的风险。
理由是，如果源产生错误，它已经处于不稳定状态，不太可能立即从中恢复。 因此，盲目地立即重试可能会产生另一个错误，并增加不稳定性。</p>
</div>
<div class="paragraph">
<p>Since <code>3.2.0.RELEASE</code>, Reactor comes with such a retry baked in: <code>Flux.retryBackoff</code>.</p>
</div>
<div class="paragraph">
<p>从3.3.4开始。 反应堆配备了一个构建器来进行这样的重试，<code>Flux.retryBackoff</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to implement an exponential backoff with <code>retryWhen</code>.
It delays retries and increases the delay between each attempt (pseudocode:
delay = attempt number * 100 milliseconds):</p>
</div>
<div class="paragraph">
<p>下面的示例展示了构建器的简单使用，在重试尝试延迟之前和之后都有钩子日志消息。
它延迟重试并增加每次尝试之间的延迟（伪代码：延迟=尝试数*100毫秒）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AtomicInteger errorCount = new AtomicInteger();
Flux&lt;String&gt; flux =
Flux.&lt;String&gt;error(new IllegalStateException("boom"))
		.doOnError(e -&gt; {  <i class="conum" data-value="1"></i><b>(1)</b>
			errorCount.incrementAndGet();
			System.out.println(e + " at " + LocalTime.now());
		})
		.retryWhen(Retry
				.backoff(3, Duration.ofMillis(100)).jitter(0d) <i class="conum" data-value="2"></i><b>(2)</b>
				.doAfterRetry(rs -&gt; System.out.println("retried at " + LocalTime.now())) <i class="conum" data-value="3"></i><b>(3)</b>
				.onRetryExhaustedThrow((spec, rs) -&gt; rs.failure()) <i class="conum" data-value="4"></i><b>(4)</b>
		);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We will log the time of errors emitted by the source and count them. 	我们将记录源发出的错误的时间并计数它们。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We configure an exponential backoff retry with at most 3 attempts and no jitter. 我们配置一个指数备份重试，最多3次尝试，没有抖动。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We also log the time at which the retry happens. 我们还记录了重试发生的时间。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>By default an Exceptions.retryExhausted exception would be thrown, with the last failure() as a cause. Here we customize that to directly emit the cause as onError. 默认情况下，Exceptions.retryExhausted 异常将被抛出，最后一个failure()作为原因。 在这里，我们自定义它，以直接发出原因作为错误。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>When subscribed to, this fails and terminates after printing out the following:
如果订阅，则失败并在打印出以下内容后终止：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>java.lang.IllegalArgumentException at 18:02:29.338
retried at 18:02:29.459 <i class="conum" data-value="1"></i><b>(1)</b>
java.lang.IllegalArgumentException at 18:02:29.460
retried at 18:02:29.663 <i class="conum" data-value="2"></i><b>(2)</b>
java.lang.IllegalArgumentException at 18:02:29.663
retried at 18:02:29.964 <i class="conum" data-value="3"></i><b>(3)</b>
java.lang.IllegalArgumentException at 18:02:29.964</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>大约100毫秒后第一次重试</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>大约200毫秒后的第二次重试</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>大约300毫秒后的第三次重试</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.thread-affinity-publishon"><a class="anchor" href="#faq.thread-affinity-publishon"></a>B.5. How Do I Ensure Thread Affinity when I Use <code>publishOn()</code>?</h3>
<div class="paragraph">
<p>As described in <a href="#schedulers">Schedulers</a>, <code>publishOn()</code> can be used to switch
execution contexts. The <code>publishOn</code> operator influences the threading context
where the rest of the operators in the chain below it run, up to a new
occurrence of <code>publishOn</code>. So the placement of <code>publishOn</code> is significant.</p>
</div>
<div class="paragraph">
<p>正如调度程序中所描述的，`publishOn()`可用于切换执行上下文。 这个`publishOn()`操作符影响线程上下文，其中它下面的链中的其他操作符运行，
直到发布新的`publishOn`出现。 因此，`publishOn`的位置是重要的。</p>
</div>
<div class="paragraph">
<p>Consider the following example:
考虑以下例子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">EmitterProcessor&lt;Integer&gt; processor = EmitterProcessor.create();
processor.publishOn(scheduler1)
         .map(i -&gt; transform(i))
         .publishOn(scheduler2)
         .doOnNext(i -&gt; processNext(i))
         .subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>transform</code> function in <code>map()</code> is
run on a worker of <code>scheduler1</code>, and the <code>processNext</code> method in
<code>doOnNext()</code> is run on a worker of <code>scheduler2</code>. Each subscription gets
its own worker, so all elements pushed to the corresponding subscriber are published
on the same <code>Thread</code>.</p>
</div>
<div class="paragraph">
<p>`map()`中的`transform`函数在`调度程序1`的上运行，而在`doOnNext()`中的`processNext`方法在调度程序2上运行。
每个订阅都有自己的工作人员，因此推送到相应订阅者的所有元素都发布在同一个线程上。</p>
</div>
<div class="paragraph">
<p>You can use single-threaded schedulers to ensure thread affinity for different stages in the
chain or for different subscribers.</p>
</div>
<div class="paragraph">
<p>您可以使用单线程调度程序来确保链中不同阶段或不同订阅者的线程亲和力。</p>
</div>
</div>
<div class="sect2">
<h3 id="faq.mdc"><a class="anchor" href="#faq.mdc"></a>B.6. What Is a Good Pattern for Contextual Logging? (MDC)</h3>
<div class="paragraph">
<p>Most logging frameworks allow contextual logging, letting users store variables that are reflected in the logging pattern, generally by way of a <code>Map</code> called the MDC ("Mapped Diagnostic Context").
This is one of the most recurring use of <code>ThreadLocal</code> in Java, and as a consequence this pattern assumes that the code being logged is tied in a one-to-one relationship with a <code>Thread</code>.</p>
</div>
<div class="paragraph">
<p>大多数日志框架允许上下文日志记录，允许用户存储日志模式中反映的变量，通常是通过名为MDC的Map（“Mapped Diagnostic Context”）。
这是Java中最经常使用ThreadLocal的方法之一，因此，这种模式假设正在记录的代码与Thread进行一对一的关系绑定。</p>
</div>
<div class="paragraph">
<p>That might have been a safe assumption to make before Java 8, but with the advent of functional programming elements in the Java language things have changed a bit&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>在Java8之前，这可能是一个安全的假设，但是随着Java语言中函数编程元素的出现，事情发生了一些变化&#8230;&#8203;​。</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take the example of a API that was imperative and used the template method pattern, then switches to a more functional style.
With the template method pattern, inheritance was at play. Now in its more functional approach, higher order functions are passed to define the "steps" of the algorithm.
Things are now more declarative than imperative, and that frees the library to make decisions about where each step should run.
For instance, knowing which steps of the underlying algorithm can be parallelized, the library can use an <code>ExecutorService</code> to execute some of the steps in parallel.</p>
</div>
<div class="paragraph">
<p>让我们举一个API的例子，它是必需的，并使用模板方法模式，然后切换到一个更实用的样式。
使用模板方法模式，继承正在发挥作用。 现在，在其更多的功能方法中，传递高阶函数来定义算法的“步骤”。
事情现在更多的是陈述性的而不是命令性的，这使得库可以自由地决定每个步骤应该运行在哪里。
例如，知道底层算法的哪些步骤可以并行化，库可以使用`ExecutorService`并行执行一些步骤。</p>
</div>
<div class="paragraph">
<p>One concrete example of such a functional API is the <code>Stream</code> API introduced in Java 8 and its <code>parallel()</code> flavor.
Logging with a MDC in a parallel <code>Stream</code> is not a free lunch: one need to ensure the MDC is captured and reapplied in each step.</p>
</div>
<div class="paragraph">
<p>这种功能API的一个具体例子是Java8中引入的StreamAPI及`parallel()`风味。
在平行的`Stream`中通过MDC记录信息并不是免费午餐，需要确保在每个步骤中捕获和重新应用 MDC。</p>
</div>
<div class="paragraph">
<p>The functional style enables such optimizations, because each step is thread-agnostic and referentially transparent, but it can break the MDC assumption of a single <code>Thread</code>.
The most idiomatic way of ensuring any kind of contextual information is accessible to all stages would be to pass that context around through the composition chain.
During the development of Reactor we encountered the same general class of problem, and we wanted to avoid this very hands-down and explicit approach.
This is why the <code>Context</code> was introduced: it propagates through the execution chain as long as <code>Flux</code> and <code>Mono</code> are used as the return value, by letting stages (operators) peek at the <code>Context</code> of their downstream stage.
So instead of using <code>ThreadLocal</code>, Reactor offers this map-like object that is tied to a <code>Subscription</code> and not a <code>Thread</code>.</p>
</div>
<div class="paragraph">
<p>功能样式允许这样的优化，因为每个步骤都是线程不可知的和区域透明的，但它可以打破单个线程的MDC假设。
确保所有阶段都能获得任何类型的上下文信息的最惯用的方法是通过组合链传递这种上下文。
在Reactor的发展过程中，我们遇到了同样的一般问题，我们希望避免这种非常直接和明确的方法。
这就是为什么引入`Context`：它通过执行链传播，只要Flux和Mono被用作返回值，就可以让阶段（运算符）窥视其下游阶段的上下文。
因此，`Reactor`没有使用ThreadLocal，而是提供了这个与订阅而不是线程绑定的类似映射的对象。</p>
</div>
<div class="paragraph">
<p>Now that we&#8217;ve established that MDC "just working" is not the best assumption to make in a declarative API, how can we perform contextualized log statements in relation to events in a Reactive Stream (<code>onNext</code>, <code>onError</code>, and <code>onComplete</code>)?</p>
</div>
<div class="paragraph">
<p>既然我们已经确定MDC“只是能用”不是在声明性API中做出的最佳使用，那么我们如何才能对Reactive中的事件执行上下文化的日志声明 (<code>onNext</code>, <code>onError</code>, and <code>onComplete</code>)？</p>
</div>
<div class="paragraph">
<p>This entry of the FAQ offers a possible intermediate solution when one wants to log in relation to these signals in a straightforward and explicit manner.
Make sure to read the <a href="#context">Adding a Context to a Reactive Sequence</a> section beforehand, and especially how a write must happen towards the bottom of the operator chain for operators above it to see it.</p>
</div>
<div class="paragraph">
<p>当一个人希望以直接和明确的方式记录这些信号时，常见问题的这一条目提供了一个可能的中间解决方案。
确保事先阅读添加上下文到反应性序列部分，特别是写必须如何发生在操作符链的底部，以便上面的操作符看到它。</p>
</div>
<div class="paragraph">
<p>To get contextual information from the <code>Context</code> to the MDC, the simplest way is to wrap logging statements in a <code>doOnEach</code> operator with a little bit of boilerplate code.
This boilerplate depends on both the logging framework/abstraction of your choice and the information you want to put in the MDC, so it has to be in your codebase.</p>
</div>
<div class="paragraph">
<p>要从上下文中获取上下信息到MDC，最简单的方法是用一点点样板代码将日志语句包装在每个操作符上。
这个样板取决于您选择的日志框架/抽象以及您想在MDC中放置的信息，因此它必须位于代码库中。</p>
</div>
<div class="paragraph">
<p>The following is an example of such a helper function around a single MDC variable and focused on logging <code>onNext</code> events, using Java 9 enhanced <code>Optional</code> API:</p>
</div>
<div class="paragraph">
<p>下面是围绕单个MDC变量的这种辅助函数的示例，重点是使用Java9增强的可选的API记录 <code>onNext</code> 事件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static &lt;T&gt; Consumer&lt;Signal&lt;T&gt;&gt; logOnNext(Consumer&lt;T&gt; logStatement) {
	return signal -&gt; {
		if (!signal.isOnNext()) return; <i class="conum" data-value="1"></i><b>(1)</b>
		Optional&lt;String&gt; toPutInMdc = signal.getContext().getOrEmpty("CONTEXT_KEY"); <i class="conum" data-value="2"></i><b>(2)</b>

		toPutInMdc.ifPresentOrElse(tpim -&gt; {
			try (MDC.MDCCloseable cMdc = MDC.putCloseable("MDC_KEY", tpim)) { <i class="conum" data-value="3"></i><b>(3)</b>
				logStatement.accept(signal.get()); <i class="conum" data-value="4"></i><b>(4)</b>
			}
		},
		() -&gt; logStatement.accept(signal.get())); <i class="conum" data-value="5"></i><b>(5)</b>
	};
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>doOnEach信号包括onComplete和onError。在此示例中，我们仅对日志记录感兴趣`onNext`</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们将从反Reactor上下文中提取一个有趣的值(参见<a href="#context.api">The <code>Context</code> API</a>部分)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在本例中，我们使用SLF4J2中的MDCClose，允许在日志语句执行后使用try-withresource语法自动清理MDC。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>正确的日志声明由调用者 Consumer&lt;T&gt;（下一个值的消费者）提供</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>如果预期的键没有设置在上下文中，我们使用替代路径，其中在MDC中没有任何内容</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Using this boilerplate code ensures that we are good citizens with the MDC: we set a key right before we execute a logging statement and remove it immediately after.
There is no risk of polluting the MDC for subsequent logging statements.</p>
</div>
<div class="paragraph">
<p>使用这个样板代码可以确保我们是MDC的好公民：我们在执行日志记录语句之前设置了一个键，并在之后立即删除它。
没有污染MDC的风险，以便随后的日志记录。</p>
</div>
<div class="paragraph">
<p>Of course, this is a suggestion. You might be interested in extracting multiple values from the <code>Context</code> or in logging things in case of <code>onError</code>.
You might want to create additional helper methods for these cases or craft a single method that makes use of additional lambdas to cover more ground.</p>
</div>
<div class="paragraph">
<p>当然，这是个建议。 您可能有兴趣从上下文中提取多个值，或者在发生错误的情况下记录事物。
您可能希望为这些案例创建额外的辅助方法，或者创建一个使用额外lambdas覆盖更多范围的单一方法。</p>
</div>
<div class="paragraph">
<p>In any case, the usage of the preceding helper method could look like the following reactive web controller:</p>
</div>
<div class="paragraph">
<p>在任何情况下，前面的helper方法的使用可能看起来像以下reactive web 控制器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/byPrice")
public Flux&lt;Restaurant&gt; byPrice(@RequestParam Double maxPrice, @RequestHeader(required = false, name = "X-UserId") String userId) {
	String apiId = userId == null ? "" : userId; <i class="conum" data-value="1"></i><b>(1)</b>

	return restaurantService.byPrice(maxPrice))
			   .doOnEach(logOnNext(r -&gt; LOG.debug("found restaurant {} for ${}", <i class="conum" data-value="2"></i><b>(2)</b>
					r.getName(), r.getPricePerPerson())))
			   .subscriberContext(Context.of("CONTEXT_KEY", apiId)); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们需要从请求头获取上下文信息，以便将其放入上下文中</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在这里，我们应用我们的助手方法到Flux，使用doOnEach。 记住：操作符看到它们下面定义的上下文值。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们使用所选的键CONTEXT_KEY将值从标题 写入上下文。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>In this configuration, the <code>restaurantService</code> can emit its data on a shared thread, yet the logs will still reference the correct <code>X-UserId</code> for each request.</p>
</div>
<div class="paragraph">
<p>在此配置中，<code>restaurantService`可以在共享线程上发出其数据，但是日志仍然会为每个请求引用正确的`X-UserID</code>。</p>
</div>
<div class="paragraph">
<p>For completeness, we can also see what an error-logging helper could look like:</p>
</div>
<div class="paragraph">
<p>为了完整起见，我们还可以看到错误记录助手的外观：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static Consumer&lt;Signal&lt;?&gt;&gt; logOnError(Consumer&lt;Throwable&gt; errorLogStatement) {
	return signal -&gt; {
		if (!signal.isOnError()) return;
		Optional&lt;String&gt; toPutInMdc = signal.getContext().getOrEmpty("CONTEXT_KEY");

		toPutInMdc.ifPresentOrElse(tpim -&gt; {
			try (MDC.MDCCloseable cMdc = MDC.putCloseable("MDC_KEY", tpim)) {
				errorLogStatement.accept(signal.getThrowable());
			}
		},
		() -&gt; errorLogStatement.accept(signal.getThrowable()));
	};
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Nothing much has changed, except for the fact that we check that the <code>Signal</code> is effectively an <code>onError</code>, and that we provide said error (a <code>Throwable</code>) to the log statement lambda.</p>
</div>
<div class="paragraph">
<p>没有什么变化，除了我们检查信号实际上是一个`onError`，以及我们向日志声明的lambda提供所说的错误（一个可抛出的）。</p>
</div>
<div class="paragraph">
<p>Applying this helper in the controller is very similar to what we&#8217;ve done before:</p>
</div>
<div class="paragraph">
<p>在控制器中应用这个助手与我们以前所做的非常相似：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/byPrice")
public Flux&lt;Restaurant&gt; byPrice(@RequestParam Double maxPrice, @RequestHeader(required = false, name = "X-UserId") String userId) {
	String apiId = userId == null ? "" : userId;

	return restaurantService.byPrice(maxPrice))
			   .doOnEach(logOnNext(v -&gt; LOG.info("found restaurant {}", v))
			   .doOnEach(logOnError(e -&gt; LOG.error("error when searching restaurants", e)) <i class="conum" data-value="1"></i><b>(1)</b>
			   .subscriberContext(Context.of("CONTEXT_KEY", apiId));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In case the <code>restaurantService</code> emits an error, it will be logged with MDC context here 如果`restaurantService`发出错误，它将在这里使用MDC上下文中记录</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/faq.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#faq">FAQ, Best Practices, and "How do I&#8230;&#8203;?"</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactor-extra"><a class="anchor" href="#reactor-extra"></a>Appendix C: Reactor-Extra</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>reactor-extra</code> artifact contains additional operators and utilities that are for
users of <code>reactor-core</code> with advanced needs.</p>
</div>
<div class="paragraph">
<p>As this is a separate artifact, you need to explicitly add it to your build. The following
example shows how to do so in Gradle:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
     compile 'io.projectreactor:reactor-core'
     compile 'io.projectreactor.addons:reactor-extra' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Add the reactor extra artifact in addition to core. See <a href="#getting">Getting Reactor</a> for details
about why you do not need to specify a version if you use the BOM, usage in Maven, and other details.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extra-tuples"><a class="anchor" href="#extra-tuples"></a>C.1. <code>TupleUtils</code> and Functional Interfaces</h3>
<div class="paragraph">
<p>The <code>reactor.function</code> package contains functional interfaces that complement the Java 8
<code>Function</code>, <code>Predicate</code>, and <code>Consumer</code> interfaces, for three to eight values.</p>
</div>
<div class="paragraph">
<p><code>TupleUtils</code> offers static methods that act as a bridge between lambdas of these functional
interfaces to a similar interface on the corresponding <code>Tuple</code>.</p>
</div>
<div class="paragraph">
<p>This lets you easily work with independent parts of any <code>Tuple</code>, as the following example shows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">.map(tuple -&gt; {
  String firstName = tuple.getT1();
  String lastName = tuple.getT2();
  String address = tuple.getT3();

  return new Customer(firstName, lastName, address);
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can rewrite the preceding example as follows:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">.map(TupleUtils.function(Customer::new)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>(as <code>Customer</code> constructor conforms to <code>Consumer3</code> functional interface signature)</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extra-math"><a class="anchor" href="#extra-math"></a>C.2. Math Operators With <code>MathFlux</code></h3>
<div class="paragraph">
<p>The <code>reactor.math</code> package contains a <code>MathFlux</code> specialized version of <code>Flux</code> that offers
mathematical operators, including <code>max</code>, <code>min</code>, <code>sumInt</code>, <code>averageDouble</code>, and others.</p>
</div>
</div>
<div class="sect2">
<h3 id="extra-repeat-retry"><a class="anchor" href="#extra-repeat-retry"></a>C.3. Repeat and Retry Utilities</h3>
<div class="paragraph">
<p>The <code>reactor.retry</code> package contains utilities to help in writing <code>Flux#repeatWhen</code> and
<code>Flux#retryWhen</code> functions. The entry points are factory methods in the <code>Repeat</code>
and <code>Retry</code> interfaces, respectively.</p>
</div>
<div class="paragraph">
<p>You can use both interfaces as a mutative builder, and they implement the correct
<code>Function</code> signature to be used in their counterpart operators.</p>
</div>
<div class="paragraph">
<p>Since 3.2.0, one of the most advanced retry strategies offered by these utilities is
also part of the <code>reactor-core</code> main artifact directly. Exponential backoff is
available as the <code>Flux#retryBackoff</code> operator.</p>
</div>
</div>
<div class="sect2">
<h3 id="extra-schedulers"><a class="anchor" href="#extra-schedulers"></a>C.4. Schedulers</h3>
<div class="paragraph">
<p>Reactor-extra comes with several specialized schedulers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ForkJoinPoolScheduler</code> (in the <code>reactor.scheduler.forkjoin</code> package): Uses the Java <code>ForkJoinPool</code> to execute tasks.</p>
</li>
<li>
<p><code>SwingScheduler</code> (in the <code>reactor.swing</code> package): Runs tasks in the Swing UI event loop thread, the <code>EDT</code>.</p>
</li>
<li>
<p><code>SwtScheduler</code> (in the <code>reactor.swing</code> package): Runs tasks in the SWT UI event loop thread.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/apdx-reactorExtra.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#reactor-extra">Reactor-Extra</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-02-23 13:48:49 +0800
</div>
</div>
</body>
</html>